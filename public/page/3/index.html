<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>cliff&#39;s personal blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="cliff&#39;s personal blog">
<meta property="og:url" content="https://cliff0412.github.io/page/3/index.html">
<meta property="og:site_name" content="cliff&#39;s personal blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cliff">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="cliff's personal blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">cliff&#39;s personal blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cliff0412.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-cpp/types" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/15/cpp/types/" class="article-date">
  <time class="dt-published" datetime="2023-11-15T03:35:20.000Z" itemprop="datePublished">2023-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/15/cpp/types/">cpp types</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Conversion-Operator"><a href="#Conversion-Operator" class="headerlink" title="Conversion Operator"></a>Conversion Operator</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyIntegerWrapper</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">MyIntegerWrapper</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Conversion operator to int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyIntegerWrapper <span class="title">myObj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implicit conversion using the conversion operator</span></span><br><span class="line">    <span class="type">int</span> intValue = myObj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Implicit Conversion: &quot;</span> &lt;&lt; intValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explicit conversion using static_cast</span></span><br><span class="line">    <span class="type">double</span> doubleValue = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(myObj);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Explicit Conversion: &quot;</span> &lt;&lt; doubleValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/11/15/cpp/types/" data-id="clp8cm0w60006l57u0fvme5s2" data-title="cpp types" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/zkp/plonky2-code-analysis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/06/cryptography/zkp/plonky2-code-analysis/" class="article-date">
  <time class="dt-published" datetime="2023-11-06T05:24:03.000Z" itemprop="datePublished">2023-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/06/cryptography/zkp/plonky2-code-analysis/">plonky2 code analysis</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>this post is a source code analysis of <a target="_blank" rel="noopener" href="https://github.com/0xPolygonZero/plonky2">https://github.com/0xPolygonZero/plonky2</a></p>
<h2 id="0-field"><a href="#0-field" class="headerlink" title="0. field"></a>0. field</h2><p>the lde in proving stage is conducted on extension field</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Field</span> &#123;</span><br><span class="line"><span class="comment">/// The 2-adicity of this field&#x27;s multiplicative group. a two-adicity of 32 means that there&#x27;s a multiplicative subgroup of size 2^32 that exists in the field.</span></span><br><span class="line"><span class="keyword">const</span> TWO_ADICITY: <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sage:</span></span><br><span class="line"><span class="comment">// ```</span></span><br><span class="line"><span class="comment">// g_2 = g^((p - 1) / 2^32)</span></span><br><span class="line"><span class="comment">// g_2.multiplicative_order().factor()</span></span><br><span class="line"><span class="comment">// ```</span></span><br><span class="line"><span class="keyword">const</span> POWER_OF_TWO_GENERATOR: <span class="keyword">Self</span> = <span class="title function_ invoke__">Self</span>(<span class="number">1753635133440165772</span>);  <span class="comment">// POWER_OF_TWO_GENERATOR^&#123;2^32&#125; = 1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Field</span> <span class="keyword">for</span> <span class="title class_">GoldilocksField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> TWO_ADICITY: <span class="type">usize</span> = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sage: `g = GF(p).multiplicative_generator()`</span></span><br><span class="line">    <span class="keyword">const</span> MULTIPLICATIVE_GROUP_GENERATOR: <span class="keyword">Self</span> = <span class="title function_ invoke__">Self</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sage:</span></span><br><span class="line">    <span class="comment">// ```</span></span><br><span class="line">    <span class="comment">// g_2 = g^((p - 1) / 2^32)</span></span><br><span class="line">    <span class="comment">// g_2.multiplicative_order().factor()</span></span><br><span class="line">    <span class="comment">// ```</span></span><br><span class="line">    <span class="keyword">const</span> POWER_OF_TWO_GENERATOR: <span class="keyword">Self</span> = <span class="title function_ invoke__">Self</span>(<span class="number">1753635133440165772</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">FieldExtension</span>&lt;<span class="keyword">const</span> D: <span class="type">usize</span>&gt;: Field &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">BaseField</span>: Field;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_basefield_array</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> [<span class="keyword">Self</span>::BaseField; D];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_basefield_array</span>(arr: [<span class="keyword">Self</span>::BaseField; D]) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">QuadraticExtension</span>&lt;F: Extendable&lt;<span class="number">2</span>&gt;&gt;(<span class="keyword">pub</span> [F; <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">impl</span>&lt;F: Extendable&lt;<span class="number">2</span>&gt;&gt; FieldExtension&lt;<span class="number">2</span>&gt; <span class="keyword">for</span> <span class="title class_">QuadraticExtension</span>&lt;F&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Optimal extension field trait.</span></span><br><span class="line"><span class="comment">/// A degree `d` field extension is optimal if there exists a base field element `W`,</span></span><br><span class="line"><span class="comment">/// such that the extension is `F[X]/(X^d-W)`.</span></span><br><span class="line"><span class="meta">#[allow(clippy::upper_case_acronyms)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">OEF</span>&lt;<span class="keyword">const</span> D: <span class="type">usize</span>&gt;: FieldExtension&lt;D&gt; &#123;</span><br><span class="line">    <span class="comment">// Element W of BaseField, such that `X^d - W` is irreducible over BaseField.</span></span><br><span class="line">    <span class="keyword">const</span> W: <span class="keyword">Self</span>::BaseField;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Element of BaseField such that DTH_ROOT^D == 1. Implementors</span></span><br><span class="line">    <span class="comment">// should set this to W^((p - 1)/D), where W is as above and p is</span></span><br><span class="line">    <span class="comment">// the order of the BaseField.</span></span><br><span class="line">    <span class="keyword">const</span> DTH_ROOT: <span class="keyword">Self</span>::BaseField;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Extendable</span>&lt;<span class="keyword">const</span> D: <span class="type">usize</span>&gt;: Field + <span class="built_in">Sized</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Extension</span>: Field + OEF&lt;D, BaseField = <span class="keyword">Self</span>&gt; + Frobenius&lt;D&gt; + <span class="built_in">From</span>&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> W: <span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> DTH_ROOT: <span class="keyword">Self</span>;  <span class="comment">// D-th root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Chosen so that when raised to the power `(p^D - 1) &gt;&gt; F::Extension::TWO_ADICITY)`</span></span><br><span class="line">    <span class="comment">/// we obtain F::EXT_POWER_OF_TWO_GENERATOR.</span></span><br><span class="line">    <span class="keyword">const</span> EXT_MULTIPLICATIVE_GROUP_GENERATOR: [<span class="keyword">Self</span>; D];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Chosen so that when raised to the power `1&lt;&lt;(Self::TWO_ADICITY-Self::BaseField::TWO_ADICITY)`,</span></span><br><span class="line">    <span class="comment">/// we get `Self::BaseField::POWER_OF_TWO_GENERATOR`. This makes `primitive_root_of_unity` coherent</span></span><br><span class="line">    <span class="comment">/// with the base field which implies that the FFT commutes with field inclusion.</span></span><br><span class="line">    <span class="keyword">const</span> EXT_POWER_OF_TWO_GENERATOR: [<span class="keyword">Self</span>; D];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Extendable</span>&lt;<span class="number">2</span>&gt; <span class="keyword">for</span> <span class="title class_">GoldilocksField</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Extension</span> = QuadraticExtension&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verifiable in Sage with</span></span><br><span class="line">    <span class="comment">// `R.&lt;x&gt; = GF(p)[]; assert (x^2 - 7).is_irreducible()`.</span></span><br><span class="line">    <span class="keyword">const</span> W: <span class="keyword">Self</span> = <span class="title function_ invoke__">Self</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DTH_ROOT = W^((ORDER - 1)/2), DTH_ROOT^D = 1</span></span><br><span class="line">    <span class="keyword">const</span> DTH_ROOT: <span class="keyword">Self</span> = <span class="title function_ invoke__">Self</span>(<span class="number">18446744069414584320</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> EXT_MULTIPLICATIVE_GROUP_GENERATOR: [<span class="keyword">Self</span>; <span class="number">2</span>] =</span><br><span class="line">        [<span class="title function_ invoke__">Self</span>(<span class="number">18081566051660590251</span>), <span class="title function_ invoke__">Self</span>(<span class="number">16121475356294670766</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> EXT_POWER_OF_TWO_GENERATOR: [<span class="keyword">Self</span>; <span class="number">2</span>] = [<span class="title function_ invoke__">Self</span>(<span class="number">0</span>), <span class="title function_ invoke__">Self</span>(<span class="number">15659105665374529263</span>)]; <span class="comment">// EXT_POWER_OF_TWO_GENERATOR^&#123;2^32&#125; = 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Mul</span> <span class="keyword">for</span> <span class="title class_">QuadraticExtension</span>&lt;GoldilocksField&gt; &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mul</span>(<span class="keyword">self</span>, rhs: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Self</span>([a0, a1]) = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Self</span>([b0, b1]) = rhs;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">ext2_mul</span>([a0.<span class="number">0</span>, a1.<span class="number">0</span>], [b0.<span class="number">0</span>, b1.<span class="number">0</span>]);</span><br><span class="line">        <span class="title function_ invoke__">Self</span>(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Let `F_D` be the optimal extension field `F[X]/(X^D-W)`. Then `ExtensionAlgebra&lt;F_D&gt;` is the quotient `F_D[X]/(X^D-W)`.</span></span><br><span class="line"><span class="comment">/// It&#x27;s a `D`-dimensional algebra over `F_D` useful to lift the multiplication over `F_D` to a multiplication over `(F_D)^D`.</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ExtensionAlgebra</span>&lt;F: OEF&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt;(<span class="keyword">pub</span> [F; D]);  <span class="comment">// F is extension field composing D base Fields, [F; D] is an array of F, with size D</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: OEF&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt; ExtensionAlgebra&lt;F, D&gt; &#123;</span><br><span class="line">    <span class="comment">/// mul extension field wiht a base field</span></span><br><span class="line">     <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">scalar_mul</span>(&amp;<span class="keyword">self</span>, scalar: F) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span> = <span class="keyword">self</span>.<span class="number">0</span>;</span><br><span class="line">        res.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">for_each</span>(|x| &#123;</span><br><span class="line">            *x *= scalar;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="title function_ invoke__">Self</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement the multiplciation of two extension field</span></span><br><span class="line"><span class="keyword">impl</span>&lt;F: OEF&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt; Mul <span class="keyword">for</span> <span class="title class_">ExtensionAlgebra</span>&lt;F, D&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = <span class="keyword">Self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mul</span>(<span class="keyword">self</span>, rhs: <span class="keyword">Self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span> = [F::ZERO; D];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">w</span> = F::<span class="title function_ invoke__">from_basefield</span>(F::W);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..D &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">j</span> <span class="keyword">in</span> <span class="number">0</span>..D &#123;</span><br><span class="line">                res[(i + j) % D] += <span class="keyword">if</span> i + j &lt; D &#123;</span><br><span class="line">                    <span class="keyword">self</span>.<span class="number">0</span>[i] * rhs.<span class="number">0</span>[j]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    w * <span class="keyword">self</span>.<span class="number">0</span>[i] * rhs.<span class="number">0</span>[j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Self</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-Config"><a href="#1-Config" class="headerlink" title="1. Config"></a>1. Config</h2><h3 id="1-1-CircuitConfig"><a href="#1-1-CircuitConfig" class="headerlink" title="1.1 CircuitConfig"></a>1.1 CircuitConfig</h3><p>the default config is <code>Self::standard_recursion_config()</code> with value as below</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Self</span> &#123;</span><br><span class="line">  num_wires: <span class="number">135</span>,</span><br><span class="line">  num_routed_wires: <span class="number">80</span>, </span><br><span class="line">  num_constants: <span class="number">2</span>,  <span class="comment">// used in ConstantGate, which hold the consant value for the circuit</span></span><br><span class="line">  <span class="comment">/// Whether to use a dedicated gate for base field arithmetic, rather than using a single gate</span></span><br><span class="line">  <span class="comment">/// for both base field and extension field arithmetic.</span></span><br><span class="line">  use_base_arithmetic_gate: <span class="literal">true</span>,</span><br><span class="line">  security_bits: <span class="number">100</span>,</span><br><span class="line">  <span class="comment">/// The number of challenge points to generate, for IOPs that have soundness errors of (roughly)</span></span><br><span class="line">  <span class="comment">/// `degree / |F|`.</span></span><br><span class="line">  num_challenges: <span class="number">2</span>,</span><br><span class="line">  zero_knowledge: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">/// A cap on the quotient polynomial&#x27;s degree factor. The actual degree factor is derived</span></span><br><span class="line">  <span class="comment">/// systematically, but will never exceed this value.</span></span><br><span class="line">  max_quotient_degree_factor: <span class="number">8</span>,</span><br><span class="line">  fri_config: FriConfig &#123;</span><br><span class="line">      rate_bits: <span class="number">3</span>,  <span class="comment">// used in lde</span></span><br><span class="line">      cap_height: <span class="number">4</span>,</span><br><span class="line">      proof_of_work_bits: <span class="number">16</span>,</span><br><span class="line">      reduction_strategy: FriReductionStrategy::<span class="title function_ invoke__">ConstantArityBits</span>(<span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">      num_query_rounds: <span class="number">28</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>notes</strong></p>
<ul>
<li><p><em>routable wire</em> It’s a wire that can be connected to other gates’ wires, rather than an “advice” wire which is for internal state. For example if we had a gate for computing x^8, we’d have two routable wires for the input and output, x and x^8. But if we wanted lower-degree constraints, we could add advice wires for the intermediate results x^2 and x^4</p>
</li>
<li><p><em>num_routed_wires</em>, the default value is 80. For eample, for a arithmetic gate, it computes <code>const_0 * multiplicand_0 * multiplicand_1 + const_1 * addend</code>. i.e 2 wires for multiplicands and 1 wire for the addend and 1 for output. total is 4. therefore, the gate can have <code>num_routed_wires/4</code> operations, in this case, it is 20. the circuit builder will add gate when number of operations exceeds 20.</p>
</li>
</ul>
<h3 id="1-2-FriConfig"><a href="#1-2-FriConfig" class="headerlink" title="1.2 FriConfig"></a>1.2 FriConfig</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">FriConfig</span> &#123;</span><br><span class="line"><span class="comment">/// `rate = 2^&#123;-rate_bits&#125;`. default is 3</span></span><br><span class="line"><span class="keyword">pub</span> rate_bits: <span class="type">usize</span>,  </span><br><span class="line"></span><br><span class="line"><span class="comment">/// Height of Merkle tree caps. default is 4</span></span><br><span class="line"><span class="keyword">pub</span> cap_height: <span class="type">usize</span>,</span><br><span class="line"><span class="comment">/// default is 16</span></span><br><span class="line"><span class="keyword">pub</span> proof_of_work_bits: <span class="type">u32</span>,</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> reduction_strategy: FriReductionStrategy,</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Number of query rounds to perform. default is 28</span></span><br><span class="line"><span class="keyword">pub</span> num_query_rounds: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Gates"><a href="#2-Gates" class="headerlink" title="2. Gates"></a>2. Gates</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A custom gate.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Gate</span>&lt;F: RichField + Extendable&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt;: <span class="symbol">&#x27;static</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">id</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">    <span class="comment">/// The maximum degree among this gate&#x27;s constraint polynomials. it is 3 for ArithmeticGate (Left, Right, Output); 7 for PoseidonGate, 1 for ConstantGate, PublicInputGate;</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">degree</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The generators used to populate the witness.</span></span><br><span class="line">    <span class="comment">/// Note: This should return exactly 1 generator per operation in the gate.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">generators</span>(&amp;<span class="keyword">self</span>, row: <span class="type">usize</span>, local_constants: &amp;[F]) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;WitnessGeneratorRef&lt;F, D&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Enables gates to store some &quot;routed constants&quot;, if they have both unused constants and</span></span><br><span class="line">    <span class="comment">/// unused routed wires.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Each entry in the returned `Vec` has the form `(constant_index, wire_index)`. `wire_index`</span></span><br><span class="line">    <span class="comment">/// must correspond to a *routed* wire.</span></span><br><span class="line">    <span class="comment">/// for ConstantGate, the size of vector is equal to num_of_consts, it&#x27;s empty for ArithmeticGate, PublicInputGate, and PoseidonGate</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">extra_constant_wires</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;(<span class="type">usize</span>, <span class="type">usize</span>)&gt; &#123;</span><br><span class="line">        <span class="built_in">vec!</span>[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-ArithmeticGate"><a href="#2-1-ArithmeticGate" class="headerlink" title="2.1 ArithmeticGate"></a>2.1 ArithmeticGate</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A gate which can perform a weighted multiply-add, i.e. `result = c0 x y + c1 z`. If the config</span></span><br><span class="line"><span class="comment">/// supports enough routed wires, it can support several such operations in one gate.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ArithmeticGate</span> &#123;</span><br><span class="line">    <span class="comment">/// Number of arithmetic operations performed by an arithmetic gate.</span></span><br><span class="line">    <span class="keyword">pub</span> num_ops: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>num_constants &#x3D; 2</li>
<li>degree &#x3D; 3 ( three inputs)</li>
<li>num_constraints &#x3D; num_ops, default 20</li>
</ul>
<h3 id="2-2-PodeidonGate"><a href="#2-2-PodeidonGate" class="headerlink" title="2.2 PodeidonGate"></a>2.2 PodeidonGate</h3><p>All pubic inputs are hashed into 4 Hash Output. Therefore, PoseidonGate is required</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Evaluates a full Poseidon permutation with 12 state elements.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This also has some extra features to make it suitable for efficiently verifying Merkle proofs.</span></span><br><span class="line"><span class="comment">/// It has a flag which can be used to swap the first four inputs with the next four, for ordering</span></span><br><span class="line"><span class="comment">/// sibling digests.</span></span><br><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PoseidonGate</span>&lt;F: RichField + Extendable&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt;(PhantomData&lt;F&gt;);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-ConstantGate"><a href="#2-2-ConstantGate" class="headerlink" title="2.2 ConstantGate"></a>2.2 ConstantGate</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A gate which takes a single constant parameter and outputs that value.</span></span><br><span class="line"><span class="comment">/// For example, constant `ONE` and `ZERO` is allocated for ArithmeticGate, then two constant generators are required if such ArithmeticGate is allocated. The ArithmeticGate only hold wires for multiplicant_1 multiplicant_2, addent, and output. the constants used is held in ConstantGate</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ConstantGate</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) num_consts: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// for constant gate, the evaluation is just input - wire output, the result should be 0</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">eval_unfiltered</span>(&amp;<span class="keyword">self</span>, vars: EvaluationVars&lt;F, D&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;F::Extension&gt; &#123;</span><br><span class="line">    (<span class="number">0</span>..<span class="keyword">self</span>.num_consts)</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|i| &#123;</span><br><span class="line">            vars.local_constants[<span class="keyword">self</span>.<span class="title function_ invoke__">const_input</span>(i)] - vars.local_wires[<span class="keyword">self</span>.<span class="title function_ invoke__">wire_output</span>(i)]</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>num_constants</code> (a configured value <code>num_consts</code>)</li>
<li><code>degree</code> &#x3D; 1 ( one inputs)</li>
<li><code>num_constraints</code> &#x3D; <code>num_constants</code></li>
</ul>
<h3 id="2-3-PublicInputGate"><a href="#2-3-PublicInputGate" class="headerlink" title="2.3 PublicInputGate"></a>2.3 PublicInputGate</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A gate whose first four wires will be equal to a hash of public inputs. the value 4 is hadcoded as the hash</span></span><br><span class="line"><span class="comment">/// out inputs is 4 Targets. PublicInputGate is aliased as pi gate</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PublicInputGate</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">PublicInputGate</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">wires_public_inputs_hash</span>() <span class="punctuation">-&gt;</span> Range&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">        <span class="number">0</span>..<span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>num_constants</code> &#x3D;0</li>
<li><code>degree</code> &#x3D; 1</li>
<li><code>num_constraints</code> &#x3D; 4</li>
</ul>
<h2 id="3-Circuit-Builder"><a href="#3-Circuit-Builder" class="headerlink" title="3. Circuit Builder"></a>3. Circuit Builder</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">CircuitBuilder</span>&lt;F: RichField + Extendable&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> config: CircuitConfig,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A domain separator, which is included in the initial Fiat-Shamir seed. This is generally not</span></span><br><span class="line">    <span class="comment">/// needed, but can be used to ensure that proofs for one application are not valid for another.</span></span><br><span class="line">    <span class="comment">/// Defaults to the empty vector.</span></span><br><span class="line">    domain_separator: <span class="type">Option</span>&lt;<span class="type">Vec</span>&lt;F&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The types of gates used in this circuit.</span></span><br><span class="line">    gates: HashSet&lt;GateRef&lt;F, D&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The concrete placement of each gate.</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) gate_instances: <span class="type">Vec</span>&lt;GateInstance&lt;F, D&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Targets to be made public.</span></span><br><span class="line">    public_inputs: <span class="type">Vec</span>&lt;Target&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The next available index for a `VirtualTarget`.</span></span><br><span class="line">    virtual_target_index: <span class="type">usize</span>,</span><br><span class="line"></span><br><span class="line">    copy_constraints: <span class="type">Vec</span>&lt;CopyConstraint&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A tree of named scopes, used for debugging.</span></span><br><span class="line">    context_log: ContextTree,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Generators used to generate the witness.</span></span><br><span class="line">    generators: <span class="type">Vec</span>&lt;WitnessGeneratorRef&lt;F, D&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// maps the constant value -&gt; ConstantTarget(a virtual target)</span></span><br><span class="line">    constants_to_targets: HashMap&lt;F, Target&gt;,</span><br><span class="line">    <span class="comment">/// an inverse map of the constants_to_targets</span></span><br><span class="line">    targets_to_constants: HashMap&lt;Target, F&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Memoized results of `arithmetic` calls.</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) base_arithmetic_results: HashMap&lt;BaseArithmeticOperation&lt;F&gt;, Target&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Memoized results of `arithmetic_extension` calls.</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) arithmetic_results: HashMap&lt;ExtensionArithmeticOperation&lt;F, D&gt;, ExtensionTarget&lt;D&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Map between gate type and the current gate of this type with available slots.</span></span><br><span class="line">    current_slots: HashMap&lt;GateRef&lt;F, D&gt;, CurrentSlot&lt;F, D&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// List of constant generators used to fill the constant wires.</span></span><br><span class="line">    constant_generators: <span class="type">Vec</span>&lt;ConstantGenerator&lt;F&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Rows for each LUT: LookupWire contains: first `LookupGate`, first `LookupTableGate`, last `LookupTableGate`.</span></span><br><span class="line">    lookup_rows: <span class="type">Vec</span>&lt;LookupWire&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// For each LUT index, vector of `(looking_in, looking_out)` pairs.</span></span><br><span class="line">    lut_to_lookups: <span class="type">Vec</span>&lt;Lookup&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lookup tables in the form of `Vec&lt;(input_value, output_value)&gt;`.</span></span><br><span class="line">    luts: <span class="type">Vec</span>&lt;LookupTable&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Optional common data. When it is `Some(goal_data)`, the `build` function panics if the resulting</span></span><br><span class="line">    <span class="comment">/// common data doesn&#x27;t equal `goal_data`.</span></span><br><span class="line">    <span class="comment">/// This is used in cyclic recursion.</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) goal_common_data: <span class="type">Option</span>&lt;CommonCircuitData&lt;F, D&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Optional verifier data that is registered as public inputs.</span></span><br><span class="line">    <span class="comment">/// This is used in cyclic recursion to hold the circuit&#x27;s own verifier key.</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) verifier_data_public_input: <span class="type">Option</span>&lt;VerifierCircuitTarget&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>virtual_target</strong>:  This is not an actual wire in the witness, but just a target that help facilitate witness generation. In particular, a generator can assign a values to a virtual target, which can then be copied to other (virtual or concrete) targets. When we generate the final witness (a grid of wire values), these virtual targets will go away.</li>
</ul>
<h3 id="3-1-methods"><a href="#3-1-methods" class="headerlink" title="3.1 methods"></a>3.1 methods</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds a gate to the circuit, and returns its index.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_gate</span>&lt;G: Gate&lt;F, D&gt;&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, gate_type: G, <span class="keyword">mut</span> constants: <span class="type">Vec</span>&lt;F&gt;) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns a routable target with the given constant value.</span></span><br><span class="line"><span class="comment">/// for example, for ArithmeticGate, at least constant of `ONE` and `ZERO` is allocated</span></span><br><span class="line"><span class="comment">/// those constant target are all virtual target</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">constant</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, c: F) <span class="punctuation">-&gt;</span> Target &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(&amp;target) = <span class="keyword">self</span>.constants_to_targets.<span class="title function_ invoke__">get</span>(&amp;c) &#123;</span><br><span class="line">        <span class="comment">// We already have a wire for this constant.</span></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">target</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">add_virtual_target</span>();</span><br><span class="line">    <span class="keyword">self</span>.constants_to_targets.<span class="title function_ invoke__">insert</span>(c, target);</span><br><span class="line">    <span class="keyword">self</span>.targets_to_constants.<span class="title function_ invoke__">insert</span>(target, c);</span><br><span class="line"></span><br><span class="line">    target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// get polynomial to constants for each gate</span></span><br><span class="line"><span class="comment">/// the size of the vector is the number of constants (a value for the whole circuit, gate selectors + constants for gate inputs)</span></span><br><span class="line"><span class="comment">/// each polynomial interpolates the actual constant value at each gate, </span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">constant_polys</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;PolynomialValues&lt;F&gt;&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// if zero_knwoledge is set, it will blind the circuit</span></span><br><span class="line"><span class="comment">/// if the number of circuits is not a power of 2, pad NoopGate, and make the total number of gates to be power of 2</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">blind_and_pad</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * hash the circuit inputs into m Target, m is a constant value of 4. During this process, a `PoseidonGate` is added as the hashing of inputs is conducted</span></span><br><span class="line"><span class="comment">  * @param inputs: public inputs and private inputs</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hash_n_to_hash_no_pad</span>&lt;H: AlgebraicHasher&lt;F&gt;&gt;(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    inputs: <span class="type">Vec</span>&lt;Target&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> HashOutTarget &#123;</span><br><span class="line">    HashOutTarget::<span class="title function_ invoke__">from_vec</span>(<span class="keyword">self</span>.hash_n_to_m_no_pad::&lt;H&gt;(inputs, NUM_HASH_OUT_ELTS))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @param k_is, the coset shift, g^&#123;j&#125;, j \in [0,num_shifts - 1], num_shifts is equal to num_routed_wires (columns); e.q 100</span></span><br><span class="line"><span class="comment">  * @subgroup: the \Omega domain. \Omega^&#123;i&#125;, i \in [0, N-1], N is number of gates (rows); e.q 8 (2^3)</span></span><br><span class="line"><span class="comment">  * @return(0): vector of the sigma polynomial (sigma polynomial is the copy constraint permutation); the size is equal to the number of cols</span></span><br><span class="line"><span class="comment">  * @return(1): the forest is a data structure representing all wires copy constraint. the collected wires forms a unique partition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sigma_vecs</span>(&amp;<span class="keyword">self</span>, k_is: &amp;[F], subgroup: &amp;[F]) <span class="punctuation">-&gt;</span> (<span class="type">Vec</span>&lt;PolynomialValues&lt;F&gt;&gt;, Forest) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-functions"><a href="#3-2-functions" class="headerlink" title="3.2 functions"></a>3.2 functions</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Finds a set of shifts that result in unique cosets for the multiplicative subgroup of size `2^subgroup_bits`.</span></span><br><span class="line"><span class="comment">/// Let `g` be a generator of the entire multiplicative group. the result is just g^0, ..., g^(num_shifts - 1)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_unique_coset_shifts</span>&lt;F: Field&gt;(subgroup_size: <span class="type">usize</span>, num_shifts: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;F&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-selectors"><a href="#4-selectors" class="headerlink" title="4. selectors"></a>4. selectors</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Returns the selector polynomials and related information.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Selector polynomials are computed as follows:</span></span><br><span class="line"><span class="comment">/// Partition the gates into (the smallest amount of) groups `&#123; G_i &#125;`, such that for each group `G`</span></span><br><span class="line"><span class="comment">/// `|G| + max_&#123;g in G&#125; g.degree() &lt;= max_degree`. These groups are constructed greedily from</span></span><br><span class="line"><span class="comment">/// the list of gates sorted by degree.</span></span><br><span class="line"><span class="comment">/// We build a selector polynomial `S_i` for each group `G_i`, with</span></span><br><span class="line"><span class="comment">/// S_i\[j\] =</span></span><br><span class="line"><span class="comment">///     if j-th row gate=g_k in G_i</span></span><br><span class="line"><span class="comment">///         k  (k \in [0, NUM_OF_GATE_TYPES)</span></span><br><span class="line"><span class="comment">///     else</span></span><br><span class="line"><span class="comment">///         UNUSED_SELECTOR</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// the reason is to reduce degrees of selector polynomial * trace polynoial (trace polynomial&#x27;s degree in each group is bounded by max_degree)</span></span><br><span class="line"><span class="comment">/// @param gates: the types of gates , gate type is differentiated by gate.id()</span></span><br><span class="line"><span class="comment">/// @param instances: all instances of gates ( a same type of gate could be used multiple times)</span></span><br><span class="line"><span class="comment">/// @param max_degree: max_degree of each group</span></span><br><span class="line"><span class="comment">/// @return(0): a vector of selector polynomials, the size of the vector is number of groups, in each group, the polynomial indicate the gate_type (k value) of each gate_instance. Hence, the degree of each polynomial is the total number of gate instances (a power of 2)</span></span><br><span class="line"><span class="comment">/// @return(1) SelectorsInfo &#123;</span></span><br><span class="line"><span class="comment">///     selector_indices, a vector of gate group information. the size of vector is same to the number of gate types. the value indicate which group the gate_type belongs to</span></span><br><span class="line"><span class="comment">///     groups: a vector of group information, the vector size is the number of groups. in each group, it is a range of the gate types (ordered as the method described above. i.e partition gates in to groups based on the rule about their degrees)</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">selector_polynomials</span>&lt;F: RichField + Extendable&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt;(</span><br><span class="line">    gates: &amp;[GateRef&lt;F, D&gt;],</span><br><span class="line">    instances: &amp;[GateInstance&lt;F, D&gt;],</span><br><span class="line">    max_degree: <span class="type">usize</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> (<span class="type">Vec</span>&lt;PolynomialValues&lt;F&gt;&gt;, SelectorsInfo) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-permutation"><a href="#5-permutation" class="headerlink" title="5. permutation"></a>5. permutation</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">WirePartition</span> &#123;</span><br><span class="line">    <span class="comment">// each element of the vector is a vector of copy constraint</span></span><br><span class="line">    partition: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;Wire&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Disjoint Set Forest data-structure following &lt;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&gt;.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Forest</span> &#123;</span><br><span class="line">    <span class="comment">/// A map of parent pointers, stored as indices. the parent value is the partition it belongs to</span></span><br><span class="line">    <span class="comment">/// those node with same parent value, means they are in the copy constraint </span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) parents: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line"></span><br><span class="line">    num_wires: <span class="type">usize</span>,</span><br><span class="line">    num_routed_wires: <span class="type">usize</span>, <span class="comment">// num_routed_wires is used to construct all wires</span></span><br><span class="line">    degree: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-hash"><a href="#6-hash" class="headerlink" title="6. hash"></a>6. hash</h2><p>defined in <code>CircuitBuilder</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Hash function used for building Merkle trees.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Hasher</span>: Hasher&lt;<span class="keyword">Self</span>::F&gt;;</span><br><span class="line"><span class="comment">/// Algebraic hash function used for the challenger and hashing public inputs.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">InnerHasher</span>: AlgebraicHasher&lt;<span class="keyword">Self</span>::F&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Trait for algebraic hash functions, built from a permutation using the sponge construction.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">AlgebraicHasher</span>&lt;F: RichField&gt;: Hasher&lt;F, Hash = HashOut&lt;F&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">AlgebraicPermutation</span>: PlonkyPermutation&lt;Target&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Circuit to conditionally swap two chunks of the inputs (useful in verifying Merkle proofs),</span></span><br><span class="line">    <span class="comment">/// then apply the permutation.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">permute_swapped</span>&lt;<span class="keyword">const</span> D: <span class="type">usize</span>&gt;(</span><br><span class="line">        inputs: <span class="keyword">Self</span>::AlgebraicPermutation,</span><br><span class="line">        swap: BoolTarget,</span><br><span class="line">        builder: &amp;<span class="keyword">mut</span> CircuitBuilder&lt;F, D&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::AlgebraicPermutation</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: RichField + Extendable&lt;D&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="7-IOP"><a href="#7-IOP" class="headerlink" title="7. IOP"></a>7. IOP</h2><h3 id="7-1-generator"><a href="#7-1-generator" class="headerlink" title="7.1 generator"></a>7.1 generator</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A generator which runs once after a list of dependencies is present in the witness.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">SimpleGenerator</span>&lt;F: RichField + Extendable&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt;:</span><br><span class="line">    <span class="symbol">&#x27;static</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">id</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">dependencies</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Target&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param out_buffer, contains the vector of a tuple (output_target, output_value)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run_once</span>(&amp;<span class="keyword">self</span>, witness: &amp;PartitionWitness&lt;F&gt;, out_buffer: &amp;<span class="keyword">mut</span> GeneratedValues&lt;F&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">adapter</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> SimpleGeneratorAdapter&lt;F, <span class="keyword">Self</span>, D&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        SimpleGeneratorAdapter &#123;</span><br><span class="line">            inner: <span class="keyword">self</span>,</span><br><span class="line">            _phantom: PhantomData,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">serialize</span>(&amp;<span class="keyword">self</span>, dst: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, common_data: &amp;CommonCircuitData&lt;F, D&gt;) <span class="punctuation">-&gt;</span> IoResult&lt;()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deserialize</span>(src: &amp;<span class="keyword">mut</span> Buffer, common_data: &amp;CommonCircuitData&lt;F, D&gt;) <span class="punctuation">-&gt;</span> IoResult&lt;<span class="keyword">Self</span>&gt;</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SimpleGeneratorAdapter</span>&lt;</span><br><span class="line">    F: RichField + Extendable&lt;D&gt;,</span><br><span class="line">    SG: SimpleGenerator&lt;F, D&gt; + ?<span class="built_in">Sized</span>,</span><br><span class="line">    <span class="keyword">const</span> D: <span class="type">usize</span>,</span><br><span class="line">&gt; &#123;</span><br><span class="line">    _phantom: PhantomData&lt;F&gt;,</span><br><span class="line">    inner: SG,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;F: RichField + Extendable&lt;D&gt;, SG: SimpleGenerator&lt;F, D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt; WitnessGenerator&lt;F, D&gt;</span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">SimpleGeneratorAdapter</span>&lt;F, SG, D&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">watch_list</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Target&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.<span class="title function_ invoke__">dependencies</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>, witness: &amp;PartitionWitness&lt;F&gt;, out_buffer: &amp;<span class="keyword">mut</span> GeneratedValues&lt;F&gt;) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> witness.<span class="title function_ invoke__">contains_all</span>(&amp;<span class="keyword">self</span>.inner.<span class="title function_ invoke__">dependencies</span>()) &#123;</span><br><span class="line">            <span class="keyword">self</span>.inner.<span class="title function_ invoke__">run_once</span>(witness, out_buffer);</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Generator used to fill an extra constant.</span></span><br><span class="line"><span class="meta">#[derive(Debug, Clone, Default)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ConstantGenerator</span>&lt;F: Field&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> row: <span class="type">usize</span>,  <span class="comment">//  specifying the gate row number</span></span><br><span class="line">    <span class="keyword">pub</span> constant_index: <span class="type">usize</span>, <span class="comment">// index of constant input. for example, for a constant gate, num_consts is specified; num_consts will specify the total number of constants</span></span><br><span class="line">    <span class="keyword">pub</span> wire_index: <span class="type">usize</span>,     <span class="comment">// index of constant wire output</span></span><br><span class="line">    <span class="keyword">pub</span> constant: F, <span class="comment">// the constant used to fill a target</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RandomValueGenerator</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) target: Target,  <span class="comment">// the target holding a random value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ArithmeticBaseGenerator</span>&lt;F: RichField + Extendable&lt;D&gt;, <span class="keyword">const</span> D: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    row: <span class="type">usize</span>,</span><br><span class="line">    const_0: F,</span><br><span class="line">    const_1: F,</span><br><span class="line">    i: <span class="type">usize</span>, <span class="comment">// column</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PoseidonGenerator</span>&lt;F: RichField + Extendable&lt;D&gt; + Poseidon, <span class="keyword">const</span> D: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    row: <span class="type">usize</span>,</span><br><span class="line">    _phantom: PhantomData&lt;F&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-2-target"><a href="#7-2-target" class="headerlink" title="7.2 target"></a>7.2 target</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A location in the witness.</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Wire</span>(Wire),</span><br><span class="line">    <span class="comment">/// A target that doesn&#x27;t have any inherent location in the witness (but it can be copied to</span></span><br><span class="line">    <span class="comment">/// another target that does). This is useful for representing intermediate values in witness</span></span><br><span class="line">    <span class="comment">/// generation.</span></span><br><span class="line">    VirtualTarget &#123;</span><br><span class="line">        index: <span class="type">usize</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="comment">/// degree is the number of gates, num_wires is the total number or wires of a gate (one gate could have multiple operations)</span></span><br><span class="line">    <span class="comment">/// num_wires is different from num_routed_wires, num_wires include those not routable wires.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">index</span>(&amp;<span class="keyword">self</span>, num_wires: <span class="type">usize</span>, degree: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Target::<span class="title function_ invoke__">Wire</span>(Wire &#123; row, column &#125;) =&gt; row * num_wires + column,</span><br><span class="line">            Target::VirtualTarget &#123; index &#125; =&gt; degree * num_wires + index,  <span class="comment">// virtual target could be the public &amp; private input, </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">BoolTarget</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> target: Target,</span><br><span class="line">    <span class="comment">/// This private field is here to force all instantiations to go through `new_unsafe`.</span></span><br><span class="line">    _private: (),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Wire</span> &#123;</span><br><span class="line">    <span class="comment">/// Row index of the wire.</span></span><br><span class="line">    <span class="keyword">pub</span> row: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// Column index of the wire.</span></span><br><span class="line">    <span class="keyword">pub</span> column: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wire</span> &#123;</span><br><span class="line">    <span class="comment">// a wire is routable means it could be connected to other gate&#x27;s wire</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_routable</span>(&amp;<span class="keyword">self</span>, config: &amp;CircuitConfig) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.column &lt; config.num_routed_wires</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-witness"><a href="#7-3-witness" class="headerlink" title="7.3 witness"></a>7.3 witness</h3><p>A witness holds information on the values of targets in a circuit.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// `PartitionWitness` holds a disjoint-set forest of the targets respecting a circuit&#x27;s copy constraints.</span></span><br><span class="line"><span class="comment">/// The value of a target is defined to be the value of its root in the forest.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PartitionWitness</span>&lt;<span class="symbol">&#x27;a</span>, F: Field&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> values: <span class="type">Vec</span>&lt;<span class="type">Option</span>&lt;F&gt;&gt;,  <span class="comment">// vector index is target index in the circuit, value is the target value</span></span><br><span class="line">    <span class="keyword">pub</span> representative_map: &amp;<span class="symbol">&#x27;a</span> [<span class="type">usize</span>],  <span class="comment">// array index is target index, value is the representative target index</span></span><br><span class="line">    <span class="keyword">pub</span> num_wires: <span class="type">usize</span>,</span><br><span class="line">    <span class="keyword">pub</span> degree: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Prover"><a href="#8-Prover" class="headerlink" title="8. Prover"></a>8. Prover</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ProverOnlyCircuitData</span>&lt;</span><br><span class="line">    F: RichField + Extendable&lt;D&gt;,</span><br><span class="line">    C: GenericConfig&lt;D, F = F&gt;,</span><br><span class="line">    <span class="keyword">const</span> D: <span class="type">usize</span>,</span><br><span class="line">&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> generators: <span class="type">Vec</span>&lt;WitnessGeneratorRef&lt;F, D&gt;&gt;, <span class="comment">// list of generators</span></span><br><span class="line">    <span class="comment">/// Generator indices (within the `Vec` above), indexed by the representative of each target</span></span><br><span class="line">    <span class="comment">/// they watch. key is generator index (as in self.generators), value is the target to watch</span></span><br><span class="line">    <span class="keyword">pub</span> generator_indices_by_watches: BTreeMap&lt;<span class="type">usize</span>, <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;,</span><br><span class="line">    <span class="comment">/// Commitments to the constants polynomials and sigma polynomials.</span></span><br><span class="line">    <span class="keyword">pub</span> constants_sigmas_commitment: PolynomialBatch&lt;F, C, D&gt;,</span><br><span class="line">    <span class="comment">/// The transpose of the list of sigma polynomials.</span></span><br><span class="line">    <span class="keyword">pub</span> sigmas: <span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;F&gt;&gt;,</span><br><span class="line">    <span class="comment">/// Subgroup of order `degree`.</span></span><br><span class="line">    <span class="keyword">pub</span> subgroup: <span class="type">Vec</span>&lt;F&gt;,</span><br><span class="line">    <span class="comment">/// Targets to be made public.</span></span><br><span class="line">    <span class="keyword">pub</span> public_inputs: <span class="type">Vec</span>&lt;Target&gt;,</span><br><span class="line">    <span class="comment">/// A map from each `Target`&#x27;s index to the index of its representative in the disjoint-set</span></span><br><span class="line">    <span class="comment">/// forest.</span></span><br><span class="line">    <span class="keyword">pub</span> representative_map: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;,</span><br><span class="line">    <span class="comment">/// Pre-computed roots for faster FFT.</span></span><br><span class="line">    <span class="keyword">pub</span> fft_root_table: <span class="type">Option</span>&lt;FftRootTable&lt;F&gt;&gt;,</span><br><span class="line">    <span class="comment">/// A digest of the &quot;circuit&quot; (i.e. the instance, minus public inputs), which can be used to</span></span><br><span class="line">    <span class="comment">/// seed Fiat-Shamir.</span></span><br><span class="line">    <span class="keyword">pub</span> circuit_digest: &lt;&lt;C <span class="keyword">as</span> GenericConfig&lt;D&gt;&gt;::Hasher <span class="keyword">as</span> Hasher&lt;F&gt;&gt;::Hash,</span><br><span class="line">    <span class="comment">///The concrete placement of the lookup gates for each lookup table index.</span></span><br><span class="line">    <span class="keyword">pub</span> lookup_rows: <span class="type">Vec</span>&lt;LookupWire&gt;,</span><br><span class="line">    <span class="comment">/// A vector of (looking_in, looking_out) pairs for for each lookup table index.</span></span><br><span class="line">    <span class="keyword">pub</span> lut_to_lookups: <span class="type">Vec</span>&lt;Lookup&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/11/06/cryptography/zkp/plonky2-code-analysis/" data-id="clq0nd00w00004z7u3a6ubwbd" data-title="plonky2 code analysis" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/zkp/stark-101" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/03/cryptography/zkp/stark-101/" class="article-date">
  <time class="dt-published" datetime="2023-11-03T09:07:33.000Z" itemprop="datePublished">2023-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/03/cryptography/zkp/stark-101/">stark 101</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="trace-and-low-degree-extension"><a href="#trace-and-low-degree-extension" class="headerlink" title="trace and low degree extension"></a>trace and low degree extension</h2><p>the objective is to develop a STARK prover for the FibonacciSq sequence over a finite field. The FibonacciSq sequence is defined by the recurrence relation<br>\[ a_{n+2} &#x3D; a_{n+1} ^2 + a_n ^2 \]</p>
<p>the statement is: <strong>I know a FieldElement \(X\in \mathbb{F}\) such that the 1023rd element of the FibonacciSq sequence starting with \(1, X\) is \(2338775057\)</strong></p>
<p>The underlying field of this class is \(\mathbb{F}_{3221225473}\) (\(3221225473 &#x3D; 3 \cdot 2^{30} + 1\)), so all operations are done modulo 3221225473.</p>
<h3 id="FibonacciSq-Trace"><a href="#FibonacciSq-Trace" class="headerlink" title="FibonacciSq Trace"></a>FibonacciSq Trace</h3><p> let’s construct a list <code>a</code> of length 1023, whose first two elements will be FieldElement objects representing 1 and 3141592, respectively. The next 1021 elements will be the FibonacciSq sequence induced by these two elements. <code>a</code> is called the <strong>trace</strong> of FibonacciSq, or, when the context is clear, the trace.</p>
<h3 id="Thinking-of-Polynomials"><a href="#Thinking-of-Polynomials" class="headerlink" title="Thinking of Polynomials"></a>Thinking of Polynomials</h3><p>We now want to think of the sequence as the evaluation of some polynomial \(f\) of degree 1022.<br>We will choose the domain to be some subgroup \(G \subseteq \mathbb{F}^\times\) of size 1024, for reasons that will become clear later.</p>
<p>(Recall that \(\mathbb{F}^\times\) denotes the multiplicative group of \(\mathbb{F}\), which we get from \(\mathbb{F}\) by omitting the zero element with the induced multiplication from the field. A subgroup of size 1024 exists because \(\mathbb{F}^\times\) is a cyclic group of size \(3\cdot 2^{30}\), so it contains a subgroup of size \(2^i\) for any \(0 \leq i \leq 30\)).</p>
<h4 id="Find-a-Group-of-Size-1024"><a href="#Find-a-Group-of-Size-1024" class="headerlink" title="Find a Group of Size 1024"></a>Find a Group of Size 1024</h4><p>If we find an element \(g \in \mathbb{F}\) whose (multiplicative) order is 1024, then \(g\) will generate such a group. Create a list called <code>G</code> with all the elements of \(G\), such that \(G[i] :&#x3D; g^i\).</p>
<h3 id="Evaluating-on-a-Larger-Domain"><a href="#Evaluating-on-a-Larger-Domain" class="headerlink" title="Evaluating on a Larger Domain"></a>Evaluating on a Larger Domain</h3><p>then, interpolating <code>G</code> over <code>a</code> we get a polynomial <code>f</code>. The trace, viewed as evaluations of a polynomial \(f\) on \(G\), can now be extended by evaluating \(f\) over a larger domain, thereby creating a Reed-Solomon error correction code.</p>
<h4 id="Cosets"><a href="#Cosets" class="headerlink" title="Cosets"></a>Cosets</h4><p>To that end, we must decide on a larger domain on which \(f\) will be evaluated. We will work with a domain that is 8 times larger than \(G\). <br>A natural choice for such a domain is to take some group \(H\) of size 8192 (which exists because 8192 divides \(|\mathbb{F}^\times|\)), and shift it by the generator of \(\mathbb{F}^\times\), thereby obtaining a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coset">coset</a> of \(H\).</p>
<p>Create a list called <code>H</code> of the elements of \(H\), and multiply each of them by the generator of \(\mathbb{F}^\times\) to obtain a list called <code>eval_domain</code>. In other words, <code>eval_domain</code> &#x3D; \(\{w\cdot h^i | 0 \leq i &lt;8192  \}\) for \(h\) the generator of \(H\) and \(w\) the generator of \(\mathbb{F}^\times\).</p>
<h4 id="Evaluate-on-a-Coset"><a href="#Evaluate-on-a-Coset" class="headerlink" title="Evaluate on a Coset"></a>Evaluate on a Coset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = interpolate_poly(G[:-<span class="number">1</span>], a)</span><br><span class="line">f_eval = [f(d) <span class="keyword">for</span> d <span class="keyword">in</span> eval_domain]</span><br></pre></td></tr></table></figure>

<h3 id="Commitments"><a href="#Commitments" class="headerlink" title="Commitments"></a>Commitments</h3><p>We will use <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/SHA-2">Sha256</a>-based <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Trees</a> as our commitment scheme.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> merkle <span class="keyword">import</span> MerkleTree</span><br><span class="line">f_merkle = MerkleTree(f_eval)</span><br></pre></td></tr></table></figure>

<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>Theoretically, a STARK proof system is a protocol for interaction between two parties - a prover and a verifier. In practice, we convert this interactive protocol into a non-interactive proof using the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic">Fiat-Shamir Heuristic</a>. In this tutorial you will use the <code>Channel</code> class, which implements this transformation. This channel replaces the verifier in the sense that the prover (which you are writing) will send data, and receive random numbers or random <code>FieldElement</code> instances.</p>
<h2 id="constraints"><a href="#constraints" class="headerlink" title="constraints"></a>constraints</h2><p>In this part, we are going to create a set of constraints over the trace <code>a</code>. </p>
<h3 id="Step-1-FibonacciSq-Constraints"><a href="#Step-1-FibonacciSq-Constraints" class="headerlink" title="Step 1 - FibonacciSq Constraints"></a>Step 1 - FibonacciSq Constraints</h3><p>For <code>a</code> to be a correct trace of a FibonacciSq sequence that proves our claim:</p>
<ol>
<li>The first element has to be 1, namely \(a[0] &#x3D; 1\).</li>
<li>The last element has to be 2338775057, namely \(a[1022] &#x3D; 2338775057\).</li>
<li>The FibonacciSq rule must apply, that is - for every \(i&lt;1021\), \(a[i+2]&#x3D;a[i+1]^2+a[i]^2\).</li>
</ol>
<h3 id="Step-2-Polynomial-Constraints"><a href="#Step-2-Polynomial-Constraints" class="headerlink" title="Step 2 - Polynomial Constraints"></a>Step 2 - Polynomial Constraints</h3><p>Recall that <code>f</code> is a polynomial over the trace domain, that evaluates exactly to <code>a</code> over \(G \setminus {g^{1023}}\) where \(G&#x3D;{g^i : 0\leq i\leq 1023}\) is the “small” group generated by \(g\).<br></p>
<p>We now rewrite the above three constraints in a form of polynomial constraints over <code>f</code>:</p>
<ol>
<li>\(a[0] &#x3D; 1\) is translated to the polynomial \(f(x) - 1\), which evalutes to 0 for \(x &#x3D; g^0\) (note that \(g^0\) is \(1\)). <br></li>
<li>\(a[1022] &#x3D; 2338775057\) is translated to the polynomial \(f(x) - 2338775057\), which evalutes to 0 for \(x &#x3D; g^{1022}\). <br></li>
<li>\(a[i+2]&#x3D;a[i+1]^2+a[i]^2\) for every \(i&lt;1021\) is translated to the polynomial \(f(g^2 \cdot x) - (f(g \cdot x))^2 - (f(x))^2\), which evaluates to 0 for \(x \in G \backslash {g^{1021}, g^{1022}, g^{1023}}\). <br><br></li>
</ol>
<h3 id="Step-3-Rational-Functions-That-are-in-Fact-Polynomials"><a href="#Step-3-Rational-Functions-That-are-in-Fact-Polynomials" class="headerlink" title="Step 3 - Rational Functions (That are in Fact Polynomials)"></a>Step 3 - Rational Functions (That are in Fact Polynomials)</h3><p>Each of the constraints above is represented by a polynomial \(u(x)\) that supposedly evaluates to \(0\) on certain elements of the group \(G\). That is, for some \(x_0, \ldots, x_k \in G\), we claim that</p>
<p>\[u(x_0) &#x3D; \ldots &#x3D; u(x_k) &#x3D; 0\]</p>
<p>(note that for the first two constaints, \(k&#x3D;0\) because they only refer to one point and for the third \(k&#x3D;1021\)).</p>
<p>This is equivalent to saying that \(u(x)\) is divisible, as a polynomial, by all of \({(x-x_i)}_{i&#x3D;0}^k\), or, equivalently, by</p>
<p>\[\prod_{i&#x3D;0}^k (x-x_i)\]</p>
<p>Therefore, each of the three constraints above can be written as a rational function of the form:</p>
<p>\[\frac{u(x)}{\prod_{i&#x3D;0}^k (x-x_i)}\]</p>
<p>for the corresponding \(u(x)\) and \({x_i}_{i&#x3D;0}^k\). In this step we will construct these three rational functions and show that they are indeed polynomials.</p>
<h3 id="The-First-Constraint"><a href="#The-First-Constraint" class="headerlink" title="The First Constraint:"></a>The First Constraint:</h3><p>In the first constraint, \(f(x) - 1\) and \({x_i} &#x3D; {1}\).</p>
<p>We will now construct the <strong>polynomial</strong> \(p_0(x)&#x3D;\frac{f(x) - 1}{x - 1}\), making sure that \(f(x) - 1\) is indeed divisible by \((x-1)\).</p>
<h3 id="The-Second-Constraint"><a href="#The-Second-Constraint" class="headerlink" title="The Second Constraint"></a>The Second Constraint</h3><p>Construct the polynomial <code>p1</code> representing the  second constraint, \(p_1(x)&#x3D; \frac{f(x) - 2338775057}{x - g^{1022}}\), similarly: <br></p>
<h3 id="The-Third-Constraint-Succinctness"><a href="#The-Third-Constraint-Succinctness" class="headerlink" title="The Third Constraint - Succinctness"></a>The Third Constraint - Succinctness</h3><p>The last constraint’s rational function is slightly more complicated: <br></p>
<p>\[p_2(x) &#x3D; \frac{f(g^2 \cdot x) - (f(g \cdot x))^2 - (f(x))^2}{\prod\limits_{i&#x3D;0}^{1020} (x-g^i)}\]</p>
<p>whose denominator can be rewritten, so that the entire expression is easier to compute:<br></p>
<p>$$\frac{f(g^2 \cdot x) - (f(g \cdot x))^2 - (f(x))^2}{\frac{x^{1024} - 1}{(x-g^{1021})(x-g^{1022})(x-g^{1023})}}$$ <br></p>
<p>This follows from the equality</p>
<p>$$\prod\limits_{i&#x3D;0}^{1023} (x-g^i) &#x3D; x^{1024} - 1$$</p>
<h3 id="Step-4-Composition-Polynomial"><a href="#Step-4-Composition-Polynomial" class="headerlink" title="Step 4 - Composition Polynomial"></a>Step 4 - Composition Polynomial</h3><p>Recall that we’re translating a problem of checking the validity of three polynomial constraints to checking that each of the rational functions \(p_0, p_1, p_2\) are polynomials. <br></p>
<p>Our protocol uses an algorithm called <a target="_blank" rel="noopener" href="https://eccc.weizmann.ac.il/report/2017/134/">FRI</a> to do so, which will be discussed in the next part. <br><br>In order for the proof to be succinct (short), we prefer to work with just one rational function instead of three. For that, we take a random linear combination of \(p_0, p_1, p_2\) called the <strong>compostion polynomial</strong> (CP for short):</p>
<p>$$CP(x) &#x3D; \alpha_0 \cdot p_0(x) + \alpha_1 \cdot p_1(x) + \alpha_2 \cdot  p_2(x)$$ <br></p>
<p>where \(\alpha_0, \alpha_1, \alpha_2 \) are random field elements obtained from the verifier, or in our case - from the channel.</p>
<p>Proving that (the rational function) \(CP\) is a polynomial guarantess, with high probability, that each of \(p_0, p_1, p_2\) are themselves polynomials.</p>
<h3 id="Commit-on-the-Composition-Polynomial"><a href="#Commit-on-the-Composition-Polynomial" class="headerlink" title="Commit on the Composition Polynomial"></a>Commit on the Composition Polynomial</h3><p>Lastly, we evaluate $cp$ over the evaluation domain (<code>eval_domain</code>), build a Merkle tree on top of that and send its root over the channel. This is similar to commiting on the LDE trace, as we did at the end of part 1.</p>
<p><img src="/images/zkp/stark/trace_to_CP.png" alt="trace to cp"></p>
<h2 id="FRI-Commitments"><a href="#FRI-Commitments" class="headerlink" title="FRI Commitments"></a>FRI Commitments</h2><h3 id="FRI-Folding"><a href="#FRI-Folding" class="headerlink" title="FRI Folding"></a>FRI Folding</h3><p>Our goal in this part is to construct the FRI layers and commit on them.<br><br>To obtain each layer we need:</p>
<ol>
<li>To generate a domain for the layer (from the previous layer’s domain).</li>
<li>To generate a polynomial for the layer (from the previous layer’s polynomial and domain).</li>
<li>To evaluate said polynomial on said domain - <strong>this is the next FRI layer</strong>.</li>
</ol>
<h4 id="Domain-Generation"><a href="#Domain-Generation" class="headerlink" title="Domain Generation"></a>Domain Generation</h4><p>The first FRI domain is simply the <code>eval_domain</code> that you already generated in Part 1, namely a coset of a group of order 8192. Each subsequent FRI domain is obtained by taking the first half of the previous FRI domain (dropping the second half), and squaring each of its elements.<br></p>
<p>Formally - we got <code>eval_domain</code> by taking:<br><br>$$w, w\cdot h, w\cdot h^2, …, w\cdot h^{8191}$$</p>
<p>The next layer will therefore be:<br><br>$$w^2, (w\cdot h)^2, (w\cdot h^2)^2, …, (w\cdot h^{4095})^2$$</p>
<p>Note that taking the squares of the second half of each elements in <code>eval_domain</code> yields exactly<br>the same result as taking the squares of the first half. This is true for the next layers as well.</p>
<p>Similarly, the domain of the third layer will be:<br><br>$$w^4, (w\cdot h)^4, (w\cdot h^2)^4, …, (w\cdot h^{2047})^4$$</p>
<p>And so on.</p>
<h4 id="FRI-Folding-Operator"><a href="#FRI-Folding-Operator" class="headerlink" title="FRI Folding Operator"></a>FRI Folding Operator</h4><p>The first FRI polynomial is simply the composition polynomial, i.e., <code>cp</code>.<br><br>Each subsequent FRI polynomial is obtained by:</p>
<ol>
<li>Getting a random field element \(\beta\) (by calling <code>Channel.receive_random_field_element</code>).</li>
<li>Multiplying the odd coefficients of the previous polynomial by \(\beta\).</li>
<li>Summing together consecutive pairs (even-odd) of coefficients.</li>
</ol>
<p>Formally, let’s say that the k-th polynomial is of degree \(&lt; m\) (for some \(m\) which is a power of 2):</p>
<p>$$p_{k}(x) :&#x3D; \sum _{i&#x3D;0} ^{m-1} c_i x^i$$</p>
<p>Then the (k+1)-th polynomial, whose degree is \(&lt; \frac m 2 \) will be:</p>
<p>\[ p_{k+1}(x) :&#x3D; \sum_{i&#x3D;0} ^{  m &#x2F; 2 - 1 } (c_{2i} + \beta \cdot c_{2i + 1}) x^i \] <br></p>
<p><img src="/images/zkp/stark/fri.png" alt="fri"></p>
<p><img src="/images/zkp/stark/fri_example.png" alt="fri example"></p>
<h3 id="Generating-FRI-Commitments"><a href="#Generating-FRI-Commitments" class="headerlink" title="Generating FRI Commitments"></a>Generating FRI Commitments</h3><p>We have now developed the tools to write the <code>FriCommit</code> method, that contains the main FRI commitment loop.<br></p>
<p>It takes the following 5 arguments:</p>
<ol>
<li>The composition polynomial, that is also the first FRI polynomial, that is - <code>cp</code>.</li>
<li>The coset of order 8192 that is also the first FRI domain, that is - <code>eval_domain</code>.</li>
<li>The evaluation of the former over the latter, which is also the first FRI layer , that is - <code>cp_eval</code>.</li>
<li>The first Merkle tree (we will have one for each FRI layer) constructed from these evaluations, that is - <code>cp_merkle</code>.</li>
<li>A channel object, that is <code>channel</code>.</li>
</ol>
<p>The method accordingly returns 4 lists:</p>
<ol>
<li>The FRI polynomials.</li>
<li>The FRI domains.</li>
<li>The FRI layers.</li>
<li>The FRI Merkle trees.</li>
</ol>
<p>The method contains a loop, in each iteration of which we extend these four lists, using the last element in each.<br>The iteration should stop once the last FRI polynomial is of degree 0, that is - when the last FRI polynomial is just a constant. It should then send over the channel this constant (i.e. - the polynomial’s free term).<br>The <code>Channel</code> class only supports sending strings, so make sure you convert anything you wish to send over the channel to a string before sending.</p>
<p><img src="/images/zkp/stark/commitment.png" alt="commitment"></p>
<h2 id="Query-Phase"><a href="#Query-Phase" class="headerlink" title="Query Phase"></a>Query Phase</h2><p>Get q random elements, provide a valdiation data for each</p>
<p><img src="/images/zkp/stark/decommitment.png" alt="decommitment"></p>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/starkware-industries/stark101">https://github.com/starkware-industries/stark101</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/starkware/tagged/stark-math">startk_math</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/starkware/starkdex-deep-dive-introduction-7b4ef0dedba8">starkEx deep dive</a></li>
<li>[coset] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coset">https://en.wikipedia.org/wiki/Coset</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/starkware/arithmetization-ii-403c3b3f4355">starkware math</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/11/03/cryptography/zkp/stark-101/" data-id="clphpvdoj0005aj7ug6vbhr5l" data-title="stark 101" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/zkp/understanding-plonk" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/01/cryptography/zkp/understanding-plonk/" class="article-date">
  <time class="dt-published" datetime="2023-11-01T09:19:04.000Z" itemprop="datePublished">2023-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/01/cryptography/zkp/understanding-plonk/">understanding plonk</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p><a target="_blank" rel="noopener" href="https://eprint.iacr.org/2019/953">PLONK</a>, standing for the unwieldy quasi-backronym “Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge”. PLONK still requires a “universal and updateable” trusted setup, meaning each program share the same setup. Secondly, there is a way for multiple parties to participate in the trusted setup such that it is secure as long as any one of them is honest.</p>
<h1 id="preliminary"><a href="#preliminary" class="headerlink" title="preliminary"></a>preliminary</h1><h2 id="observation-1"><a href="#observation-1" class="headerlink" title="observation 1"></a>observation 1</h2><p>a key fact: for non-zero \( f \in \mathbb{F_p}^{\le d}[X]\) <br><br>for \( r  \leftarrow \mathbb{F_p}: Pr[f(r) &#x3D; 0] \le d&#x2F;p\)<br>understanding: polynomial \(f\) contains at most \(d\) roots of zeros. <br><br>suppose \( p \approx 2^{256}\) and  \( d \approx 2^{40}\) then \(d&#x2F;p\) is negligible. <br><br>Therefore, for random \( r  \leftarrow \mathbb{F_p}\) if \(f(r) &#x3D; 0\) then \(f\) is identically zero w.h.p (with high probability)</p>
<p>&#x3D;&gt; a simple zero test for a committed polynomial<br><strong>Note</strong> SZDL lemma: this also holds for multivariate polynomials (where d is total degree of f) </p>
<h2 id="observation-2"><a href="#observation-2" class="headerlink" title="observation 2"></a>observation 2</h2><p>let \(f,g \in \mathbb{F_p}^{\le d}[X]\).<br>for \( r  \leftarrow \mathbb{F_p}\), if \(f(r) &#x3D; g(r)\), then \(f &#x3D; g\) w.h.p <br><br>\(f(r)-g(r)&#x3D;0\) &#x3D;&gt; \(f-g&#x3D;0\) w.h.p <br></p>
<p>&#x3D;&gt; a simple equality test for two committed polynomials</p>
<h1 id="useful-proof-gadgets"><a href="#useful-proof-gadgets" class="headerlink" title="useful proof gadgets"></a>useful proof gadgets</h1><h2 id="1-zero-test"><a href="#1-zero-test" class="headerlink" title="1. zero test"></a>1. zero test</h2><p>let \( \omega \in \mathbb{F_p} \) be a primitive k-th root of unity \(( \omega ^{k} &#x3D; 1)\)<br>set \( H:&#x3D; \{1,\omega,\omega^2,\omega^3,…,\omega^{k-1}\}  \subseteq \mathbb{F_p} \)<br>let \( f \in \mathbb{F_p}^{\le d}[X]\) and \( b, c \in \mathbb{F_p}\)  \((d \ge k)\)</p>
<p>task: prove that \(f\) is identically zero on \(H\)<br><img src="/images/zkp/plonk/zero_test.png" alt="zero test"></p>
<p><strong>info</strong> the box of \(f\) means the commitment of polynomial \(f\), i.e \(com_f\)</p>
<h2 id="2-product-check"><a href="#2-product-check" class="headerlink" title="2. product check"></a>2. product check</h2><p>product check on \(\Omega: \quad \prod_{a\in \Omega} f(a) &#x3D; 1\)<br>Set \( t \in \mathbb{F_p}^{\le k}[X]\) to be the degree-k polynomial:<br>\[ t(1) &#x3D; f(\omega^0) &#x3D; f(1), \quad t(\omega^s) &#x3D; \prod_{i&#x3D;0}^{s}f(\omega^{i}) \quad for \quad s &#x3D; 1,…, k-1\]<br>Then<br>\(t(\omega) &#x3D; f(1) \cdot f(\omega), \quad t(\omega^2) &#x3D; f(1) \cdot f(\omega) \cdot f(\omega^2), … \)<br>\(t( \omega^{k-1}) &#x3D; \prod_{a \in \Omega}f(a) &#x3D; 1\)<br>and \( t(\omega \cdot x) &#x3D; t(x) \cdot f(\omega \cdot x) \) for all \(x \in \Omega \) (including at \(x &#x3D; \omega^{k-1}\))<br><img src="/images/zkp/plonk/prod_check_lemma.png" alt="prod_check_lemma"><br><img src="/images/zkp/plonk/prod_check_prove_verify.png" alt="prod_check_prove_and_verify"></p>
<p>Same works for rational functions: \( \prod_{a \in \Omega}{f&#x2F;g}(a) &#x3D;1 \)<br>The proof is similar</p>
<h2 id="3-permutation-check"><a href="#3-permutation-check" class="headerlink" title="3. permutation check"></a>3. permutation check</h2><p>let \(f,g\) be polynomials in \(\mathbb{F_p}^{\le d}[X]\). Verifier has \(com_f, com_g\).<br>Prover wants to prove that \((f(1),f(\omega^1),f(\omega^2),…,f(\omega^{k-1})) \in \mathbb{F_p}^{\le k}[X]\) is a permutaion of \((g(1),g(\omega^1),g(\omega^2),…,g(\omega^{k-1})) \in \mathbb{F_p}^{\le k}[X]\)</p>
<p><img src="/images/zkp/plonk/permutation_check.png" alt="permutation check"></p>
<h2 id="4-prescribed-permutation-check"><a href="#4-prescribed-permutation-check" class="headerlink" title="4. prescribed permutation check"></a>4. prescribed permutation check</h2><p><img src="/images/zkp/plonk/prescribed_perm_check_problem.png"><br><img src="/images/zkp/plonk/prescribed_perm_check_problem_quadratic.png"><br><img src="/images/zkp/plonk/prescribed_perm_check_problem_reduce.png"><br><img src="/images/zkp/plonk/prescribed_perm_check_problem_prove_verify.png"><br><img src="/images/zkp/plonk/prescribed_perm_check_problem_complete.png"></p>
<h1 id="PLONK-a-poly-IOP-for-a-general-circuit-C-x-w"><a href="#PLONK-a-poly-IOP-for-a-general-circuit-C-x-w" class="headerlink" title="PLONK: a poly-IOP for a general circuit C(x,w)"></a>PLONK: a poly-IOP for a general circuit C(x,w)</h1><h2 id="step-1-compile-circuit-to-a-computation-trace-gate-fan-in-x3D-2"><a href="#step-1-compile-circuit-to-a-computation-trace-gate-fan-in-x3D-2" class="headerlink" title="step 1: compile circuit to a computation trace (gate fan-in &#x3D; 2)"></a>step 1: compile circuit to a computation trace (gate fan-in &#x3D; 2)</h2><p><img src="/images/zkp/plonk/plonk_circuit_to_trace.png" alt="circuit to trace"></p>
<p>and encode the trace as polynomial<br>let \(|C|\) be the total number of gates, \(|I| :&#x3D; |I_x| + |I_w|\) be total number of inputs, where \(|I_x|\) is the number of public inputs, \(I_w\) is the number of private inputs.<br>Let \(d&#x3D;3*|C|+|I|\) and \( \Omega&#x3D;\{1,\omega,\omega^2,\omega^3,…,\omega^{d-1}\} \)</p>
<p>prover interpolates \( T \in \mathbb{F_p}^{\le d}[X]\) such that</p>
<ul>
<li><strong>T encodes all inputs</strong>: \( T(\omega^{-j})  \)&#x3D; input #j, for j &#x3D; 1,…,|I|</li>
<li><strong>T encodes all wires</strong>:<br>\(LeftInput&#x3D;f(\omega^{3l})\), \(  RightInput&#x3D;f(\omega^{3l+1})\), \(Output&#x3D;f(\omega^{3l+2})\), for \(l &#x3D; 0,1,…, |C| -1\)<br>For the example,<br><strong>inputs</strong><br>\(x_1&#x3D; 5 &#x3D; T(\omega^9)\), \(x_2&#x3D; 6 &#x3D; T(\omega^{10})\), and \(w_1 &#x3D; 1&#x3D;T(\omega^{11})\)<br><strong>wires</strong><br>\(5&#x3D;T(\omega^0)\), \(6&#x3D;T(\omega^{1})\), and \(11&#x3D;T(\omega^{2})\)<br>\(6&#x3D;T(\omega^3)\), \(1&#x3D;T(\omega^{4})\), and \(7&#x3D;T(\omega^{5})\)<br>\(11&#x3D;T(\omega^6)\), \(7&#x3D;T(\omega^{7})\), and \(77&#x3D;T(\omega^{8})\)</li>
</ul>
<h2 id="step-2-proving-validity-of-T"><a href="#step-2-proving-validity-of-T" class="headerlink" title="step 2: proving validity of T"></a>step 2: proving validity of T</h2><p>Prover needs to prove 4 things</p>
<ol>
<li><strong>\(T(x)\) encodes the correct public inputs</strong><br>Both prover and verifier interpolate a polynomial \( v(x) \in \mathbb{F_p}^{\le |I_x|}[X]\)<br>that encodes the \(x\)-inputs to the circuit:<br>\(v(\omega^{-j}) &#x3D;\) input #j, for \(j &#x3D; 1, …, |I_x|\)<br>In our example, \(v(\omega^{-1} &#x3D; 5), v(\omega^{-2} &#x3D; 6)\)<br>Let \( \Omega_{inp}&#x3D;\{\omega^{-1},\omega^{-2},…,\omega^{-|I_x|}\} \)<br>Prover proves by using a <strong>ZeroTest</strong> on \(\Omega_inp\) to prove that<br>\[T(y) - v(y) &#x3D;0 \quad \forall y \in \Omega_{inp}\]</li>
<li><strong>every gate is evaluated correctly</strong><br><strong>Idea</strong> encode gate types using a selector polynomial \(S(X)\)<br>define \(S(X) \in  \mathbb{F_p}^{\le d}[X]\) such that \( \forall l &#x3D; 0, …, |C| -1\):</li>
</ol>
<ul>
<li>\(S(\omega^{3l}) &#x3D;1\) if gate #l is an addition gate</li>
<li>\(S(\omega^{3l}) &#x3D;0\) if gate #l is a multiplication gate</li>
</ul>
<p>Then, \( \forall y \in   \Omega_{gates} : &#x3D; \{1,\omega^{3},\omega^{6},…,\omega^{3(|C|-1)}\} \)<br>\(S(y) \cdot [T(y) + T(\omega y)] + (1-S(y))\cdot T(y) \cdot T(\omega y) &#x3D; T(\omega^2 y)\)<br><img src="/images/zkp/plonk/gate_evaluation_zero_test.png" alt="gate_evaluation_zero_test"></p>
<ol start="3">
<li><strong>the wiring is implemented correctly (coppy constraint)</strong><br><img src="/images/zkp/plonk/copy_constraint_example.png"></li>
</ol>
<p>  \(T(\omega^9,\omega^0)&#x3D;\sigma(\omega^0,\omega^9)\)<br>  \(T(\omega^{10},\omega^1,\omega^3)&#x3D;\sigma(\omega^1,\omega^3,\omega^{10})\)<br>  \(T(\omega^2,\omega^6)&#x3D;\sigma(\omega^6,\omega^2)\)<br>  \(T(\omega^{11},\omega^4)&#x3D;\sigma(\omega^4,\omega^{11})\)<br>    \(T(\omega^{5},\omega^7)&#x3D;\sigma(\omega^7,\omega^{5})\)<br><strong>note</strong>: 9 is actually -1, 10 is -2, 11 is -3<br>Define a polynomial \(W: \Omega -&gt; \Omega\) that implemnets a rotation<br>\( W(\omega^{10}, \omega^1, \omega^3) &#x3D;(\omega^1, \omega^3, \omega^{10}) \), \(W(\omega^{9}, \omega^0)&#x3D;(\omega^0, \omega^{9})\), …</p>
<p><strong>Lemma</strong>: \(\forall y \in \Omega: T(y) &#x3D; T(W(y))\) &#x3D;&gt; wire constraints are satisfied<br>This could be proved using a prescribed permutation check</p>
<ol start="4">
<li><strong>the output of last gate is 0</strong><br>this is to prove \(T(\omega^8) -77 &#x3D; 0\)</li>
</ol>
<h1 id="custom-gate"><a href="#custom-gate" class="headerlink" title="custom gate"></a>custom gate</h1><p><img src="/images/zkp/plonk/custom_gate.png"><br>\(u, v, w, t, r\) are polynomials represent input variables (row number is the gate number). in the <code>Add</code>, <code>Mul</code> only circuits, there are only two inputs, namely <code>LeftInput</code> and <code>RightInput</code>. Hoever, here there are multiple inputs for custom gate. </p>
<p>In the above example, it is a constraint for \( v_4 + w_3 \cdot t_3 - t_4 &#x3D; 0 \)</p>
<h1 id="plonkup"><a href="#plonkup" class="headerlink" title="plonkup"></a>plonkup</h1><p>plonkup is to ensure some values are in a pre-defined list. for example</p>
<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>Output</th>
</tr>
</thead>
<tbody><tr>
<td>\(a_{1,1}\)</td>
<td>\(a_{1,2}\)</td>
<td>\(a_{1,3}\)</td>
<td>\(a_{1,4}\)</td>
</tr>
<tr>
<td>\(a_{2,1}\)</td>
<td>\(a_{2,2}\)</td>
<td>\(a_{2,3}\)</td>
<td>\(a_{2,4}\)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>\(a_{n,1}\)</td>
<td>\(a_{n,2}\)</td>
<td>\(a_{n,3}\)</td>
<td>\(a_{n,4}\)</td>
</tr>
</tbody></table>
<p>\(n\) is gate number. the task is to prove a vector </p>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul>
<li><a target="_blank" rel="noopener" href="https://hackmd.io/@learn-zkp/note-plonk-family">https://hackmd.io/@learn-zkp/note-plonk-family</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=A0oZVEXav24">ZKP MOOC Lecture 5: The Plonk SNARK</a></li>
<li><a target="_blank" rel="noopener" href="https://cs251.stanford.edu/lectures/lecture15.pdf">CS251.stanford lecture</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/11/01/cryptography/zkp/understanding-plonk/" data-id="clphpvdok000baj7u3i3te2rg" data-title="understanding plonk" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-blockchain/danksharding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/12/blockchain/danksharding/" class="article-date">
  <time class="dt-published" datetime="2023-10-12T06:36:58.000Z" itemprop="datePublished">2023-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/12/blockchain/danksharding/">danksharding</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>Danksharding is central to Ethereum’s rollup-centric roadmap. The idea is to provide space for large blobs of data, which are verifiable and available, without attempting to interpret them.</p>
<h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><p>All references to EC, in this report, refer to BLS12_381 [1]. We are mainly concerned with the EC Abelian-group \(\mathbb{G_{1}}\) and the EC scalar-field \(F_r\). Both are of size \(r &lt; 2256\). Note that \(2^{32}\) divides the size of the multiplicative-group in \(F_r\)</p>
<h2 id="Data-organization"><a href="#Data-organization" class="headerlink" title="Data organization"></a>Data organization</h2><p>The input data consists of n &#x3D; 256 shard-blobs. Each shard-blob is a vector of m &#x3D; 4096 field-elements referred-to as symbols. The data symbols are organized in an n × m input<br>matrix<br>\[<br>    \tag{1}<br>    D_{n x m}^{in} &#x3D;<br>\begin{bmatrix}<br>\displaylines{<br>    d(0,0)   &amp; d(0,1)  &amp; \dots  &amp; d(0,m-1)\\<br>    d(1,0)   &amp; d(1,1)  &amp; \dots  &amp; d(1,m-1)\\<br>    \vdots                 &amp; \vdots                 &amp; \ddots &amp; \vdots\\<br>    d(n-1,0)   &amp; d(n-1,1)  &amp; \dots  &amp; d(n-1,m-1)<br>}<br>\end{bmatrix}<br>\]<br>where each row is one of the shard-blob vectors [2]<br>In order to enable interpolation and polynomial-commitment to the data, we will pro-<br>ceed to treat the data symbols as polynomial evaluations.</p>
<p>Let us thus associate each domain location in the input matrix with a field-element pair \(u_{\mu}, \omega_{\eta}\), where \(\mu \in [0, n−1], \eta \in [0, m−1]\) correspond to the row and column indexes, respectively.The row field-element is defined as \( u_{\mu} \equiv u^{rbo(\mu)}\), where u is a 2n’th root-of-unity such that \(u^{2n} &#x3D; 1\). The column field-element is defined as \( \omega_{\eta} \equiv \omega^{rbo(\eta)}\), where \(\omega\) is a 2m’th root-of-unity such that \(\omega^{2m} &#x3D; 1\). <span style="color:red"><em>Using reverse-bit-order ordering rather than natural-ordering allows accessing cosets in block (consecutive) rather than interleaved manner</em></span></p>
<h2 id="coefficients-extraction"><a href="#coefficients-extraction" class="headerlink" title="coefficients extraction"></a>coefficients extraction</h2><p>Taking the data symbols to be evaluations of a 2D-polynomial or 1D-product-polynomials with row degree n−1 and column degree m−1 uniquely defines the polynomials’ coefficients.</p>
<h3 id="2D-coeficients-extraction"><a href="#2D-coeficients-extraction" class="headerlink" title="2D coeficients extraction"></a>2D coeficients extraction</h3><p>The 2D-polynomial representing the input data can be expressed as<br>\[\tag{2} d(x,y) \equiv \sum_{i&#x3D;0}^{n-1}\sum_{j&#x3D;0}^{m-1} \hat{c}[i,j] x^{i}y^{j}\]<br>Plugging an evaluation from (1) into (2) results in the following:</p>
<p>\[\tag{3} d(u_{\mu},\omega_{\eta}) \equiv \sum_{i&#x3D;0}^{n-1}\sum_{j&#x3D;0}^{m-1} \hat{c}[i,j] {u_{\mu}}^{i}{\omega_{\eta}}^{j}\]</p>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p>[1] Ben Edgington. Bls12-381 for the rest of us. <a target="_blank" rel="noopener" href="https://hackmd.io/@benjaminion/bls12-381">https://hackmd.io/@benjaminion/bls12-381</a>.<br>[2] Dankrad Feist. Data availability encoding. <a target="_blank" rel="noopener" href="https://notes.ethereum.org/@dankrad/danksharding_encoding">https://notes.ethereum.org/@dankrad/danksharding_encoding</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/10/12/blockchain/danksharding/" data-id="clokyy8dm0005qwsja95zaawe" data-title="danksharding" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/blockchain/" rel="tag">blockchain</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-math/fourier-series" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/12/math/fourier-series/" class="article-date">
  <time class="dt-published" datetime="2023-10-12T03:13:17.000Z" itemprop="datePublished">2023-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/12/math/fourier-series/">fourier series, DFT and FFT</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="Fourier-Series"><a href="#Fourier-Series" class="headerlink" title="Fourier Series"></a>Fourier Series</h2><h3 id="innter-product-of-two-functions"><a href="#innter-product-of-two-functions" class="headerlink" title="innter product of two functions"></a>innter product of two functions</h3><p>\[ &lt;f(x), g(x)&gt; &#x3D; \int_{a}^{b} f(x) \bar{g}(x)dx\]<br>\(\bar{g}\) is the congugate of g on complex number system</p>
<h3 id="Fourier-series-definition"><a href="#Fourier-series-definition" class="headerlink" title="Fourier series definition"></a>Fourier series definition</h3><p>let \(f(x)\) be a periodic function over a period of \([-\pi, +\pi]\)<br><img src="/images/math/fourier_series/f_x.png" alt="f(x)"></p>
<p>\( f(x) \) can be transformed into below<br>\[ f(x) &#x3D; \frac{A_{0}}{2} + \sum_{k&#x3D;1}^{\infty}A_{k}cos(kx) + B_{k}sin(kx)\],<br>where<br>\[ A_{k} &#x3D; \frac{1}{\pi} \int_{-\pi}^{+\pi} f(x)cos(kx)dx &#x3D; \frac{1}{||cos(kx)||^2}&lt;f(x),cos(kx)&gt; \]<br>\[ B_{k} &#x3D; \frac{1}{\pi} \int_{-\pi}^{+\pi} f(x)sin(kx)dx &#x3D; \frac{1}{||sin(kx)||^2}&lt;f(x),sin(kx)&gt; \]<br>where \(A_{k}, B_{k}\) is just the <strong>innver product</strong> of \(f(x)\), and \( cos(kx) \), \(sin(kx)\) respectively. intuitively, it is the <strong>projection</strong> of \(f(x)\) over \(sin(kx)\), or \(cos(kx)\). </p>
<h3 id="if-period-is-L"><a href="#if-period-is-L" class="headerlink" title="if period is L"></a>if period is L</h3><p>\[ f(x) &#x3D; \frac{A_{0}}{2} + \sum_{k&#x3D;1}^{\infty}A_{k}cos(\frac{2\pi kx}{L}) + B_{k}sin(\frac{2\pi kx}{L})\],<br>where<br>\[ A_{k} &#x3D; \frac{2}{L} \int_{0}^{L} f(x)cos(\frac{2\pi kx}{L})dx\]<br>\[ B_{k} &#x3D; \frac{2}{L} \int_{0}^{L} f(x)sin(\frac{2\pi kx}{L})dx\]</p>
<h2 id="Complex-Fourier-Series"><a href="#Complex-Fourier-Series" class="headerlink" title="Complex Fourier Series"></a>Complex Fourier Series</h2><p>let’s define \[ \psi_k &#x3D; e^{ikx} &#x3D; cos(kx) + i \cdot sin(kx)\]<br>we can prove that \(\psi_k, and \psi_j\) are <strong>orthogonal</strong> as their inner product is zero<br><strong>proof</strong><br>\[ &lt;\psi_j, \psi_k&gt; &#x3D; \int_{-\pi}^{+\pi} e^{jkx}e^{-ikx}dx &#x3D;  \int_{-\pi}^{+\pi} e^{j(j-k)x}dx &#x3D; \frac{1}{i(j-k)}[e^{i(j-k)x}]_{-\pi}^{\pi}\]<br>it is 0 if \(j \ne k\) , \(2\pi \) if \(j&#x3D;k\)</p>
<p><strong>note</strong> conjugate of \(\psi_k\) is \(e^{-ikx}\)</p>
<p>\(f(x) &#x3D; \frac{1}{2\pi} \sum_{k&#x3D;-\infty}^{\infty} c_k \psi_k\), where \(c_k&#x3D;&lt;f(x), \psi_k&gt; &#x3D; \int_{-\pi}^{+\pi} f(x)e^{-ikx}dx\)</p>
<h2 id="Discrete-Fourier-Transform-DFT"><a href="#Discrete-Fourier-Transform-DFT" class="headerlink" title="Discrete Fourier Transform (DFT)"></a>Discrete Fourier Transform (DFT)</h2><p>The discrete Fourier transform transforms a sequence of N complex numbers<br>\[\lbrace x_{n} \rbrace :&#x3D; x_0, x_1,…, x_{N-1} \] into another sequence of complex numbers,<br>\[\lbrace X_{k} \rbrace :&#x3D; X_0, X_1,…, X_{N-1} \] which is defined by<br>\[X_{k} &#x3D; \sum_{n&#x3D;0}^{N-1} x_{n} \cdot e^{-\frac{i2\pi}{N}kn}\]</p>
<p>let the n-th root of unity be \(\omega_N &#x3D; e^{-\frac{2\pi i}{N}}\), we have<br>\[ \tag{1.1} X_{k} &#x3D; \sum_{n&#x3D;0}^{N-1} x_{n} \cdot \omega_N^{kn}\]</p>
<h3 id="inverse-DFT"><a href="#inverse-DFT" class="headerlink" title="inverse DFT"></a>inverse DFT</h3><p>The inverse transform is given by<br>\[ \tag{1.2} x_{n} &#x3D; \frac{1}{N}\sum_{k&#x3D;0}^{N-1} X_{k} \cdot \omega_N^{-kn}\]</p>
<h3 id="the-unitary-DFT"><a href="#the-unitary-DFT" class="headerlink" title="the unitary DFT"></a>the unitary DFT</h3><p>Another way of looking at the DFT is to note that the DFT can be expressed as the DFT matrix, a Vandermonde matrix, introduced by Sylvester in 1867.<br>\[<br>    \boldsymbol{F} &#x3D;<br>\begin{bmatrix}<br>\displaylines{<br>    \omega_{N}^{0\cdot0}   &amp; \omega_{N}^{0\cdot1}   &amp; \dots  &amp; \omega_{N}^{0\cdot (N-1)}\\<br>    \omega_{N}^{1\cdot0}   &amp; \omega_{N}^{1\cdot1}   &amp; \dots  &amp; \omega_{N}^{2\cdot (N-1)}\\<br>    \vdots                 &amp; \vdots                 &amp; \ddots &amp; \vdots\\<br>    \omega_{N}^{N-1\cdot0} &amp; \omega_{N}^{N-1\cdot1} &amp; \dots  &amp; \omega_{N}^{N-1\cdot (N-1)}<br>}<br>\end{bmatrix}<br>\]<br>where \( \omega_{N} &#x3D; e^{-\frac{i2\pi}{N}}\) is a primitive Nth root of unity. (any complex number that yields 1 when raised to some positive integer power n)</p>
<p>\[ X &#x3D; F \cdot x^{T}\]<br>\(x\) is a column vector</p>
<h2 id="Polynomial-amp-DFT"><a href="#Polynomial-amp-DFT" class="headerlink" title="Polynomial &amp; DFT"></a>Polynomial &amp; DFT</h2><h3 id="Polynomial-evaluation-amp-DFT"><a href="#Polynomial-evaluation-amp-DFT" class="headerlink" title="Polynomial evaluation &amp; DFT"></a>Polynomial evaluation &amp; DFT</h3><p>let a polynomial be<br>$$f(x)&#x3D;\sum_{n&#x3D;0}^{N-1}x_nx^n$$<br>then,<br>$$f(\omega_N^{k})&#x3D;\sum_{n&#x3D;0}^{N-1}x_n\omega_N^{kn},\quad k&#x3D;0,1,2,…,N-1$$<br>compare this equation with E.q(1.1), we can know that DFT is the evaluations of a polynomial at N points of Nth root of unity, \(\omega_N^{0},\omega_N^1,\omega_N^2,…,\omega_N^{N-1}\)</p>
<p>$$(\omega_N^{0},X_0),(\omega_N^1,X_1),(\omega_N^2,X_2),…,(\omega_N^{N-1},X_{N-1})$$</p>
<h3 id="Polynomial-interpolation-amp-IDFT"><a href="#Polynomial-interpolation-amp-IDFT" class="headerlink" title="Polynomial interpolation &amp; IDFT"></a>Polynomial interpolation &amp; IDFT</h3><p>According to E.q(1.2), IDFT is the polynomial interpolation (getting original polynomial coefficients).</p>
<h2 id="Fast-Fourier-Transform-FFT-3"><a href="#Fast-Fourier-Transform-FFT-3" class="headerlink" title="Fast Fourier Transform (FFT) [3]"></a>Fast Fourier Transform (FFT) [3]</h2><p>The problem is to calculate the below<br>\[ \tag{2.1} X_{k} &#x3D; \sum_{n&#x3D;0}^{N-1} x_{n} \cdot \omega_N^{kn}, \quad  k&#x3D; 0,1,…,N-1\]<br>A straightforward calculation using would require \(N^2\) operations where “operation” means, as it will throughout this note, a complex multiplication followed by a complex addition.<br>The FFT algorithm described here iterates on the array and yields the result in less than \( 2N log_2N \)</p>
<p>To derive the algorithm, suppose \(N\) is a composite, i.e., \(N &#x3D; r_1\cdot r_2\). Then let the indices in (2.1) be expressed<br>\[ k &#x3D; k_1r_1 + k_0, \quad k_0 &#x3D; 0,1,…,r_1-1, \quad k_1 &#x3D; 0,1,…, r_2 -1 \]<br>\[ n &#x3D; n_1r_2 + n_0, \quad n_0 &#x3D; 0,1,…,r_2-1, \quad n_1 &#x3D; 0,1,…, r_1 -1 \]</p>
<p>Since \(  n &#x3D; n_1r_2 + n_0\), we can write</p>
<p>\[ \tag{2.2} X(k_1, k_0) &#x3D; \sum_{n_0} \sum_{n_1}x(n_1,n_0)\omega_N^{kn} &#x3D; \sum_{n_0} \sum_{n_1}x(n_1,n_0)\omega_N^{kn_1r_2}\omega_N^{kn_0}  \]<br><strong>note</strong> \( x(n_1,n_0)\) is same to \(x(n)\), just the indexing is transformed form 1D to 2D. You can think original 1D array of size N is resized to a matrix of size \( (r_2, r_1) \), \(r_1\) is number of cols, while \(r_2\) is number of rows</p>
<p>Since \(k &#x3D; k_1r_1 + k_0\), we have<br>\[ \omega_N^{kn_1r_2} &#x3D;\omega_N^{(k_1r_1+k_0)n_1r_2} &#x3D; \omega_N^{(k_1r_1)n_1r_2} \cdot \omega_N^{k_0n_1r_2}\]<br>according to the property of Nth root of unity, \( \omega_N^{N} &#x3D; \omega_N^{r_1r_2} &#x3D;1 \), \( \omega_N^{(k_1r_1)n_1r_2}\) is also 1.<br>then we have<br>\[ \omega_N^{kn_1r_2} &#x3D;  \omega_N^{k_0n_1r_2}\]<br>substitute it into E.q 2.2, we get<br>\[ \tag{2.3} X(k_1, k_0) &#x3D; \sum_{n_0} \sum_{n_1}x(n_1,n_0)\omega_N^{kn} &#x3D; \sum_{n_0} \sum_{n_1}x(n_1,n_0)\omega_N^{k_0n_1r_2}\omega_N^{kn_0}  \]<br>Therefore, the inner sum, over \(n_1\), depends only on \(k_0\) and \(n_0\), and can be defined as a new array,<br>\[ \tag{2.4} x_1(k_0, n_0) &#x3D; \sum_{n_1} x(n_1, n_0) \cdot \omega_N^{k_0n_1r_2}\]<br>E.q(2.3) can be writtern as<br>\[ \tag{2.5} X(k_1, k_0) &#x3D; \sum_{n_0} x_1(k_0,n_0)\omega_N^{kn_0} &#x3D;  \sum_{n_0} x_1(k_0,n_0)\omega_N^{(k_1r_1 + k_0)n_0}  \]</p>
<p>There are N elements in the matrix \(x_1\), each requiring \(r_1\) operations, giving a total of \(Nr_1\) operations. Similarly, it takes \(Nr_2\) operations to calculate \(X\) from \(x_1\). Therefore, the two-step algorithm, given by Eq(2.4) and Eq(2.5) requires a total of<br>\[ \tag{2.6} T &#x3D; N(r_1+r_2) \]</p>
<p>it is easy to see how successive applications of the above procedure (recursively),  starting with its appliation to Eq(2.4) give an m-step algorihtm requiring<br>\[ \tag{2.7} T &#x3D; N(r_1+r_2 + … + r_m) \]<br>where<br>\[ N &#x3D; \prod_{j&#x3D;1}^{j&#x3D;m}r_j\]<br>if all \(r_j\) are equal to \(r\), i.e \(N &#x3D; r^m \), which gives \( m &#x3D; log_rN \)<br>E.q(2.7) becomes<br>\[ \tag{2.8} T &#x3D; N(m \cdot r)  &#x3D; rNm &#x3D; rN(log_rN) \]</p>
<h2 id="radix-2-FFT"><a href="#radix-2-FFT" class="headerlink" title="radix-2 FFT"></a>radix-2 FFT</h2><p>The algorithm with \(r&#x3D;2\) is derived by expressing the indices in the form</p>
<p>\[\tag{3.1} k&#x3D;k_{m-1} \cdot 2^{m-1} + … + k_1 \cdot 2 + k_0 \]<br>\[\tag{3.2} n&#x3D;n_{m-1} \cdot 2^{m-1} + … + n_1 \cdot 2 + n_0 \]<br>where \( k_v \in [0,1] \), for \( v &#x3D; 0,…,m-1 \), and \( n_v \in [0,1] \), for \( v &#x3D; 0,…,m-1 \)<br><strong>\(k_v\) and \(n_v\) are the contents of the respective bit positions in the binary representation of \(k\) and \(n\)</strong></p>
<p>All arrays will now be written as functions of the bits of their indices. With this convention E.q(2.1) is written as<br>\[ \tag{3.3}<br>\displaylines{<br>  X(k_{m-1}, …, k_0) &#x3D; \sum_{n_0}\sum_{n_1} … \sum_{n_{m-1}} x(n_{m-1}, …,n_1, n_0) \cdot \omega_N^{kn} \\<br>  &#x3D; \sum_{n_0}\sum_{n_1} … \sum_{n_{m-1}} x(n_{m-1}, …,n_1, n_0) \cdot \omega_N^{k(n_{m-1} \cdot 2^{m-1} + … + n_1 \cdot 2 + n_0)} \\<br>  &#x3D; \sum_{n_0}\sum_{n_1} … \sum_{n_{m-1}} x(n_{m-1}, …,n_1, n_0) \cdot \omega_N^{kn_{m-1} \cdot 2^{m-1} + … + kn_1 \cdot 2 + kn_0}<br>}<br>\]<br>where the sums are over \(n_v \in [0,1]\), for \(v &#x3D; 0,1,…,m-1\)</p>
<p>Since \[ \displaylines{<br>  \omega_N^{kn_{m-1}\cdot 2^{m-1}} &#x3D; \omega_N^{(k_{m-1} \cdot 2^{m-1} + … + k_1 \cdot 2 + k_0)n_{m-1}\cdot 2^{m-1}} \\<br>  &#x3D; \omega_N^{k_0 n_{m-1} \cdot 2^{m-1}}<br>}<br>  \]<br>(it is easy to show that all other terms are 1 as \( \omega_N^{2^m} &#x3D; 1 \), so only \( k_0\) is kept)</p>
<p>the innermost sum of E.q(3.3) over \(n_{m-1} \), depends only on \( k_0, n_{m-2}, …, n_0\) and can be writtern<br>\[ \displaylines{<br>x_1(k_0, n_{m-2}, …, n_1, n_0) &#x3D; \sum_{n_{m-1}} x(n_{m-1}, …, n_0) \cdot \omega_N^{k_0 n_{m-1} \cdot 2^{m-1}}<br>}<br>  \]</p>
<p>proceeding to the next innermost sum, over \( n_{m-2} \), and so on, and using<br>\[ \displaylines{<br>  \omega_N^{kn_{m-l}\cdot 2^{m-l}} &#x3D; \omega_N^{(k_{m-1} \cdot 2^{m-1} + … + k_1 \cdot 2 + k_0)n_{m-l}\cdot 2^{m-l}} \\<br>  &#x3D; \omega_N^{(k_{l-1}\cdot 2^{l-1} + … + k_0) n_{m-l} \cdot 2^{m-1}}<br>}<br>  \]<br>one obtains successive arrays<br>\[\displaylines{<br>x_l(k_0, …, k_{l-1}, n_{m-l-1}, … , n_0)   \\<br>&#x3D; \sum_{n_{m-l}}x_{l-1}(k_0, …, k_{l-2}, n_{m-l}, …, n_0 ) \cdot \omega_N^{(k_{l-1}\cdot 2^{l-1} + …+ k_0) \cdot n_{m-l} \cdot 2^{m-l}}<br>}\]<br>for \(l &#x3D; 1,2,…,m \)</p>
<p>writing out the sum this appears as<br>\[  \tag{3.4} \displaylines{<br>x_l(k_0, …, k_{l-1}, n_{m-l-1}, … , n_0)   \\<br>&#x3D; x_{l-1}(k_0, …, k_{l-2}, 0, n_{m-l -1}, …, n_0 ) \cdot \omega_N^{(k_{l-1}\cdot 2^{l-1} + …+ k_0) \cdot 0 \cdot 2^{m-l}}   \\<br>+ x_{l-1}(k_0, …, k_{l-2}, 1, n_{m-l -1}, …, n_0 ) \cdot \omega_N^{(k_{l-1}\cdot 2^{l-1} + …+ k_0) \cdot 1 \cdot 2^{m-l}}  \\<br>&#x3D; x_{l-1}(k_0, …, k_{l-2}, 0, n_{m-l -1}, …, n_0 ) \\<br>+ x_{l-1}(k_0, …, k_{l-2}, 1, n_{m-l-1}, …, n_0 ) \cdot \omega_N^{(k_{l-1}\cdot 2^{l-1} + k_{l-2}\cdot 2^{l-2 }+k_{l-3}\cdot 2^{l-3} + …+ k_0) \cdot 2^{m-l}} \\<br>&#x3D; x_{l-1}(k_0, …, k_{l-2}, 0, n_{m-l -1}, …, n_0 ) \\<br>+ \omega_N^{k_{l-1}\cdot 2^{l-1} \cdot 2^{m-l} } \cdot \omega_N^{k_{l-2}\cdot 2^{l-2 } \cdot 2^{m-l}} \cdot x_{l-1}(k_0, …, k_{l-2}, 1, n_{m-l-1}, …, n_0 ) \cdot \omega_N^{(k_{l-3}\cdot 2^{l-3} + …+ k_0) \cdot 2^{m-l}} \\<br>&#x3D; x_{l-1}(k_0, …, k_{l-2}, 0, n_{m-l -1}, …, n_0 ) \\<br>+ \omega_N^{k_{l-1}\cdot 2^{m-1} } \cdot \omega_N^{k_{l-2}\cdot 2^{m-2}} \cdot x_{l-1}(k_0, …, k_{l-2}, 1, n_{m-l-1}, …, n_0 ) \cdot \omega_N^{(k_{l-3}\cdot 2^{l-3} + …+ k_0) \cdot 2^{m-l}} \\<br>&#x3D; x_{l-1}(k_0, …, k_{l-2}, 0, n_{m-l -1}, …, n_0 ) \\<br>+ (-1)^{k_{l-1} } \cdot i^{k_{l-2}} \cdot x_{l-1}(k_0, …, k_{l-2}, 1, n_{m-l-1}, …, n_0 ) \cdot \omega_N^{(k_{l-3}\cdot 2^{l-3} + …+ k_0) \cdot 2^{m-l}}<br>}\]<br>according to the indexing convension, this is stored in a location whose index is<br>\[ k_0 \cdot 2^{m-1} + … + k_{l-1} \cdot 2 ^{m-l} + n_{m-l-1} \cdot 2^{m-l-1} + … + n_0 \]</p>
<p>It can be seen in E.q(3.4) that only the two storage locations with indices having 0 and 1 in the \(2^{m-l}\) bit position are involved in the computation. Parallel computation is permitted since the operation described by E.q(3.4) can be carried out with all values of \(k_0, …, k_{l-2} \), and \( n_0, …, n_{m-l-1}\) simultaneously. In some applications it is convenient to use E.q(3.4) to express \(x_l\) in terms of \(x_{l-2}\), giving what is equivalent to an algorithm with \(r &#x3D; 4\).<br>the last array calculated gives the desired Fourier sums,</p>
<p>\[\tag{3.5}<br>X(k_{m-1}, …, k_0) &#x3D; x_{m}(k_0, …, k_{m-1})<br>\]<br>in such an order that the index of an X must have its binary bits put in reverse order to yield its index in the array \(x_m\)</p>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=MB6XGQWLV04">youtube video by Steve Brunton, Fourier Series</a></li>
<li>[2] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform">DFT wikipedia</a></li>
<li>[3] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm">Cooley–Tukey FFT algorithm wikipedia</a></li>
<li>[4] <a target="_blank" rel="noopener" href="https://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0178586-1/S0025-5718-1965-0178586-1.pdf">1965, Cooley &amp; Turkey: an algorithm for the machine calculation of complex fourier series</a></li>
<li>[5] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Split-radix_FFT_algorithm">Split-radix FFT algorithm wikipedia</a></li>
<li>[6] <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43870101/article/details/106095644?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-2-106095644-blog-132357995.235%5Ev38%5Epc_relevant_sort_base1&spm=1001.2101.3001.4242.2&utm_relevant_index=5">csdn blog of FFT notes</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/10/12/math/fourier-series/" data-id="clokyy8dv0021qwsjhghcad7b" data-title="fourier series, DFT and FFT" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/math/" rel="tag">math</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tools/markdown_and_latex" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/01/tools/markdown_and_latex/" class="article-date">
  <time class="dt-published" datetime="2023-10-01T01:22:35.000Z" itemprop="datePublished">2023-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/10/01/tools/markdown_and_latex/">markdown &amp; latex</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="markdown-by-example"><a href="#markdown-by-example" class="headerlink" title="markdown by example"></a>markdown by example</h2><p><em>italic</em><br><span style="color:red">color</span></p>
<h2 id="latex-by-example"><a href="#latex-by-example" class="headerlink" title="latex by example"></a>latex by example</h2><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p>\( \mu \)<br>\( \omega \)<br>\( \sigma \)<br>\( \epsilon \)<br>\( \zeta \)<br>\( \eta \)<br>\( \theta \)<br>\( \kappa \)<br>\( \nu \)<br>\( \omicron \)<br>\( \rho \)<br>\( \delta \)<br>\( \tau \)<br>\( \upsilon \)<br>\( \phi \)<br>\( \chi \)<br>\( \psi \)<br>\(\mathcal O\)</p>
<h2 id="font-amp-effects"><a href="#font-amp-effects" class="headerlink" title="font &amp; effects"></a>font &amp; effects</h2><p>\( \mathbb{G_{1}}\)<br>\( \boldsymbol{F}\)<br>\( \hat{h} \)</p>
<h2 id="equation"><a href="#equation" class="headerlink" title="equation"></a>equation</h2><p>\[  \tag{1.1} X &#x3D; F \cdot x^{T}\]</p>
<h2 id="blob"><a href="#blob" class="headerlink" title="blob"></a>blob</h2><p>\[<br>\begin{bmatrix}<br>\displaylines{<br>    \omega_{N}^{0\cdot0}   &amp; \omega_{N}^{0\cdot1}   &amp; \dots  &amp; \omega_{N}^{0\cdot (N-1)}\\<br>    \omega_{N}^{1\cdot0}   &amp; \omega_{N}^{1\cdot1}   &amp; \dots  &amp; \omega_{N}^{2\cdot (N-1)}\\<br>    \vdots                 &amp; \vdots                 &amp; \ddots &amp; \vdots\\<br>    \omega_{N}^{N-1\cdot0} &amp; \omega_{N}^{N-1\cdot1} &amp; \dots  &amp; \omega_{N}^{N-1\cdot (N-1)}<br>}<br>\end{bmatrix}<br>\]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/10/01/tools/markdown_and_latex/" data-id="clokyy8dv001zqwsj9hdfghdd" data-title="markdown &amp; latex" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tool/" rel="tag">tool</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/zkp/zkp-demystify-zokrates" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/14/cryptography/zkp/zkp-demystify-zokrates/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T06:29:26.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/14/cryptography/zkp/zkp-demystify-zokrates/">zkp demystify zokrates</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h2><h3 id="source-file"><a href="#source-file" class="headerlink" title="source file"></a>source file</h3><p>an example, <code>square.zok</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def main(private field a, field b) &#123;</span><br><span class="line">    assert(a * a == b);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>The keyword private signals that we do not want to reveal this input, but still prove that we know its value.</li>
</ul>
<h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zokrates compile -i root.zok</span><br></pre></td></tr></table></figure>
<p>after compile, it generates below files</p>
<ul>
<li>out</li>
<li>out.r1cs</li>
<li>abi.json</li>
</ul>
<h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>Performs a trusted setup for a given constraint system</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zokrates setup</span><br></pre></td></tr></table></figure>
<p>options </p>
<ul>
<li>-i, –input <FILE>                       Path of the binary [default: out]<br>it generates below two files</li>
<li>proving.key</li>
<li>verification.key</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/07/14/cryptography/zkp/zkp-demystify-zokrates/" data-id="clokyy8e00039qwsjfxurcxan" data-title="zkp demystify zokrates" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/zkp/zkp-groth16-demystified" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/07/cryptography/zkp/zkp-groth16-demystified/" class="article-date">
  <time class="dt-published" datetime="2023-07-07T06:29:26.000Z" itemprop="datePublished">2023-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/07/cryptography/zkp/zkp-groth16-demystified/">groth16 demystified</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>Goldwasser, Micali and Rackoff [GMR89] introduced zero-knowledge proofs that enable a prover to convince a verifier that a statement is true without revealing anything else. They have three core properties:</p>
<ul>
<li><strong>Completeness</strong>: Given a statement and a witness, the prover can convince the verifier. </li>
<li><strong>Soundness</strong>: A malicious prover cannot convince the verifier of a false statement. </li>
<li><strong>Zero-knowledge</strong>: The proof does not reveal anything but the truth of the statement</li>
</ul>
<h3 id="1-1-Contribution"><a href="#1-1-Contribution" class="headerlink" title="1.1. Contribution"></a>1.1. Contribution</h3><p><strong>Succinct NIZK</strong> We construct a NIZK argument for arithmetic circuit satisfiability where a proof consists of only 3 group elements. In addition to being small, the proof is also easy to verify. The verifier just needs to compute a number of exponentiations proportional to the statement size and check a single pairing product equation, which only has 3 pairings.</p>
<h2 id="2-Preliminaries"><a href="#2-Preliminaries" class="headerlink" title="2. Preliminaries"></a>2. Preliminaries</h2><h3 id="2-1-Bilinear-Groups"><a href="#2-1-Bilinear-Groups" class="headerlink" title="2.1 Bilinear Groups"></a>2.1 Bilinear Groups</h3><p>We will work over bilinear groups \((p, \mathbb{G_{1}}, \mathbb{G_{2}}, \mathbb{G_{T}} , e, g, h)\) with the following properties:</p>
<ul>
<li>\(\mathbb{G_{1}}, \mathbb{G_{2}}, \mathbb{G_{T}} \)are groups of prime order \(p\)</li>
<li>The pairing \( e:\mathbb{G_{1}} \times \mathbb{G_{2}} \rightarrow \mathbb{G_{T}}\) is a bilinear map</li>
<li>\(g\) is a generator for \(\mathbb{G_{1}}\), \(h\) is a generator for \(\mathbb{G_{2}}\), and \(e(g,h)\) is a generator for \(\mathbb{G_{T}}\)</li>
</ul>
<p>There are many ways to set up bilinear groups both as symmetric bilinear groups where \(\mathbb{G_{1}} &#x3D; \mathbb{G_{1}}\) and as asymmetric bilinear groups where \(\mathbb{G_{1}} \neq \mathbb{G_{1}}\). Galbraith, Paterson and Smart [GPS08] classify bilinear groups as <strong>Type I</strong> where \(\mathbb{G_{1}} &#x3D; \mathbb{G_{2}}\), <strong>Type II</strong> where there is an efficiently computable non-trivial homomorphism \(\Phi : \mathbb{G_{2}} \rightarrow \mathbb{G_{1}}\), and <strong>Type III</strong> where no such efficiently computable homomorphism exists in either direction between \(\mathbb{G_{1}}\) and \(\mathbb{G_{2}}\). Type III bilinear groups are the most efficient type of bilinear groups and hence the most relevant for practical applications.<br>As a notation for group elements, we write \( \lbrack a \rbrack_{1} \) for \( g^a\), \( \lbrack b \rbrack_{2}\) for \( h^b\) and \( \lbrack c \rbrack_{T}\) for \(e(g,h)^{c} \).  A vector of group elements will be represented as \( \lbrack \mathbf{a} \rbrack_{i} \).  Given two vectors of \(n\) group elements \( \lbrack \mathbf{a} \rbrack_{1} \) and \( \lbrack \mathbf{b} \rbrack_{2} \), we define their dot product as \( \lbrack \mathbf{a} \rbrack_{1} \cdot \lbrack \mathbf{b} \rbrack_{2}  &#x3D; \lbrack \mathbf{a} \cdot  \mathbf{b} \rbrack_{T} \), which can be efficiently computed using the pairing \(e\).</p>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><h3 id="R1CS"><a href="#R1CS" class="headerlink" title="R1CS"></a>R1CS</h3><p>Let \(A, B,C\) be \(m \times n\) matrices with entries from field \( \mathbb{F}\). An R1CA instance takes the form:<br>\[ \tag{1} (z\cdot A) \odot (z \cdot B) &#x3D; z \cdot C \]<br>where \(\cdot\) denotes dot product and \(\odot\) denotes entry-wise product. we required \(z_0 &#x3D; 1\) because otherwise, \(z&#x3D;0\) would satisfy every R1CS instance.</p>
<p><strong>note</strong>: <code>m</code> is the number of witness, <code>n</code> is number of constraints.</p>
<h3 id="QAP"><a href="#QAP" class="headerlink" title="QAP"></a>QAP</h3><p>Consider an arithmetic circuit \({C, x,y}\) with addition and multiplication gates, where we designate some input&#x2F;output wires to specify statement \(x\) and the rest of the wires to specify witness \(\omega\). The prover wants to convince the verifier that there exists a witness \(\omega\) such that \(C(x,\omega) &#x3D; y\). If the prover knows a witness \(\omega\), then they know a vector \(z\) that satisfies the constraint of the R1CS. We set the solution vector \(z\) to be an \(m\)-length vector, where \(z_0&#x3D;1\). each remaining entry of \(z\) represents either the statement \(x\) or witness \(\omega\). Namely, \(x&#x3D;\{z_1, …, z_l\}\) and \(\omega&#x3D;\{ z_{l+1},…,z_{m}\}\). </p>
<p>Choose arbitrary distinct elements \(\{r_1, r_2, …, r_n\} \in \mathbb{F}\), where \(r_i\) indicating gate number. We define polynomial coefficient matrices such that each polynomial evaluation encodes an R1CS constraint:<br>\[\tag{2} A_i(r_q) &#x3D; A_{i,q} \quad B_i(r_q) &#x3D; B_{i,q} \quad C_i(r_q) &#x3D; C_{i,q} \]<br>where \(i &#x3D; 1,…,m; q&#x3D;1,…,n\)<br>we sum these polynomial vector groups to define three univariate polynomials<br>\[ \tag{3} A(X) &#x3D; \sum_{i&#x3D;0}^{m}z_iA_i(X) \quad B(X) &#x3D; \sum_{i&#x3D;0}^{m}z_iB_i(X) \quad C(X) &#x3D; \sum_{i&#x3D;0}^{m}z_iC_i(X)\]<br>The witness vector \(z\), where \(z_0&#x3D;1\), will satisfy the \(n\) equations in the R1CS instance if and only if at each point \(\{r_1, r_2,…r_n\}\):<br>\[ \tag{4} \sum_{i&#x3D;0}^{m}z_iA_i(r_q) \cdot \sum_{i&#x3D;0}^{m}z_iB_i(r_q) &#x3D; \sum_{i&#x3D;0}^{m}z_iC_i(r_q)\]</p>
<p>We know \(t(x):&#x3D;(x-r_1)(x-r_2)…(x-r_n) &#x3D;\prod_{q&#x3D;1}^{n}(x-r_q)\) is the lowest degree monomial such that \(t(r_q)&#x3D;0\) in each point. Thus, we can reformulate the above as:</p>
<p>\[ \tag{5} \sum_{i&#x3D;0}^{m}z_iA_i(r_q) \cdot \sum_{i&#x3D;0}^{m}z_iB_i(r_q) &#x3D; \sum_{i&#x3D;0}^{m}z_iC_i(r_q)  \mod t(X)\]<br>Thus, the derived QAP defines the following relation R, where \(z_0 &#x3D;1\)<br>\(<br>  \begin{equation}<br>  R &#x3D;<br>    \begin{cases}<br>      x&#x3D;(z_1,…,z_l) \in \mathbb{F}^l \\<br>      \omega &#x3D;(z_{l+1},…,z_m) \in \mathbb{F}^{m-l} \\<br>      \sum_{i&#x3D;0}^{m}z_iA_i(r_q) \cdot \sum_{i&#x3D;0}^{m}z_iB_i(r_q) &#x3D; \sum_{i&#x3D;0}^{m}z_iC_i(r_q)  \mod t(X)<br>    \end{cases}<br>\end{equation}<br>  \)</p>
<h3 id="Verifying-the-QAP"><a href="#Verifying-the-QAP" class="headerlink" title="Verifying the QAP"></a>Verifying the QAP</h3><p>Let these QAP polynomials be defined as \(A(X), B(X), C(X)\) where \(A(X) &#x3D; \sum_{i&#x3D;0}^{m}z_iA_i(X)\) and similarly for \(B,C\). Let \(g_z\) denote the d-degree polynomial, where \(d\le 2(n-1)\) since \(A(X), B(X), C(X)\) are at most degree \(n-1\)<br>\[ g_z(X) &#x3D; \sum_{i&#x3D;0}^{m}z_iA_i(X) \cdot \sum_{i&#x3D;0}^{m} z_iB_i(X) - \sum_{i&#x3D;0}^{m}z_iC_i(X)  \]<br>To verify the QAP, we show the existence of a low-degree polynomial \( h(X) &#x3D; \frac{g_z(X)}{t(X)} \)</p>
<h3 id="Non-Interactive-Zero-Knowledge-NIZK-arguments-for-QAP"><a href="#Non-Interactive-Zero-Knowledge-NIZK-arguments-for-QAP" class="headerlink" title="Non-Interactive Zero-Knowledge(NIZK) arguments for QAP"></a>Non-Interactive Zero-Knowledge(NIZK) arguments for QAP</h3><p>Consider \(R&#x3D;(p, \mathbb{G_1}, \mathbb{G_2}, \mathbb{G_T}, e, g_1, g_2, l, \{A_i(X), B_i(X), C_i(X)\}, t(X))\)</p>
<p>Recall \(x&#x3D;(z_1,…,z_l) \in \mathbb{Z}_{p}^{l}\)</p>
<p>and \(\omega&#x3D;(z_{l+1},…,z_m) \in \mathbb{Z}_{p}^{m-l}\), where \(z_0&#x3D;1\). The relation defines<br>\[ A(X) \cdot B(X) -C(X) &#x3D; h(X)t(X) \]</p>
<h3 id="Trusted-Setup"><a href="#Trusted-Setup" class="headerlink" title="Trusted Setup"></a>Trusted Setup</h3><p>Groth16 uses a two-step trusted setup to generate the common reference string (CRS). The trusted setup consists of two phases: the first is generic and the second is specific to the circuit.<br>As our CRS, we generate the random field elements \(\alpha, \beta, \gamma, \delta, \tau \in \mathbb{Z}_{p}^{*}\)</p>
<h4 id="phase-1-powers-of-tau"><a href="#phase-1-powers-of-tau" class="headerlink" title="phase 1 powers of tau"></a>phase 1 powers of tau</h4><p>\( (\lbrack \tau^0 \rbrack_{1}, \lbrack \tau^1 \rbrack_{1}, \lbrack \tau^2 \rbrack_{1},…, \lbrack \tau^{2(n-1)} \rbrack_{1}) \)<br>\( (\lbrack \tau^0 \rbrack_{2}, \lbrack \tau^1 \rbrack_{2}, \lbrack \tau^2 \rbrack_{2},…, \lbrack \tau^{n-1} \rbrack_{2}) \)<br>\( \lbrack \alpha \rbrack_{1} \cdot (\lbrack \tau^0 \rbrack_{1}, \lbrack \tau^1 \rbrack_{1}, \lbrack \tau^2 \rbrack_{1},…, \lbrack \tau^{n-1} \rbrack_{1}) \)<br>\( \lbrack \beta \rbrack_{1} \cdot (\lbrack \tau^0 \rbrack_{1}, \lbrack \tau^1 \rbrack_{1}, \lbrack \tau^2 \rbrack_{1},…, \lbrack \tau^{n-1} \rbrack_{1}) \)<br>\(\lbrack \beta \rbrack_{2}\)</p>
<h4 id="phase-2"><a href="#phase-2" class="headerlink" title="phase 2"></a>phase 2</h4><p>Given \(A_i, B_i, C_i\), we define polynomials \(L_i: L_i(X) &#x3D; \beta \cdot A_i(X) + \alpha \cdot B_i(X) +C_i(X) \). We cannot compute \(L_i(X)\) directly because \(\alpha\) and \(\beta\) are private, so instead, we construct \(L_i(\tau)\cdot g_i\) using values computed in Phase 1.</p>
<h4 id="providng-key-pk"><a href="#providng-key-pk" class="headerlink" title="providng key (pk)"></a>providng key (pk)</h4><p>\((\lbrack \alpha \rbrack_{1}, \lbrack \beta \rbrack_{1}, \lbrack \delta \rbrack_{1})\)<br>\((\lbrack \tau^0 \rbrack_{1}, \lbrack \tau^2 \rbrack_{1}, \lbrack \tau^2 \rbrack_{1},…,  \lbrack \tau^{n-1} \rbrack_{1})\)<br>\( \lbrack \delta^{-1} \rbrack_{1} \cdot( \lbrack L_l(\tau) \rbrack_{1}, \lbrack L_{l+1}(\tau) \rbrack_{1}, …, \lbrack L_{n-1}(\tau) \rbrack_{1}   ) \)<br>\(  \lbrack \delta^{-1} \rbrack_{1} \cdot (\lbrack \tau^0 \rbrack_{1}, \lbrack \tau^1 \rbrack_{1},\lbrack \tau^2 \rbrack_{1},…,  \lbrack \tau^{n-1} \rbrack_{1}) \cdot \lbrack t(\tau) \rbrack_{1} \)<br>\( \lbrack \beta \rbrack_{2}, \lbrack \delta \rbrack_{2}\)<br>\((\lbrack \tau^0 \rbrack_{2}, \lbrack \tau^1 \rbrack_{2}, \lbrack \tau^2 \rbrack_{2},…,  \lbrack \tau^{n-1} \rbrack_{2})\)</p>
<h4 id="Verification-key-vk"><a href="#Verification-key-vk" class="headerlink" title="Verification key (vk)"></a>Verification key (vk)</h4><p>\(\lbrack \alpha \rbrack_{1}\)<br>\( \lbrack \gamma^{-1} \rbrack_{1} \cdot( \lbrack L_0(\tau) \rbrack_{1}, \lbrack L_{1}(\tau) \rbrack_{1},\lbrack L_{2}(\tau) \rbrack_{1}, …, \lbrack L_{l-1}(\tau) \rbrack_{1}   ) \)<br>\( (\lbrack \beta \rbrack_{2}, \lbrack \gamma \rbrack_{2}, \lbrack \delta \rbrack_{2}) \)</p>
<h3 id="Formal-Groth16-NIZK-argument"><a href="#Formal-Groth16-NIZK-argument" class="headerlink" title="Formal Groth16 NIZK argument"></a>Formal Groth16 NIZK argument</h3><ol>
<li>\((pk,vk) \leftarrow SETUP(R)\): Choose \(vk&#x3D;(\alpha,\beta,\gamma,\delta,\tau) \in \mathbb{Z}_p^{*}\) and compute proving key<br>\(\left(\left[p k_1\right]_1,\left[p k_2\right]_2\right)\)</li>
</ol>
<p>\[<br> pk_1&#x3D;(\alpha,\beta,\delta,<br>\{ \tau^i \}_{i&#x3D;0}^{n-1}, \left\{ \frac{\beta A_i(\tau) + \alpha B_i(\tau) + C_i(\tau)}{\gamma} \right\}_{i&#x3D;0}^{l},<br>\left\{ \frac{\beta A_i(\tau) + \alpha B_i(\tau) + C_i(\tau)}{\delta} \right\}_{i&#x3D;l+1}^{m},\{ \frac{\tau^i \cdot t(\tau) }{\delta}\}_{i&#x3D;0}^{n-2}<br>)\]</p>
<p>\[ pk_2&#x3D;(\beta,\delta,\gamma, \{ \tau^i \}_{i&#x3D;0}^{n-1}) \]</p>
<ol start="2">
<li>\(\pi \leftarrow PROVE(R, pk, x,\omega)\): Given witness \(\omega&#x3D;(z_{l+1},…,z_m)\) and two random \((r,s)\in \mathbb{Z}_p\), compute \(\pi&#x3D;(\lbrack A \rbrack_{1}, \lbrack C \rbrack_{1}, \lbrack B \rbrack_{2})\) where</li>
</ol>
<p>\[ A&#x3D; \alpha +\sum_{i&#x3D;0}^{m}z_iA_i(\tau)+r\delta\]<br>\[ B&#x3D; \beta +\sum_{i&#x3D;0}^{m}z_iB_i(\tau)+s\delta\]<br>\[ C&#x3D; \frac{\sum_{i&#x3D;l+1}^{m}z_i(\beta A_i(\tau)+\alpha B_i(\tau)+C_i(\tau))+h(\tau)t(\tau)}{\delta} + As+Br-rs\delta\]<br>\(r,s\) is used to randomize proof generation to ensure the zero-knowledge property is satisfied. As shown, all elements in A are elements in \(\mathbb{G}_1\), such as \(\alpha&#x3D;\alpha \cdot g_1\). Similarly, elements in B are in \(\mathbb{G}_2\)</p>
<ol start="3">
<li>\(0,1 \leftarrow VFY(R, pk,x\pi)\): The verifier accepts the proof \(\pi\) if and only if:<br>\[ \lbrack A \rbrack_{1} \cdot   \lbrack B \rbrack_{2} &#x3D; \lbrack \alpha \rbrack_{1} \cdot   \lbrack \beta \rbrack_{2} + \sum_{i&#x3D;0}^{l}z_i\lbrack \frac{\beta A_i(\tau) + \alpha B_i(\tau) + C_i(\tau)}{\gamma} \rbrack \cdot \lbrack \gamma \rbrack_2 + \lbrack C \rbrack_1 \cdot \lbrack \delta \rbrack_2 \]<br>Intuitively, \( \lbrack A \rbrack_{1} \cdot   \lbrack B \rbrack_{2} \) represents the pairing \(e: \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T\)</li>
</ol>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul>
<li>[1] groth 16 paper, On the Size of Pairing-based Non-interactive Arguments by Jens Groth</li>
<li>[2] 2022 Kaylee George, The Mathematical Mechanics Behind the Groth16 Zero-knowledge Proving Protocol</li>
<li>[3] <a target="_blank" rel="noopener" href="https://2π.com/22/groth16/">2pi.com groth16</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/07/07/cryptography/zkp/zkp-groth16-demystified/" data-id="clreernf90003uz7uhorxcjzk" data-title="groth16 demystified" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/zkp/zkp-under-the-hood" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/01/cryptography/zkp/zkp-under-the-hood/" class="article-date">
  <time class="dt-published" datetime="2023-07-01T06:29:26.000Z" itemprop="datePublished">2023-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/01/cryptography/zkp/zkp-under-the-hood/">zkp how and why it works</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="The-medium-of-proof-Polynomial"><a href="#The-medium-of-proof-Polynomial" class="headerlink" title="The medium of proof: Polynomial"></a>The medium of proof: Polynomial</h2><p>If a prover claims to know some polynomial (no matter how large its degree is) that the verifier also knows, they can follow a simple protocol to verify the statement<br>• Verifier chooses a random value for x and evaluates his polynomial locally<br>• Verifier gives x to the prover and asks to evaluate the polynomial in question<br>• Prover evaluates his polynomial at x and gives the result to the verifier<br>• Verifier checks if the local result is equal to the prover’s result, and if so then the statement is proven with a high confidence</p>
<h2 id="Non-Interactive-Zero-Knowledge-of-a-Polynomial"><a href="#Non-Interactive-Zero-Knowledge-of-a-Polynomial" class="headerlink" title="Non-Interactive Zero-Knowledge of a Polynomial"></a>Non-Interactive Zero-Knowledge of a Polynomial</h2><ol>
<li><p>Proving Knowledge of a Polynomial<br>A polynomial can be expressed in the form (where n is the degree of the polynomial):<br>\[c_n x^n + …+ c_1 x^1 + c_0 x^0\]<br>It one claims that he know a polynomial, it is actually the knowledge of the polynomial’s coefficients.</p>
</li>
<li><p>Factorization<br>The Fundamental Theorem of Algebra states that any polynomial can be factored into linear po- lynomials (i.e., a degree 1 polynomials representing a line), as long it is solvable. Consequently, we can represent any valid polynomial as a product of its factors:<br>\[(x-a_0)(x-a_1)…(x-a_n) &#x3D; 0\]</p>
</li>
</ol>
<p>if the prover wants to prove that indeed his polynomial has specific roots without disclosing the polynomial itself, he needs to prove that his polynomial \(p(x)\) is the multiplication of those cofactors \(t(x) &#x3D; (x − x_0)(x − x_1)\), called target polynomial, where \(x_0, x_1\) are the specific roots. i.e.:<br>\[p(x) &#x3D; t(x) \cdot h(x)\]<br>A natural way to find \(h(x)\) is through the division \(h(x) &#x3D; \frac{p(x)}{t(x)}\)</p>
<blockquote>
<p>for simplicity, onwards we will use polynomial’s letter variable to denote its evaluation, e.g., \(p &#x3D; p(r)\)</p>
</blockquote>
<p>Using our polynomial identity check protocol we can compare polynomials \(p(x)\) and \(t(x)·h(x)\):</p>
<ul>
<li>Verifier samples a random value \(r\), calculates \(t &#x3D; t(r)\) (i.e., evaluates) and gives \(r\) to the prover</li>
<li>Prover calculates \(h(x) &#x3D; \frac{p(x)}{t(x)}\) and evaluates \(p(r)\) and \(h(r)\); the resulting values \(p,h\) are<br>provided to the verifier</li>
<li>Verifier then checks that \(p &#x3D; t \cdot h\), if so those polynomials are equal, meaning that \(p(x)\) has \(t(x)\) as a cofactor.</li>
</ul>
<p><strong>Remark 3.1</strong> Now we can check a polynomial for specific properties without learning the polyno- mial itself, so this already gives us some form of zero-knowledge and succinctness. Nonetheless, there are multiple issues with this construction:<br>• Prover may not know the claimed polynomial \(p(x)\) at all. He can calculate evaluation \(t &#x3D; t(r)\), select a random number \(h\) and set \(p &#x3D; t \cdot h\), which will be accepted by the verifier as valid, since equation holds.<br>• Because prover knows the random point \(x &#x3D; r\), he can construct any polynomial which has one shared point at \(r\) with \(t(r) \cdot h(r)\).<br>• In the original statement, prover claims to know a polynomial of a particular degree, in the current protocol there is no enforcement of degree. Hence prover can cheat by using a polynomial of higher degree which also satisfies the cofactors check.</p>
<ol start="3">
<li>Obscure Evaluation<br>Two first issues of remark 3.1 are possible because values are presented at raw, prover knows r and t(r). It would be ideal if those values would be given as a black box, so one cannot temper with the protocol, but still able to compute operations on those obscure values.<br>3.1. Homomorphic Encryption<br>There are multiple ways to achieve homomorphic properties of encryption, and we will briefly introduce a simple one. The general idea is to choose a base number \(g\) and do ecncryption of a value \(x\) by exponentiate of \(g\)<br>\[E(x) &#x3D; g^{x} \bmod p\]<br>For example, let \(E(x_1) &#x3D; g^{x_1} \bmod p\), and \(E(x_2) &#x3D; g^{x_2} \bmod p\), then<br>\[E(x_2) \cdot E(x_1) &#x3D; g^{x_1 + x_2} &#x3D; E(x_1 + x_2) \]</li>
</ol>
<p>3.2. Encrypted Polynomial<br>Let us see how we can evaluate a polynomial \(p(x) &#x3D; x^3 − 3x^2 + 2x\). Because homomorphic encryption does not allows to exponentiate an encrypted value, we’ve must been given encrypted values of powers of x from 1 to 3: \(E(x),E(x2),E(x3)\) so that<br>\[ E(x^3)^1 \cdot E(x^2)^{-3} \cdot E(x)^2 &#x3D; (g^{x^3})^{1} \cdot (g^{x^2})^{-3} \cdot (g^{x})^{2} &#x3D; g^{1x^3} \cdot g^{-3x^2} \cdot g^{2x} &#x3D; g^{x^3-3x^2+2x}\]<br>Hence, we have an encrypted evaluation of our polynomial at some unknown to us \(x\) </p>
<p>We can now update the previous version of the protocol, for a polynomial fo degree \(d\):</p>
<ul>
<li>Verifier<ul>
<li>samples a random value \(s\), i.e., secret</li>
<li>calculates encryptions of \(s\) for all powers \(i\) in \(0,1,…,d\), i.e. : \(E(s^{i}) &#x3D; g^{s^{i}}\)</li>
<li>evaluates unencrypted target polynomial with \(s: t(s)\)</li>
<li>encrypted powers of \(s\) are provided to the prover: \(E(s^{0}),E(s^{1}),…,E(s^{d})\)</li>
</ul>
</li>
<li>Prover<ul>
<li>calculates polynomial \(h(x) &#x3D; \frac{p(x)}{t(x)}\)</li>
<li>using encrypted powers \(g^{s^{0}},g^{s^{1}},…,g^{s^{d}}\) and coefficients \(c_0, c_1,…,c_n \) evaluates \(E(p(s)) &#x3D; g^{p(s)} &#x3D; (g^{s^{d}})^{c_d} \cdot \cdot \cdot (g^{s^{1}})^{c_1} \cdot (g^{s^{0}})^{c_0}\) and similarly \(E(h(s)) &#x3D; g^{h(s)}\)</li>
<li>the resulting \(g^p\) and \(g^h\) are provided to the verifier</li>
</ul>
</li>
<li>Verifier<ul>
<li>The alst step for the verifier is to checks that \(p &#x3D; t(s) \cdot h \) in encrypted space: \(g^p &#x3D; (g^h)^{t(s)}\) &#x3D;&gt; \(g^p &#x3D; g^{t(s) \cdot h}\)</li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: because the prover does not know anything about s, it makes it hard to come up with non-legitimate but still matching evaluations.</p>
</blockquote>
<h2 id="referneces"><a href="#referneces" class="headerlink" title="referneces"></a>referneces</h2><ul>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1906.07221.pdf">why and how zk-SNARK works by Maksym</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/07/01/cryptography/zkp/zkp-under-the-hood/" data-id="clokyy8e2003iqwsj23zw9035" data-title="zkp how and why it works" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/arithmatic/" rel="tag">arithmatic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchain/" rel="tag">blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cargo/" rel="tag">cargo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/circom/" rel="tag">circom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cuda/" rel="tag">cuda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ec/" rel="tag">ec</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ecdsa/" rel="tag">ecdsa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/field/" rel="tag">field</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/geth/" rel="tag">geth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mpc/" rel="tag">mpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/number-theory/" rel="tag">number_theory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust/" rel="tag">rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust-crate/" rel="tag">rust-crate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust-std/" rel="tag">rust-std</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/arithmatic/" style="font-size: 12.22px;">arithmatic</a> <a href="/tags/blockchain/" style="font-size: 15.56px;">blockchain</a> <a href="/tags/cargo/" style="font-size: 10px;">cargo</a> <a href="/tags/circom/" style="font-size: 10px;">circom</a> <a href="/tags/cpp/" style="font-size: 14.44px;">cpp</a> <a href="/tags/cryptography/" style="font-size: 20px;">cryptography</a> <a href="/tags/cuda/" style="font-size: 12.22px;">cuda</a> <a href="/tags/ec/" style="font-size: 11.11px;">ec</a> <a href="/tags/ecdsa/" style="font-size: 10px;">ecdsa</a> <a href="/tags/field/" style="font-size: 10px;">field</a> <a href="/tags/geth/" style="font-size: 16.67px;">geth</a> <a href="/tags/golang/" style="font-size: 11.11px;">golang</a> <a href="/tags/math/" style="font-size: 11.11px;">math</a> <a href="/tags/mpc/" style="font-size: 10px;">mpc</a> <a href="/tags/number-theory/" style="font-size: 10px;">number_theory</a> <a href="/tags/rust/" style="font-size: 18.89px;">rust</a> <a href="/tags/rust-crate/" style="font-size: 10px;">rust-crate</a> <a href="/tags/rust-std/" style="font-size: 13.33px;">rust-std</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/zkp/" style="font-size: 17.78px;">zkp</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/08/math/multi-scalar-multiplication/">multi scalar multiplication (MSM)</a>
          </li>
        
          <li>
            <a href="/2024/01/01/rust/rust_analyzer/">rust analyzer</a>
          </li>
        
          <li>
            <a href="/2023/12/20/cpp/build/">cpp build</a>
          </li>
        
          <li>
            <a href="/2023/12/15/cryptography/field/field/">field</a>
          </li>
        
          <li>
            <a href="/2023/12/11/cryptography/zkp/polygon_zkevm/">polygon zkEVM</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 cliff<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>