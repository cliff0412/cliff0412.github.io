<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>cliff&#39;s personal blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="cliff&#39;s personal blog">
<meta property="og:url" content="https://cliff0412.github.io/index.html">
<meta property="og:site_name" content="cliff&#39;s personal blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="cliff">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="cliff's personal blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">cliff&#39;s personal blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://cliff0412.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-cryptography/zkp/zkp-a-brief-understanding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/27/cryptography/zkp/zkp-a-brief-understanding/" class="article-date">
  <time class="dt-published" datetime="2023-06-27T06:29:26.000Z" itemprop="datePublished">2023-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/27/cryptography/zkp/zkp-a-brief-understanding/">zkp a brief understanding (1)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>zk-SNARKs cannot be applied to any computational problem directly; rather, you have to convert the problem into the right “form” for the problem to operate on. The form is called a “quadratic arithmetic program” (QAP), and transforming the code of a function into one of these is itself highly nontrivial.</p>
<p>The example that we will choose is a simple one: proving that you know the solution to a cubic equation: \(x^3 + x + 5 &#x3D;&#x3D; 35\)</p>
<p>Note that modulo (%) and comparison operators (&lt;, &gt;, ≤, ≥) are NOT supported, as there is no efficient way to do modulo or comparison directly in finite cyclic group arithmetic (be thankful for this; if there was a way to do either one, then elliptic curve cryptography would be broken faster)</p>
<p>You can extend the language to modulo and comparisons by providing bit decompositions (eg. \(13 &#x3D; 2^3 + 2^2 + 1\)) as auxiliary inputs, proving correctness of those decompositions and doing the math in binary circuits; in finite field arithmetic, doing equality <code>(==)</code> checks is also doable and in fact a bit easier, but these are both details we won’t get into right now. We can extend the language to support conditionals (eg. <code>if x &lt; 5: y = 7; else: y = 9</code>) by converting them to an arithmetic form: <code>y = 7 * (x &lt; 5) + 9 * (x &gt;= 5)</code>;though note that both “paths” of the conditional would need to be executed.</p>
<h2 id="Flattening"><a href="#Flattening" class="headerlink" title="Flattening"></a>Flattening</h2><p>The first step is a “flattening” procedure, where we convert the original code into a sequence of statements that are of two forms</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sym1 = x * x</span><br><span class="line">y = sym1 * x</span><br><span class="line">sym2 = y + x</span><br><span class="line">~out = sym2 + 5</span><br></pre></td></tr></table></figure>

<h2 id="Gates-to-R1CS"><a href="#Gates-to-R1CS" class="headerlink" title="Gates to R1CS"></a>Gates to R1CS</h2><p>Now, we convert this into something called a rank-1 constraint system (R1CS). An R1CS is a sequence of groups of three vectors <code>(a, b, c)</code>, and the solution to an R1CS is a vector s, where s must satisfy the equation <code>s . a * s . b - s . c = 0</code>, where <code>.</code> represents the dot product. For example, this is a satisfied R1CS:<br><img src="/images/cryptography/zkp/r1cs.png" alt="r1cs"><br>\[s \cdot a &#x3D; (1,3,35,9,27,30) \cdot (5,0,0,0,0,1) &#x3D; 35\]<br>\[s \cdot b &#x3D; (1,3,35,9,27,30) \cdot (1,0,0,0,0,0) &#x3D; 1\]<br>\[s \cdot c &#x3D; (1,3,35,9,27,30) \cdot (0,0,1,0,0,0) &#x3D; 35\]<br>Hence<br>\[ s \cdot a * s \cdot b - s \cdot c &#x3D; 35 * 1 - 35 &#x3D; 0\]</p>
<p>But instead of having just one constraint, we are going to have many constraints: one for each logic gate. There is a standard way of converting a logic gate into a <code>(a, b, c)</code> triple depending on what the operation is <code>(+, -, * or /)</code> and whether the arguments are variables or numbers. The length of each vector is equal to the total number of variables in the system, including a dummy variable <code>~one</code> at the first index representing the number 1, the input variables <code>x</code>, a dummy variable <code>~out</code> representing the output, and then all of the intermediate variables (<code>sym1</code> and <code>sym2</code> above);<br>First, we’ll provide the variable mapping that we’ll use:<br><code>&#39;~one&#39;, &#39;x&#39;, &#39;~out&#39;, &#39;sym1&#39;, &#39;y&#39;, &#39;sym2&#39;</code></p>
<p>Now, we’ll give the (a, b, c) triple for the first gate:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 1, 0, 0, 0, 0]</span><br><span class="line">b = [0, 1, 0, 0, 0, 0]</span><br><span class="line">c = [0, 0, 0, 1, 0, 0]</span><br></pre></td></tr></table></figure>
<p>which is \(x*x -sym1 &#x3D; 0\)</p>
<p>Now, let’s go on to the second gate:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 0, 0, 1, 0, 0]</span><br><span class="line">b = [0, 1, 0, 0, 0, 0]</span><br><span class="line">c = [0, 0, 0, 0, 1, 0]</span><br></pre></td></tr></table></figure>
<p>which is \(sym1 * x &#x3D; y\)<br>Now, the third gate:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 1, 0, 0, 1, 0]</span><br><span class="line">b = [1, 0, 0, 0, 0, 0]</span><br><span class="line">c = [0, 0, 0, 0, 0, 1]</span><br></pre></td></tr></table></figure>
<p>which is \( (x+y) *  \sim one &#x3D; sym2\)</p>
<p>Finally, the fourth gate:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [5, 0, 0, 0, 0, 1]</span><br><span class="line">b = [1, 0, 0, 0, 0, 0]</span><br><span class="line">c = [0, 0, 1, 0, 0, 0]</span><br></pre></td></tr></table></figure>
<p>which is \((5 + sym2) * \sim one &#x3D; \sim out\)<br>And there we have our R1CS with four constraints. The witness is simply the assignment to all the variables, including input, output and internal variables:<br><code>[1, 3, 35, 9, 27, 30]</code></p>
<p>The complete R1CS put together is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">[0, 1, 0, 0, 0, 0]</span><br><span class="line">[0, 0, 0, 1, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 1, 0]</span><br><span class="line">[5, 0, 0, 0, 0, 1]</span><br><span class="line">B</span><br><span class="line">[0, 1, 0, 0, 0, 0]</span><br><span class="line">[0, 1, 0, 0, 0, 0]</span><br><span class="line">[1, 0, 0, 0, 0, 0]</span><br><span class="line">[1, 0, 0, 0, 0, 0]</span><br><span class="line">C</span><br><span class="line">[0, 0, 0, 1, 0, 0]</span><br><span class="line">[0, 0, 0, 0, 1, 0]</span><br><span class="line">[0, 0, 0, 0, 0, 1]</span><br><span class="line">[0, 0, 1, 0, 0, 0]</span><br></pre></td></tr></table></figure>

<h2 id="R1CS-to-QAP"><a href="#R1CS-to-QAP" class="headerlink" title="R1CS to QAP"></a>R1CS to QAP</h2><p>The next step is taking this R1CS and converting it into QAP form, which implements the exact same logic except using polynomials instead of dot products. We do this as follows. We go from four groups of three vectors of length six to six groups of three degree-3 polynomials, where evaluating the polynomials at each x coordinate represents one of the constraints. That is, if we evaluate the polynomials at x&#x3D;1, then we get our first set of vectors, if we evaluate the polynomials at x&#x3D;2, then we get our second set of vectors, and so on.</p>
<p>We can make this transformation using something called a <strong>Lagrange interpolation</strong>.<br><img src="/images/cryptography/zkp/lagrange_interpolating.png" alt="lagrange interpolating"></p>
<p>Now, let’s use Lagrange interpolation to transform our R1CS. What we are going to do is take the first value out of every a vector, use Lagrange interpolation to make a polynomial out of that (where evaluating the polynomial at i gets you the first value of the ith a vector), repeat the process for the first value of every b and c vector, and then repeat that process for the second values, the third, values, and so on. For convenience I’ll provide the answers right now:</p>
<blockquote>
<p>Note: the intuition here is to think the R1CS A,B,C matrix vertically (column). For example, for the first column of A, the polynomial should pass (1,0), (2,0), (3,0), (4,5); the second polynomial shoudd pass (1,1), (2,0), (3,1), (4,)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A polynomials</span><br><span class="line">[-5.0, 9.166, -5.0, 0.833]</span><br><span class="line">[8.0, -11.333, 5.0, -0.666]</span><br><span class="line">[0.0, 0.0, 0.0, 0.0]</span><br><span class="line">[-6.0, 9.5, -4.0, 0.5]</span><br><span class="line">[4.0, -7.0, 3.5, -0.5]</span><br><span class="line">[-1.0, 1.833, -1.0, 0.166]</span><br><span class="line">B polynomials</span><br><span class="line">[3.0, -5.166, 2.5, -0.333]</span><br><span class="line">[-2.0, 5.166, -2.5, 0.333]</span><br><span class="line">[0.0, 0.0, 0.0, 0.0]</span><br><span class="line">[0.0, 0.0, 0.0, 0.0]</span><br><span class="line">[0.0, 0.0, 0.0, 0.0]</span><br><span class="line">[0.0, 0.0, 0.0, 0.0]</span><br><span class="line">C polynomials</span><br><span class="line">[0.0, 0.0, 0.0, 0.0]</span><br><span class="line">[0.0, 0.0, 0.0, 0.0]</span><br><span class="line">[-1.0, 1.833, -1.0, 0.166]</span><br><span class="line">[4.0, -4.333, 1.5, -0.166]</span><br><span class="line">[-6.0, 9.5, -4.0, 0.5]</span><br><span class="line">[4.0, -7.0, 3.5, -0.5]</span><br></pre></td></tr></table></figure>
<p>Coefficients are in ascending order, so the first polynomial above is actually \(0.833 x^3 — 5 x^2 + 9.166 x - 5\)<br>Let’s try evaluating all of these polynomials at x&#x3D;1. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">A results at x=1</span><br><span class="line">0 = 0.833 * 1^3 - 5 * 1^2 + 9.166 * 1^1 -5 * 1^0 = 0.833 -5 + 9.166 -5 = 0</span><br><span class="line">1 = -0.666 * 1^3 - 5.0 * 1^2 + -11.333 * 1^1 + 8.0 * 1^0 = -0.666 + 5.0 -11.333 +8.0 = 1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">B results at x=1</span><br><span class="line">0 = -0.333 * 1^3 +2.5 * 1^2 -5.166 * 1^1 +3.0 * 1^0 = -0.333 +2.5 -5.166 +3.0 = 0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">C results at x=1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="Checking-the-QAP"><a href="#Checking-the-QAP" class="headerlink" title="Checking the QAP"></a>Checking the QAP</h2><p>Now what’s the point of this crazy transformation? The answer is that instead of checking the constraints in the R1CS individually, we can now check all of the constraints at the same time by doing the dot product check on the polynomials.<br><img src="/images/cryptography/zkp/checking_qap.png" alt="checking qap"><br>Because in this case the dot product check is a series of additions and multiplications of polynomials, the result is itself going to be a polynomial. If the resulting polynomial, evaluated at every x coordinate that we used above to represent a logic gate, is equal to zero, then that means that all of the checks pass; if the resulting polynomial evaluated at at least one of the x coordinate representing a logic gate gives a nonzero value, then that means that the values going into and out of that logic gate are inconsistent</p>
<p>To check correctness, we don’t actually evaluate the polynomial <code>t = A . s * B . s - C . s</code> at every point corresponding to a gate; instead, we divide <code>t</code> by another polynomial, <code>Z</code>, and check that <code>Z</code> evenly divides <code>t</code> - that is, <strong>the division <code>t / Z</code> leaves no remainder</strong>.</p>
<p><code>Z</code> is defined as <code>(x - 1) * (x - 2) * (x - 3) ...</code> - the simplest polynomial that is equal to zero at all points that correspond to logic gates. It is an elementary fact of algebra that any polynomial that is equal to zero at all of these points has to be a multiple of this minimal polynomial, and if a polynomial is a multiple of <code>Z</code> then its evaluation at any of those points will be zero;</p>
<p>Note that the above is a simplification; “in the real world”, the addition, multiplication, subtraction and division will happen not with regular numbers, but rather with finite field elements — a spooky kind of arithmetic which is self-consistent, so all the algebraic laws we know and love still hold true, but where all answers are elements of some finite-sized set</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">vitalik’s blog: qap zero to hero</a></li>
<li><a target="_blank" rel="noopener" href="https://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html">lagrange interpolating</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/06/27/cryptography/zkp/zkp-a-brief-understanding/" data-id="clk5adu2s001i0psj6v031xej" data-title="zkp a brief understanding (1)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/cryptography-04-digital-signature" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/20/cryptography/cryptography-04-digital-signature/" class="article-date">
  <time class="dt-published" datetime="2023-06-20T06:29:26.000Z" itemprop="datePublished">2023-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/20/cryptography/cryptography-04-digital-signature/">cryptography (4) digital signature</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

<h2 id="Elgamal-Digital-Signature-Scheme"><a href="#Elgamal-Digital-Signature-Scheme" class="headerlink" title="Elgamal Digital Signature Scheme"></a>Elgamal Digital Signature Scheme</h2><p>The Elgammal signature scheme is based on the difficulty of computing discrete logarithms. Unlike RSA, where encryption and digital signature are almoste identical operations, the Elgamal digital signature is quite different from the encryption scheme with teh same name.</p>
<h3 id="key-generation"><a href="#key-generation" class="headerlink" title="key generation"></a>key generation</h3><hr>
<ol>
<li>Choose a large prime \(p\).</li>
<li>Choose a primitive element \(\alpha\) of \(Z_{p}^{\ast}\), or a subgroup of \(Z_{p}^{\ast}\).</li>
<li>Choose a random integer \(d \in {2,3,…,p-2}\)</li>
<li>Compute \(\beta &#x3D; \alpha^{d} \bmod p\)</li>
</ol>
<hr>
<p>The public key is now formed by \(k_{pub} &#x3D; (p, \alpha, \beta)\), and the private key by \(k_{pr}&#x3D;d\)<br>\(Z_{p}^{\ast}\) is the set of integers who are smaller than \(p\) and coprime to \(p\)</p>
<h3 id="signature-and-verification"><a href="#signature-and-verification" class="headerlink" title="signature and verification"></a>signature and verification</h3><p>Usign the private ey and parameters of the public key, the signature<br>\[sig_{k_{pr}}(x, k_{E}) &#x3D; (r,s)\]<br>\(x\) is the message. \(k_{E}\) is a random value, which forms an ephemeral private key</p>
<hr>
<p><strong>Elgamal Signature Generation</strong></p>
<ol>
<li>choose a random ephemeral key \(k_{E} \in {0,1,2,..,p-2}\) such that \(gcd(k_{E}, p-1) &#x3D; 1\)</li>
<li>compute the signatue parameters:<br>\[r \equiv \alpha^{k_{E}} \bmod p\]<br>\[s \equiv (x - d \cdot r)k_{E}^{-1} \bmod p-1\]</li>
</ol>
<hr>
<p>on the receiving side, the signature is verified as \(ver_{k_{pub}}(x,(r,s))\) using the public key, the signature and the message.</p>
<hr>
<p><strong>Elgamal Signature Verification</strong></p>
<ol>
<li>comput the value<br>\[t \equiv \beta^{r} \cdot r^s \bmod p\]</li>
<li>the verification follows form<br>\begin{equation}<br>t &#x3D;<br>\begin{cases}<br>\equiv \alpha^{x} \bmod p &amp; &#x3D;&gt; \text{valid signature} \cr<br>\not\equiv \alpha^{x} \bmod p  &amp; &#x3D;&gt; \text{invalid signature}<br>\end{cases}<br>\end{equation}</li>
</ol>
<hr>
<h2 id="Digital-Signature-Algorithm-DSA"><a href="#Digital-Signature-Algorithm-DSA" class="headerlink" title="Digital Signature Algorithm (DSA)"></a>Digital Signature Algorithm (DSA)</h2><p>The native Elgamal signature algorithm described above is rarely used in practice. Instead, a much more popular variant is used, known as the Digital Signature Algorithm (DSA). It is a federal US government standard for digital signatures and was proposed by NIST (National Institute of Standards and Technology). Its main advantages over the Elgamal signature scheme are that the signature is only 320-bit long and that some of the attacks<br> that can threaten the Elgamal scheme are not applicable.</p>
<h3 id="key-generation-1"><a href="#key-generation-1" class="headerlink" title="key generation"></a>key generation</h3><hr>
<p><strong>key Generation for DSA</strong></p>
<ol>
<li>Generate a prime \(p\) with \(2^1023 &lt; p &lt; 2^1024\)</li>
<li>find a prime divisor \(q\) of \(p-1\) \(2^159 &lt; q &lt; 2^160\)</li>
<li>Find an element \(\alpha\) with \( ord(\alpha) &#x3D; q\), i.e., \alpha genertes the subgroup with \(q\) elements.</li>
<li>choose a random integer \(d\) with \(0 &lt; d &lt; q\).</li>
<li>compute \(\beta \equiv \alpha^{d} \bmod p\).<br>the keys are now:<br>\(k_{pub} &#x3D; (p, q, \alpha, \beta)\)<br>\(k_{pr}&#x3D; (d)\)</li>
</ol>
<hr>
<p>The central idea of DSA is that there are two cyclic groups involved. One is the large cyclic group \(Z_{p}*{\ast}\), the order of which has bit length of 1024 bit. The second one is in the 160-bit subgroup of \(Z_{p}^{\ast}\). this set-up yields shorter signature.</p>
<h3 id="Signature-and-Verification"><a href="#Signature-and-Verification" class="headerlink" title="Signature and Verification"></a>Signature and Verification</h3><p>As in the Elgamal signatue scheme, the DSA signature consists of a pair of integers \((r,s)\). Since each of the two parameters is only 160-bit long, the total signature length is 320 bit. </p>
<hr>
<p><strong>DSA signature generation</strong></p>
<ol>
<li>choose an integer as random ephemeral key \(k_{E}\) with \(0 &lt; k_{E} &lt; q\).</li>
<li>compute \(r \equiv (\alpha^{k_{E}} \bmod p) \bmod q\)</li>
<li>compute \(s \equiv (SHA(x) + d \cdot r)k_{E}^{-1} \bmod q \)</li>
</ol>
<hr>
<p>The signature verification process is as follows:</p>
<hr>
<p><strong>DSA signature verification</strong></p>
<ol>
<li>compute auxilary value \(w \equiv s^{-1} \bmod q\).</li>
<li>compute auxilary value \(u_{1} \equiv w \cdot SHA(x) \bmod q\).</li>
<li>compute auxilary value \(u_{2} \equiv w \cdot r \bmod q\).</li>
<li>compute \(v \equiv (\alpha^{u_1} \cdot \beta^{u_2} \bmod p) \bmod q\).</li>
<li>the verification \(ver_{k_{pub}}(x, (r,s))\) folows from<br>\begin{equation}<br>v &#x3D;<br>\begin{cases}<br>\equiv r \bmod q &amp; &#x3D;&gt; \text{valid signature} \cr<br>\not\equiv r \bmod q  &amp; &#x3D;&gt; \text{invalid signature}<br>\end{cases}<br>\end{equation}</li>
</ol>
<hr>
<h2 id="Elliptic-Curve-Digital-Signature-Algorithm-ECDSA"><a href="#Elliptic-Curve-Digital-Signature-Algorithm-ECDSA" class="headerlink" title="Elliptic Curve Digital Signature Algorithm (ECDSA)"></a>Elliptic Curve Digital Signature Algorithm (ECDSA)</h2><p>Elliptic curves have several advantages over RSA and over DL schemes like Elgamal or DSA. In particular, in abscence of strong attacks against elliptic curve cryptosystems (ECC), bit lengths in the range of 160-256 bit can be chosen which provide security equivalent to 1024-3072 bit RSA and DL scheme. The shorter bit length of ECC often results in shorter processing time and in shorter signatures.<br>The ECDSA standard is defined for elliptic curves over prime fields \(Z_{p}\) adn Galois fields \(GF(2^m)\). the former is often preferred in practice, and we only introduce this one in what follows</p>
<h3 id="key-generation-2"><a href="#key-generation-2" class="headerlink" title="key generation"></a>key generation</h3><hr>
<p><strong>Key Generation for ECDSA</strong></p>
<ol>
<li>Use and elliptic curve E with</li>
</ol>
<ul>
<li>modulus p</li>
<li>coefficients a and b</li>
<li>a point A which generates a cyclic group of prime order q.</li>
</ul>
<ol start="2">
<li>choose a random integer d with \(0 &lt; d &lt; q\)</li>
<li>compute \(B &#x3D; dA\).<br>The keys are now<br>\(k_{pub} &#x3D; (p,a,b,q,A,B)\)<br>\(k_{pr} &#x3D; (d)\)</li>
</ol>
<hr>
<h3 id="Signature-and-Verification-1"><a href="#Signature-and-Verification-1" class="headerlink" title="Signature and Verification"></a>Signature and Verification</h3><hr>
<p><strong>ECDSA Signature Generation</strong></p>
<ol>
<li>choose an integer as random ephemeral key \(k_{E}\) with \( 0 &lt; k_{E} &lt; q\).</li>
<li>compute \(R &#x3D; k_{E}A\)</li>
<li>Let \(r &#x3D; x_{R}\)</li>
<li>compute \(s \equiv (h(x) + d \cdot r)k_{E}^{-1} \bmod q\)</li>
</ol>
<hr>
<p>the signature verification process is as follows</p>
<hr>
<p><strong>ECDSA Signature Verification</strong></p>
<ol>
<li>Compute auxiliary value \(w \equiv s^{-1} \bmod q\)</li>
<li>compute auxilary value \(u_1 \equiv w \cdot h(x) \bmod q\)</li>
<li>compute auxiliary value \(u_2 &#x3D; w \cdot r \bmod q\)</li>
<li>compute \(P &#x3D; u_1 A + u_2 B\).</li>
<li>the verification \(ver{k_{pub}}(x, (r,s))\) follows from<br>\begin{equation}<br>x_{P} &#x3D;<br>\begin{cases}<br>\equiv r \bmod q &amp; &#x3D;&gt; \text{valid signature} \cr<br>\not\equiv r \bmod q  &amp; &#x3D;&gt; \text{invalid signature}<br>\end{cases}<br>\end{equation}</li>
</ol>
<hr>
<p>The point multiplication, which is in most cases by the far the most arithmetic intensive operation, can be precomputed by choosing the ephemeral key ahead of time.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/06/20/cryptography/cryptography-04-digital-signature/" data-id="clk5adu2k000a0psjgcb81dbw" data-title="cryptography (4) digital signature" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/cryptography-03-elliptic-curve" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/17/cryptography/cryptography-03-elliptic-curve/" class="article-date">
  <time class="dt-published" datetime="2023-06-17T06:29:26.000Z" itemprop="datePublished">2023-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/17/cryptography/cryptography-03-elliptic-curve/">cryptography (3) elliptic curve</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>


<h2 id="elliptic-curve-definition"><a href="#elliptic-curve-definition" class="headerlink" title="elliptic curve definition"></a>elliptic curve definition</h2><p>for cryptographic use, we need to conside the curve not over the real numbers but over a finite field. the most popular fields <code>GF(p)</code>, where all arithmetic is performed modulo a prime p.</p>
<hr>
<p>the elliptic curve over \( Z_{p}, p&gt;3 \), is the set of all pairs \( (x,y) \in Z_{p} \) which fulfill<br> \[ y^2 \equiv x^3 + a \cdot x + b \bmod p \]<br>together with an imaginary point of infinity \( \mathcal{O} \), where<br> \[ a,b \in Z_{p} \]<br> and the condition \( 4 \cdot a^3 + 27 \cdot b^2 \neq 0 \bmod p \)</p>
<hr>
<p>the definition of elliptic curve requires that the curve is nonsingular. Geometrically speaking, this means that the plot has no self-intersections or vertices, which is achieved if the discriminant of the curve \( -16(4a^3) + 27b^2 \) is nonzero.</p>
<h2 id="operations-on-elliptic-curve"><a href="#operations-on-elliptic-curve" class="headerlink" title="operations on elliptic curve"></a>operations on elliptic curve</h2><p><img src="/images/cryptography/elliptic_curve/point_addition.webp" alt="point addition"><br>let’s denote the group operation with the addition symbol <code>+</code>. “addition” means that given two points and their coordinates, say \( P &#x3D; (x_1, y_1) \) and \( Q &#x3D; (x_2, y_2) \), we have to compute the coordidnate of a third point \( R (x_3, y_3) \). the construction works as follows: draw a line through P and Q and obtain a third point of intersection between the elliptic curve and the line (-R). Mirror this third intersection point along the x-axis. this mirored point is, by definition, the point R. point doubling <code>(P+P = 2P)</code> is a tangent line through the point P, and the rest is same.<br>the fomulae for Point Addition (P+Q) and Point Doubling (2P) is as below </p>
<hr>
<p> \[ x_3 &#x3D; s^2 - x_1 -x_2 \bmod p \]<br> \[ y_3 &#x3D; s(x_1 - x_3) - y_1 \bmod p\]<br> where<br>\begin{equation}<br>s &#x3D;<br>\begin{cases}<br>\frac{y_2-y_1}{x_2-x_1} \bmod p &amp; if P \neq Q (\text{point addition}) \cr<br>\frac{3x_{1}^{2} + a}{2y_1} \bmod p  &amp; if P &#x3D;Q (\text{point doubling})<br>\end{cases}<br>\end{equation}</p>
<hr>
<p>note that the parameter s is the slope of the line through P and Q in the case of point addition, or the slope of the tangent through P in the case of point doubling.<br>Furthmore, we define an abstract point at infinity as the neutral element \( \mathcal{O} \).<br>\[ P + \mathcal{O} &#x3D; P\]<br>according the group definition, we can now also define the inverse <code>-P</code> of any group element P as<br>\[ P + (-P) &#x3D; \mathcal{O}\]<br>Therefore, the inverse of \( P &#x3D; (x_p, y_p) \) is just \( P &#x3D; (x_p, -y_p)\). since  \( -y_p \equiv p - y_p\), hence<br>\[ -P &#x3D; (x_p, p-y_p) \]</p>
<h2 id="DLP-discrete-log-problem-with-Elliptic-curve"><a href="#DLP-discrete-log-problem-with-Elliptic-curve" class="headerlink" title="DLP(discrete log problem) with Elliptic curve"></a>DLP(discrete log problem) with Elliptic curve</h2><p>to set up DL cryptosystems it is important to know the order of the group.<br>Hasse’s theorem</p>
<hr>
<p>given an elliptic curve E modulo p, the number of points on the curve is denoted by #E and is bounded by:<br>\[ p+1-2\sqrt{p} \leq \#E \leq p+1+2\sqrt{p} \]</p>
<hr>
<p>Elliptic Curved Discrete Logarithm Problem (ECDLP)</p>
<hr>
<p>Given an elliptic curve E. We consider a primitive elemnt P and another element T. The DL problem is finding the integer d, where \( 1 \leq d \leq \#E \), such that:<br>\[ P + P + ….+ P &#x3D; dP &#x3D; T \]</p>
<hr>
<p>In cryptosystems, d is the private key which is an integer, while the public key T is a point on the curve with coordinates \( T &#x3D; (x_T, y_T)\)<br>Usually a <strong>square-and-multiply</strong> algorithm is used to calculate point multiplication (the algorithm detail is not coverred in this post). </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/06/17/cryptography/cryptography-03-elliptic-curve/" data-id="clk5adu2i00070psj86ukabp9" data-title="cryptography (3) elliptic curve" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/cryptography-02-rsa" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/10/cryptography/cryptography-02-rsa/" class="article-date">
  <time class="dt-published" datetime="2023-06-10T06:29:26.000Z" itemprop="datePublished">2023-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/10/cryptography/cryptography-02-rsa/">cryptography (2) RSA cryptosystem</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>


<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>the security of RSA relies on the difficulty of factoring a product of two large primes(the integer factorization problem). it is firstly presented in 1978 in [1].</p>
<h2 id="Euclidean-Algorithm"><a href="#Euclidean-Algorithm" class="headerlink" title="Euclidean Algorithm"></a>Euclidean Algorithm</h2><p>the gcd of two positive integers \(r_0\) and \(r_1\) is denoted by<br>\[gcd(r_0, r_1)\]<br>the Eucliedean algorithm is used to calculate gcd, based on as simple observation that<br>\[gcd(r_0, r_1) &#x3D; gcd(r_0-r_1, r_1)\]<br>where we assume \(r_0 &gt; r_1\)<br>This property can easily be proven: Let \(gcd(r_0, r_1) &#x3D; g\), since \(g\) divides both  \(r_0\) and \(r_1\), we can write \(r_0 &#x3D; g \cdot x\) and \(r_1 &#x3D; g \cdot y\), where \(x&gt;y\) and \(x\) and \(y\) are coprime integers, i.e., they do not have common factors. Moreover, it is easy to show that \((x-y)\) and \(y\) are also coprime. it follows from here that<br>\[gcd(r_0 - r_1, r_1) &#x3D; gcd(g \cdot (x-y), g\cdot y) &#x3D; g\]</p>
<p>it also follow immediately that we can apply the process iteratively:<br>\[gcd(r_0 - r_1, r_1) &#x3D; gcd(r_0 - mr_1, r_1) \]<br>as long as \((r_0 - mr_1) &gt;0\). the algorithm use the fewest number of steps if we choose maximum value of \(m\). this is the case if we compute:<br>\[gcd(r_0, r_1) &#x3D; gcd( r_1, r_0 \bmod r_1) \]<br>this process can be applied recursively until we obtain finally \[gcd(r_l, 0) &#x3D; r_l \]<br>the euclidean algorithm is very efficient, even with the very long numbers. the number of iterations is close to the number of digits of the input operands. that means, for instance, that the number of iterations of a gcd involving 1024-bit nubmers is 1024 times a constant.</p>
<h2 id="Extended-Euclidean-Algorithm"><a href="#Extended-Euclidean-Algorithm" class="headerlink" title="Extended Euclidean Algorithm"></a>Extended Euclidean Algorithm</h2><p>an extension of the Euclidean algorithm allows us to compute <em><strong>modular inverse</strong></em>. in addition to computing the gcd, the <em><strong>extended Euclidean algorithm</strong></em> computes a linear combination of the form<br>\[gcd(r_0, r_1) &#x3D; s \cdot r_0 + t\cdot r_1 \]<br>where s and t are integer coefficients. this equation is ofthen referred to as <em><strong>Diophantine equation</strong></em></p>
<p>the detail of the algorithm can be foud in section 6.3.2 of the book understanding cryptography by Christof Paar. Here presents the general idea by using an example.<br>let \(r_0 &#x3D;973 , r_1 &#x3D; 301\). during the steps of Euclidean Algorithm, we obtain \(973 &#x3D; 3\cdot301 + 70\)<br>which is \[r_0 &#x3D; q_1 \cdot r_1 + r_2\]<br>rearrange:<br>\[r_2 &#x3D;  r_0 + (-q_1) \cdot r_1\]<br>replacing (r_0, r_1) and iteratively by (r_1, r_2), … (r_{i-1}, r_{i}), util \(r_{i+1} &#x3D; 0\)<br>then \(r_{i}\) is \(gcd(r_0,r_1)\), and can have a representation of<br>\[gcd(r_0, r_1) &#x3D; s\cdot r_0 + t\cdot r_1 \].<br>since the inverse only exists if \(gcd(r_0, r_1)&#x3D;1\). we obtain<br>\[ s\cdot r_0 + t\cdot r_1 &#x3D; 1\]<br>taking this equation modulo \(r_0\) we obtain<br>\[ s\cdot 0 + t\cdot r_1 \equiv 1 \bmod r_0\]<br>\[  t\cdot r_1 \equiv 1 \bmod r_0\]<br>t is the definition of the inverse of \(r_1\)</p>
<p>Thus, if we need to compute an inverse \(a^{-1} \bmod m\), we apply EEA with the input parameters \(m\) and \(a\)</p>
<h2 id="Euler’s-Phi-Function"><a href="#Euler’s-Phi-Function" class="headerlink" title="Euler’s Phi Function"></a>Euler’s Phi Function</h2><p>we consider the ring \( Z_m\) i.e., the set of integers \({0,1,…,m-1}\). we are interested in teh problem of knowing how many numbers in this set are relatively prime to m. this quantity is given by Euler’s phi function, which is \(\Phi(m)\)</p>
<hr>
<p>let m have the following canonical factorization<br>\[ m &#x3D; p_{1}^{e_1} \cdot p_{2}^{e_2} \cdot … \cdot p_{n}^{e_n}\]<br>where the \(p_i\) are distinct prime numbers and \( e_i\) are positive integers, then</p>
<p>\[ \Phi(m) &#x3D; \prod_{i&#x3D;1}^{n}(p_{i}^{e_i} - p_{i}^{e_i -1} ) \]</p>
<hr>
<p>it is important to stress that we need to know the factoorization of m in order to calculate Euler’s phi function.</p>
<h2 id="Fermat’s-little-theorem"><a href="#Fermat’s-little-theorem" class="headerlink" title="Fermat’s little theorem"></a>Fermat’s little theorem</h2><p>Fermat’s little theorem states that if p is a prime number, then for any integer a, the number<br>\(a^{p}-a \) is an integer multiple of p. In the notation of modular arithmetic, this is expressed as<br>\[ a^{p} \equiv a \bmod p\]<br>the theorem can be stated in the form also,<br>\[ a^{p-1} \equiv 1 \bmod p\]<br>then the inverse of an integer is,<br>\[ a^{-1} \equiv a^{p-2} \bmod p\]<br>performing the above formulate (involving exponentiation) to find inverse is usually slower than using extended Euclidean algorithm. However, there are situations where it is advantageous to use Fermat’s Little Theorem,  e.g., on smart cards or other devices which have a hardware accelerator for fast exponentiation anyway.</p>
<p>a generatlization of Fermat’s little Theorem to any integer moduli, i.e., moduli that are not necessarily primes, is Euler’s theorem.</p>
<hr>
<p><strong>Euler’s Theorem</strong><br>let \(a\) and \(m\) be integers with \(gcd(a,m) &#x3D; 1\), then<br>\[ a^{\Phi(m)} \equiv 1 \bmod m\]</p>
<hr>
<p>since it works modulo m, it is applicable to integer rings \(Z_{m}\)</p>
<h2 id="key-generation"><a href="#key-generation" class="headerlink" title="key generation"></a>key generation</h2><hr>
<p><strong>Output</strong>: public key: \( k_{pub} &#x3D; (n,e) and private key: k_{pr} &#x3D; (d) \)</p>
<ol>
<li>choose two large primes p and q.</li>
<li>compute \(n &#x3D; p\cdot q\)</li>
<li>compute \( \Phi(n) &#x3D; (p-1)(q-1)\)</li>
<li>select the public exponent \( e \in {1,2,…,\Phi(n)-1} \) such that<br>\[ gcd(e,\Phi(n)) &#x3D; 1\]</li>
<li>compute the private key d such that<br>\[ d \cdot e \equiv 1 \bmod \Phi(n)\]</li>
</ol>
<hr>
<p>the condition that \( gcd(e,\Phi(n)) &#x3D; 1\) ensures that the inverse of \(e\) exists modulo \(\Phi(n)\), so that there is always a private key \(d\).<br>the computation of key keys \(d\) and \(e\) canb e doen at once using the extended Euclidean algorith. </p>
<h2 id="Encryption-and-Decryption"><a href="#Encryption-and-Decryption" class="headerlink" title="Encryption and Decryption"></a>Encryption and Decryption</h2><hr>
<p><strong>RSA Encryption</strong> Given the privaate key \( k_{pub} &#x3D; (n,e) \) and the plaintext \(x\), the encryption is:<br>\[ y &#x3D; e_{k_{pub}}(x) \equiv x^{e} \bmod n\]<br>where \(x,y \in Z_{n}\)</p>
<hr>
<hr>
<p><strong>RSA Decryption</strong> Given the public key \d &#x3D; k_{pr} \) and the plaintext \(y\), the decryption is:<br>\[ x &#x3D; d_{k_{pr}}(y) \equiv y^{d} \bmod n\]<br>where \(x,y \in Z_{n}\)</p>
<hr>
<h2 id="Digital-signature"><a href="#Digital-signature" class="headerlink" title="Digital signature"></a>Digital signature</h2><p>the message \(x\) that is being signed is in the range \(1,2,…,n-1\)<br><img src="/images/cryptography/rsa/rsa_signature.png" alt="rsa digital signature"></p>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul>
<li>[1] <a target="_blank" rel="noopener" href="https://web.williams.edu/Mathematics/lg5/302/RSA.pdf">A Method for Obtaining Digital<br>Signatures and Public-Key Cryptosystems</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/06/10/cryptography/cryptography-02-rsa/" data-id="clk5adu2h00040psjhtih0cd9" data-title="cryptography (2) RSA cryptosystem" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rust/rust_std/rust-std-sync" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/08/rust/rust_std/rust-std-sync/" class="article-date">
  <time class="dt-published" datetime="2023-06-08T14:04:38.000Z" itemprop="datePublished">2023-06-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/08/rust/rust_std/rust-std-sync/">rust std sync</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="lock-free-amp-wait-free"><a href="#lock-free-amp-wait-free" class="headerlink" title="lock free &amp; wait free"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Non-blocking_algorithm">lock free &amp; wait free</a></h2><p>“Lock-free” and “wait-free” are two different approaches to designing concurrent algorithms and data structures. Both aim to provide efficient and non-blocking synchronization in concurrent environments.</p>
<ul>
<li><strong>lock-free</strong> A lock-free algorithm or data structure guarantees progress for at least one thread, regardless of the behavior or state of other threads. In a lock-free design, threads can independently perform their operations without being blocked by other threads. If one thread gets delayed or suspended, other threads can continue to make progress. Lock-free algorithms typically use low-level synchronization primitives such as atomic operations to ensure progress and prevent data races.</li>
<li><strong>wait-free</strong> A wait-free algorithm or data structure guarantees progress for every thread, regardless of the behavior or state of other threads. In a wait-free design, every thread executing an operation completes its operation within a finite number of steps, without being delayed by other threads. Wait-free algorithms are more stringent in their requirements compared to lock-free algorithms and often require more complex synchronization mechanisms.</li>
</ul>
<p>It’s important to note that both lock-free and wait-free designs aim to avoid traditional locks or blocking synchronization mechanisms (such as mutexes or condition variables) that can lead to contention and thread blocking. Instead, they rely on techniques like atomic operations, compare-and-swap (CAS), or memory fences to ensure progress and prevent data races in concurrent execution.</p>
<h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/sync/atomic/index.html">atomic</a></h2><p>Rust atomics currently follow the same rules as <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic">C++20 atomics</a>, specifically <code>atomic_ref</code>. Basically, creating a shared reference to one of the Rust atomic types corresponds to creating an <code>atomic_ref</code> in C++; the atomic_ref is destroyed when the lifetime of the shared reference ends.<br>Each method takes an <code>Ordering</code> which represents the strength of the memory barrier for that operation. These orderings are the same as the <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order">C++20 atomic orderings</a>. For more information see the <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/nomicon/atomics.html">nomicon</a><br>Atomic variables are safe to share between threads (they implement Sync) but they do not themselves provide the mechanism for sharing and follow the threading model of Rust. The most common way to share an atomic variable is to put it into an Arc (an atomically-reference-counted shared pointer).</p>
<h3 id="Compiler-Reordering"><a href="#Compiler-Reordering" class="headerlink" title="Compiler Reordering"></a>Compiler Reordering</h3><p>Compilers may change the actual order of events, or make events never occur! If we write something like</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">3</span>;</span><br><span class="line">x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>The compiler may conclude that it would be best if your program did:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">2</span>;</span><br><span class="line">y = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>This has inverted the order of events and completely eliminated one event. But if our program is multi-threaded, we may have been relying on x to actually be assigned to 1 before y was assigned. </p>
<h3 id="Hardware-Reordering"><a href="#Hardware-Reordering" class="headerlink" title="Hardware Reordering"></a>Hardware Reordering</h3><p>here is indeed a global shared memory space somewhere in your hardware, but from the perspective of each CPU core it is so very far away and so very slow. Each CPU would rather work with its local cache of the data and only go through all the anguish of talking to shared memory only when it doesn’t actually have that memory in cache. The end result is that the hardware doesn’t guarantee that events that occur in some order on one thread, occur in the same order on another thread. To guarantee this, we must issue special instructions to the CPU telling it to be a bit less smart.<br>For instance, say we convince the compiler to emit this logic:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">initial state: x = 0, y = 1</span><br><span class="line"></span><br><span class="line">THREAD 1        THREAD2</span><br><span class="line">y = 3;          if x == 1 &#123;</span><br><span class="line">x = 1;              y *= 2;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>Ideally this program has 2 possible final states:</p>
<ul>
<li>y &#x3D; 3: (thread 2 did the check before thread 1 completed)</li>
<li>y &#x3D; 6: (thread 2 did the check after thread 1 completed)<br>However there’s a third potential state that the hardware enables:</li>
<li>y &#x3D; 2: (thread 2 saw x &#x3D; 1, but not y &#x3D; 3, and then overwrote y &#x3D; 3)<br>It’s worth noting that different kinds of CPU provide different guarantees. It is common to separate hardware into two categories: strongly-ordered and weakly-ordered. Most notably x86&#x2F;64 provides strong ordering guarantees, while ARM provides weak ordering guarantees.</li>
</ul>
<h3 id="Data-Accesses"><a href="#Data-Accesses" class="headerlink" title="Data Accesses"></a>Data Accesses</h3><p>Atomic accesses are how we tell the hardware and compiler that our program is multi-threaded. Each atomic access can be marked with an ordering that specifies what kind of relationship it establishes with other accesses.  For the compiler, this largely revolves around re-ordering of instructions. For the hardware, this largely revolves around how writes are propagated to other threads. The set of orderings Rust exposes are:</p>
<ul>
<li>Sequentially Consistent (SeqCst)</li>
<li>Release</li>
<li>Acquire</li>
<li>Relaxed</li>
</ul>
<h3 id="Sequentially-Consistent"><a href="#Sequentially-Consistent" class="headerlink" title="Sequentially Consistent"></a>Sequentially Consistent</h3><p>Sequentially Consistent is the most powerful of all, implying the restrictions of all other orderings. Intuitively, a sequentially consistent operation cannot be reordered: all accesses on one thread that happen before and after a SeqCst access stay before and after it.</p>
<h3 id="Acquire-Release"><a href="#Acquire-Release" class="headerlink" title="Acquire-Release"></a>Acquire-Release</h3><p>Acquire and Release are largely intended to be paired. they’re perfectly suited for acquiring and releasing locks.<br>Intuitively, an acquire access ensures that every access after it stays after it. However operations that occur before an acquire are free to be reordered to occur after it. Similarly, a release access ensures that every access before it stays before it. However operations that occur after a release are free to be reordered to occur before it.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicBool, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>)); <span class="comment">// value answers &quot;am I locked?&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... distribute lock to threads somehow ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to acquire the lock by setting it to true</span></span><br><span class="line">    <span class="keyword">while</span> lock.<span class="title function_ invoke__">compare_and_swap</span>(<span class="literal">false</span>, <span class="literal">true</span>, Ordering::Acquire) &#123; &#125;</span><br><span class="line">    <span class="comment">// broke out of the loop, so we successfully acquired the lock!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... scary data accesses ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ok we&#x27;re done, release the lock</span></span><br><span class="line">    lock.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Relaxed"><a href="#Relaxed" class="headerlink" title="Relaxed"></a>Relaxed</h3><p>Relaxed accesses are the absolute weakest. They can be freely re-ordered and provide no happens-before relationship. Still, relaxed operations are still atomic. That is, they don’t count as data accesses and any read-modify-write operations done to them occur atomically. For instance, incrementing a counter can be safely done by multiple threads using a relaxed <code>fetch_add</code> if you’re not using the counter to synchronize any other accesses.</p>
<h2 id="an-example-spinlock"><a href="#an-example-spinlock" class="headerlink" title="an example (spinlock)"></a>an example (spinlock)</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::&#123;hint, thread&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spinlock</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spinlock_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;spinlock);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span>|| &#123;</span><br><span class="line">        spinlock_clone.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Ordering::SeqCst);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the other thread to release the lock</span></span><br><span class="line">    <span class="keyword">while</span> spinlock.<span class="title function_ invoke__">load</span>(Ordering::SeqCst) != <span class="number">0</span> &#123;</span><br><span class="line">        hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(panic) = thread.<span class="title function_ invoke__">join</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Thread had an error: &#123;panic:?&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="usual-structs"><a href="#usual-structs" class="headerlink" title="usual structs"></a>usual structs</h2><ol>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicBool.html">AtomicBool</a></li>
</ol>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul>
<li><code>fn get_mut(&amp;mut self) -&gt; &amp;mut bool</code></li>
<li><code>fn into_inner(self) -&gt; bool</code></li>
<li><code>fn load(&amp;self, order: Ordering) -&gt; bool</code></li>
<li><code>fn store(&amp;self, val: bool, order: Ordering)</code></li>
<li><code>fn compare_exchange(&amp;self, current: bool,new: bool,success: Ordering,failure: Ordering) -&gt; Result&lt;bool, bool&gt;</code><br>Stores a value into the bool if the current value is the same as the current value.<br>compare_exchange takes two Ordering arguments to describe the memory ordering of this operation. success describes the required ordering for the read-modify-write operation that takes place if the comparison with current succeeds. failure describes the required ordering for the load operation that takes place when the comparison fails. </li>
<li><code>fn fetch_and(&amp;self, val: bool, order: Ordering) -&gt; bool</code><br>Logical “and” with a boolean value.<br>Performs a logical “and” operation on the current value and the argument val, and sets the new value to the result.</li>
<li><code>const fn as_ptr(&amp;self) -&gt; *mut bool</code><br>Returns a mutable pointer to the underlying bool.<br>Doing non-atomic reads and writes on the resulting integer can be a data race. This method is mostly useful for FFI, where the function signature may use *mut bool instead of &amp;AtomicBool.</li>
</ul>
<ol start="2">
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicUsize.html">AtomicUsize</a></li>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicPtr.html">AtomicPtr</a><br>A raw pointer type which can be safely shared between threads.<br>This type has the same in-memory representation as a *mut T</li>
</ol>
<h2 id="Higher-level-synchronization-objects"><a href="#Higher-level-synchronization-objects" class="headerlink" title="Higher-level synchronization objects"></a>Higher-level synchronization objects</h2><p>Most of the low-level synchronization primitives are quite error-prone and inconvenient to use, which is why the standard library also exposes some higher-level synchronization objects.</p>
<ul>
<li><strong>Arc</strong>: Atomically Reference-Counted pointer, which can be used in multithreaded environments to prolong the lifetime of some data until all the threads have finished using it.</li>
<li><strong>Barrier</strong>: Ensures multiple threads will wait for each other to reach a point in the program, before continuing execution all together.</li>
<li><strong>Condvar</strong>: Condition Variable, providing the ability to block a thread while waiting for an event to occur.</li>
<li><strong>mpsc</strong>: Multi-producer, single-consumer queues, used for message-based communication. Can provide a lightweight inter-thread synchronisation mechanism, at the cost of some extra memory.</li>
<li><strong>Mutex</strong>: Mutual Exclusion mechanism, which ensures that at most one thread at a time is able to access some data.</li>
<li><strong>Once</strong>: Used for a thread-safe, one-time global initialization routine</li>
<li><strong>OnceLock</strong>: Used for thread-safe, one-time initialization of a global variable.</li>
<li><strong>RwLock</strong>: Provides a mutual exclusion mechanism which allows multiple readers at the same time, while allowing only one writer at a time. In some cases, this can be more efficient than a mutex.</li>
</ul>
<h2 id="mpsc"><a href="#mpsc" class="headerlink" title="mpsc"></a>mpsc</h2><p>This module provides message-based communication over channels, concretely defined among three types:</p>
<ul>
<li>Sender</li>
<li>SyncSender</li>
<li>Receiver</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/06/08/rust/rust_std/rust-std-sync/" data-id="clk5adu2u001u0psj0a698v1u" data-title="rust std sync" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust-std/" rel="tag">rust-std</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rust/rust_std/rust-smart-pointer-and-internal-mutibility" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/03/rust/rust_std/rust-smart-pointer-and-internal-mutibility/" class="article-date">
  <time class="dt-published" datetime="2023-06-03T14:04:38.000Z" itemprop="datePublished">2023-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/03/rust/rust_std/rust-smart-pointer-and-internal-mutibility/">rust std smart pointer &amp; interior mutability</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="smart-pointer"><a href="#smart-pointer" class="headerlink" title="smart pointer"></a>smart pointer</h1><h2 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/rc/struct.Rc.html">Rc</a></h2><p>A single-threaded reference-counting pointer. The inherent methods of Rc are all associated functions, which means that you have to call them as e.g., Rc::get_mut(&amp;mut value) instead of value.get_mut(). This avoids conflicts with methods of the inner type T.</p>
<h1 id="internal-mutibility"><a href="#internal-mutibility" class="headerlink" title="internal mutibility"></a>internal mutibility</h1><h2 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html">Cell</a></h2><p><code>Cell&lt;T&gt;</code> enables mutation inside an immutable value. In other words, it enables <code>interior mutability</code>. It never gives out mutable pointer to the inner value; A Cell can be shared by multiple references.</p>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul>
<li><code>fn get(&amp;self) -&gt; T</code></li>
<li><code>fn set(&amp;self, val: T)</code></li>
<li><code>fn swap(&amp;self, other: &amp;Cell&lt;T&gt;)</code></li>
<li><code>fn replace(&amp;self, val: T) -&gt; T</code><br>Replaces the contained value with val, and returns the old contained value</li>
<li><code>fn into_inner(self) -&gt; T</code></li>
<li><code>const fn as_ptr(&amp;self) -&gt; *mut T</code></li>
<li><code>fn get_mut(&amp;mut self) -&gt; &amp;mut T</code></li>
<li><code>fn from_mut(t: &amp;mut T) -&gt; &amp;Cell&lt;T&gt;</code></li>
</ul>
<h3 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Cell</span>&lt;T&gt;  <span class="comment">// cannot be used in other threads</span></span><br></pre></td></tr></table></figure>

<h2 id="OnceCell"><a href="#OnceCell" class="headerlink" title="OnceCell"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/cell/struct.OnceCell.html">OnceCell</a></h2><p>A cell which can be written to only once.</p>
<h3 id="special-methods"><a href="#special-methods" class="headerlink" title="special methods"></a>special methods</h3><ul>
<li><code>fn get_or_init&lt;F&gt;(&amp;self, f: F) -&gt; &amp;T</code></li>
</ul>
<h2 id="LazyCell"><a href="#LazyCell" class="headerlink" title="LazyCell"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/cell/struct.LazyCell.html">LazyCell</a></h2><p>A value which is initialized on the first access</p>
<h2 id="UnsafeCell"><a href="#UnsafeCell" class="headerlink" title="UnsafeCell"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html#">UnsafeCell</a></h2><p><code>UnsafeCell&lt;T&gt;</code> opts-out of the immutability guarantee for <code>&amp;T</code>: a shared reference <code>&amp;UnsafeCell&lt;T&gt;</code> may point to data that is being mutated. This is called <code>interior mutability</code>.<br>All other types that allow internal mutability, such as <code>Cell&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>, internally use <code>UnsafeCell</code> to wrap their data.<br>Note that only the immutability guarantee for shared references is affected by <code>UnsafeCell</code>. The uniqueness guarantee for mutable references is unaffected (only one mutable reference at one time, or multiple immutable reference). </p>
<h3 id="methods-1"><a href="#methods-1" class="headerlink" title="methods"></a>methods</h3><ul>
<li><code>pub const fn get(&amp;self) -&gt; *mut T</code><br>Gets a mutable pointer to the wrapped value.</li>
<li><code>pub fn get_mut(&amp;mut self) -&gt; &amp;mut T</code><br>Returns a mutable reference to the underlying data</li>
<li><code>pub const fn raw_get(this: *const UnsafeCell&lt;T&gt;) -&gt; *mut T</code><br>Gets a mutable pointer to the wrapped value. The difference from get is that this function accepts a raw pointer, which is useful to avoid the creation of temporary references. e.g. Gradual initialization of an UnsafeCell requires raw_get, as calling get would require creating a reference to uninitialized data:<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::UnsafeCell;</span><br><span class="line"><span class="keyword">use</span> std::mem::MaybeUninit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">m</span> = MaybeUninit::&lt;UnsafeCell&lt;<span class="type">i32</span>&gt;&gt;::<span class="title function_ invoke__">uninit</span>();</span><br><span class="line"><span class="keyword">unsafe</span> &#123; UnsafeCell::<span class="title function_ invoke__">raw_get</span>(m.<span class="title function_ invoke__">as_ptr</span>()).<span class="title function_ invoke__">write</span>(<span class="number">5</span>); &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">uc</span> = <span class="keyword">unsafe</span> &#123; m.<span class="title function_ invoke__">assume_init</span>() &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(uc.<span class="title function_ invoke__">into_inner</span>(), <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li>
<li><code>fn into_inner(self) -&gt; T</code><br>Unwraps the value, consuming the cell.</li>
</ul>
<h2 id="SyncUnsafeCell"><a href="#SyncUnsafeCell" class="headerlink" title="SyncUnsafeCell"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/cell/struct.SyncUnsafeCell.html">SyncUnsafeCell</a></h2><p>This is just an <code>UnsafeCell</code>, except it implements <code>Sync</code> if T implements Sync.</p>
<h2 id="std-cell-RefCell"><a href="#std-cell-RefCell" class="headerlink" title="std::cell::RefCell"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html">std::cell::RefCell</a></h2><p>A mutable memory location with <strong>dynamically</strong> checked borrow rules</p>
<ul>
<li><code>fn borrow(&amp;self) -&gt; Ref&lt;&#39;_, T&gt;</code></li>
<li><code>fn borrow_mut(&amp;self) -&gt; RefMut&lt;&#39;_, T&gt;</code></li>
<li><code>fn as_ptr(&amp;self) -&gt; *mut T</code></li>
</ul>
<h1 id="borrow"><a href="#borrow" class="headerlink" title="borrow"></a>borrow</h1><h2 id="std-borrow-Cow"><a href="#std-borrow-Cow" class="headerlink" title="std::borrow::Cow"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/borrow/enum.Cow.html">std::borrow::Cow</a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/06/03/rust/rust_std/rust-smart-pointer-and-internal-mutibility/" data-id="clk5adu2t001p0psj3xqq1frq" data-title="rust std smart pointer &amp; interior mutability" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust-std/" rel="tag">rust-std</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cryptography/cryptography-01-primitive-group-and-field" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/03/cryptography/cryptography-01-primitive-group-and-field/" class="article-date">
  <time class="dt-published" datetime="2023-06-03T06:29:26.000Z" itemprop="datePublished">2023-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/03/cryptography/cryptography-01-primitive-group-and-field/">cryptography (1) group &amp; field</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>



<h2 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h2><p>a group is a set of elements \( G \) together with an operation \( \circ \). a group has the following properties</p>
<ol>
<li>the group operation \( \circ \) is closed. that is, for all \( a,b, \in G  \), it holds that \( a \circ b &#x3D; c \in G \)</li>
<li>the group operation is associative. That is, \( a \circ (b \circ c) &#x3D; (a \circ b) \circ c \) for all \( a,b,c \in G \)</li>
<li>there is an element \( 1 \in G \), called the neutral element (or identity element), such that \( a \circ \ &#x3D; 1 \circ a\) for all \( a \in G \)</li>
<li>For each \( a \in G \) there exists an element \( a^{-1} \in G\), called the inverse of a, such that \( a \circ a^{-1} &#x3D; 1 \).</li>
<li>a group G is abelian (or commutative) if, furthermore, \( a \circ b &#x3D; b \circ a \) for all \( a, b \in G \)</li>
</ol>
<h3 id="Example-of-Group"><a href="#Example-of-Group" class="headerlink" title="Example of Group"></a>Example of Group</h3><p>the set of integers \( Z_{m} &#x3D; 0,1,…,m-1 \) and the operation addition modulo \( m \) forma group with the neutral element 0. every element \( a \) has an inverse \(  -a \). note that this set does not form a group with the operation multiplication gecause mose eleents \(  a \) do not have an inverse such that \(  a a^{-1} &#x3D; 1 \bmod m\).</p>
<p>In order to have all four basic arithmetic operations (i.e. addition, subtraction, multiplication, division) in one structure, we need a set which contains an additive and a multiplicative group. this is what we call a field.</p>
<h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><p>A field is a set of elements with the following properties</p>
<ul>
<li>all elements of \( F\) form an additive group with the group operation \( + \) and the neutral element \( 0 \)</li>
<li>all element of \( F \) except \( 0 \) form a multiplicative group with the gorup operation \( x \) and the neutral element \( 1 \) .</li>
<li>when the two group operations are mixed, the distributivety law holds, i.e., for all \( a,b,c \in F: a(b+c) &#x3D; (ab) + (ac) \)</li>
</ul>
<h3 id="Example-of-Field"><a href="#Example-of-Field" class="headerlink" title="Example of Field"></a>Example of Field</h3><p>the set \( R \) of real numbers is a field with the neutral element 0 for the additive group and the neutral element 1 for the multiplicative group. every real number \( a \) has an additive inverse, namely \( -a \), and every nonzero element \( a \) has a multiplicative inverse \( 1 \div a \)</p>
<h2 id="Galois-Field"><a href="#Galois-Field" class="headerlink" title="Galois Field"></a>Galois Field</h2><p>In cryptography, we are almose always interested in fields with a <strong>finite</strong> number of elements, which we call finite fields or <code>Galois field</code>. the number of elements in the field is called the <code>order</code> or <code>cardinality</code> of the field. Of fundamental importance is the following theorem</p>
<hr>
<p>a field with order <code>m</code> only exists if <code>m</code> is a prime power, i.e, \( m &#x3D; p^{n} \), for some positive integer <code>n</code> and prime integer <code>p</code>. <code>p</code> is called the characteristic of the finite field</p>
<hr>
<p>the theorem implies that there are, for instance, finite fields with 11 elements (\( 11^{1} \)), or with 81 elements \( 81 &#x3D; 3^{4} \) or with 256 elements (\( 256 &#x3D; 2^{8} \)). </p>
<h2 id="Prime-Field"><a href="#Prime-Field" class="headerlink" title="Prime Field"></a>Prime Field</h2><p>the most intuitive examples of finite fields are fields of prime order, i.e., fields with \( n &#x3D;1 \). elements of the field \( GF(p) \) can be represented by integers \( 0,1,…, p-1 \).</p>
<h2 id="Extension-Field-GF-2-m"><a href="#Extension-Field-GF-2-m" class="headerlink" title="Extension Field GF(2^m)"></a>Extension Field <code>GF(2^m)</code></h2><p>In AES the finite field contains 256 elements and is denoted as \( GF(2^8) \).<br>However, if the order  of a finite field is not prime, and \( 2^8 \) is clearly not a prime, the addition and multiplication operation cannot be represented by addition and multiplication of integers modulo \( 2^8 \). such fields with \( m &gt;1 \) are called <code>extension field</code>. in order to deal with extension fields we need (1) a different notation for field elements and (2) different rules for performing arithmetic with the elements. elements of extension fields can be represented as <code>polynomials</code>, and computation in the extension field is achieved by performing a certain type of <code>polynomial arithmetic</code>.</p>
<p>In the field \( GF(2^8) \), which is used in AES, each element \( A \in GF(2^8) \) is thus represented as:<br>\[ A(x) &#x3D; a_{7}x^7 + …+a_{1}x+a_{0}, a_{i} \in GF(2) &#x3D; {0,1} \]<br>It is also important to observe that every polynomial can simply be stored in digital form as an 8-bit vector<br>\[ A &#x3D; (a_7,a_6,a_5,a_4,a_3,a_2,a_1,a_0) \]</p>
<h3 id="addition-and-subtraction-in-GF-2-m"><a href="#addition-and-subtraction-in-GF-2-m" class="headerlink" title="addition and subtraction in GF(2^m)"></a>addition and subtraction in <code>GF(2^m)</code></h3><p>addition and subtraction are simply achieved by performing polynomial addition and subtraction. note that we perform modulo 2 addition (or subtraction) with the coefficients.<br>\[ A(x) &#x3D; x^7 + x^6 + x^4 + 1 \]<br>\[ B(x) &#x3D; x^4 + x^2+ 1 \]<br>\[ A(x) + B(x) &#x3D; x^7 + x^6+ x^2 \]</p>
<h3 id="multiplication-in-GF-2-m"><a href="#multiplication-in-GF-2-m" class="headerlink" title="multiplication in GF(2^m)"></a>multiplication in <code>GF(2^m)</code></h3><p>firstly, two elements (represented by their polynomials) of a finite field <code>GF(2^m)</code> are multiplied usig the standard polynomial multiplication rule \[ A(x) \dot B(x) &#x3D; C(x) \]. In general, the product polynomial \[ C(x) \] will have a degree higher than <code>m-1</code> and has to be reduced. to do that, the product of the multiplication is divided by a certain polyhomial, and we consider only the remainder after the polynomial division. we need <strong>irreducible</strong> polynomials for the module reduction. irreducible polynomials are roughly comparable to prime numbers. their only factors are 1 and polynomial itself.<br>Thus, every field <code>GF(2^m)</code> requires an irreducible polynomial <code>P(x)</code> of degree <code>m</code>.<br>For AES, the irreducible polynomial is<br>\[ P(x) &#x3D; x^8 + x^4+ x^3 +x + 1 \]<br>the main algorithm for computing multiplicative inverse is the extended Euclidean algorithm, which is introduced in other posts.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/06/03/cryptography/cryptography-01-primitive-group-and-field/" data-id="clk5adu2m000j0psjcucog3rw" data-title="cryptography (1) group &amp; field" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rust/rust-10-concurrency" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/01/rust/rust-10-concurrency/" class="article-date">
  <time class="dt-published" datetime="2023-06-01T14:04:38.000Z" itemprop="datePublished">2023-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/01/rust/rust-10-concurrency/">rust concurrency</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Send-and-Sync"><a href="#Send-and-Sync" class="headerlink" title="Send and Sync"></a>Send and Sync</h2><ul>
<li>A type is Send if it is safe to send it to another thread.</li>
<li>A type is Sync if it is safe to share between threads (T is Sync if and only if &amp;T is Send).</li>
<li>raw pointers are neither Send nor Sync (because they have no safety guards).</li>
<li>UnsafeCell isn’t Sync (and therefore Cell and RefCell aren’t).</li>
<li>Rc isn’t Send or Sync (because the refcount is shared and unsynchronized).</li>
</ul>
<p>Types that aren’t automatically derived can simply implement them if desired:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>(*<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Send</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Sync</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>one can also unimplement Send and Sync:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(negative_impls)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I have some magic semantics for some synchronization primitive!</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SpecialThreadToken</span>(<span class="type">u8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> !<span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">SpecialThreadToken</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> !<span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">SpecialThreadToken</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/send-and-sync.html">rustonomicon</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/06/01/rust/rust-10-concurrency/" data-id="clk5adu2p000y0psjge4wewdm" data-title="rust concurrency" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust/" rel="tag">rust</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rust/rust_std/rust-std-data-structure-2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/02/rust/rust_std/rust-std-data-structure-2/" class="article-date">
  <time class="dt-published" datetime="2023-05-02T14:04:38.000Z" itemprop="datePublished">2023-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/02/rust/rust_std/rust-std-data-structure-2/">rust std data structure (2D)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><h3 id="BTreeMap"><a href="#BTreeMap" class="headerlink" title="BTreeMap"></a>BTreeMap</h3><ul>
<li><code>clear(&amp;mut self)</code> Clears the map, removing all elements.</li>
<li><code>get(&amp;self, key: &amp;Q)</code> Returns a reference to the value corresponding to the key.</li>
<li><code>get_key_value(&amp;self, k: &amp;Q)</code></li>
<li><code>first_key_value(&amp;self)</code> eturns the first key-value pair in the map.</li>
<li><code>first_entry(&amp;mut self)</code> Returns the first entry in the map for in-place manipulation</li>
<li><code>pop_first(&amp;mut self)</code> </li>
<li><code>last_key_value(&amp;self)</code></li>
<li><code>last_entry(&amp;mut self)</code></li>
<li><code>pop_last(&amp;mut self)</code></li>
<li><code>contains_key(&amp;self, key: &amp;Q)</code></li>
<li><code>get_mut(&amp;mut self, key: &amp;Q)</code> Returns a mutable reference to the value corresponding to the key</li>
<li><code>insert(&amp;mut self, key: K, value: V)</code></li>
<li><code>try_insert(&amp;mut self, key: K, value: V)</code> If the map already had this key present, nothing is updated, and an error containing the occupied entry and the value is returned.</li>
<li><code>remove(&amp;mut self, key: &amp;Q)</code></li>
<li><code>remove_entry(&amp;mut self, key: &amp;Q)</code></li>
<li><code>retain&lt;F&gt;(&amp;mut self, mut f: F)</code> Retains only the elements specified by the predicate.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: BTreeMap&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt; = (<span class="number">0</span>..<span class="number">8</span>).<span class="title function_ invoke__">map</span>(|x| (x, x*<span class="number">10</span>)).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="comment">// Keep only the elements with even-numbered keys.</span></span><br><span class="line">map.<span class="title function_ invoke__">retain</span>(|&amp;k, _| k % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">assert!</span>(map.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">eq</span>(<span class="built_in">vec!</span>[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">20</span>), (<span class="number">4</span>, <span class="number">40</span>), (<span class="number">6</span>, <span class="number">60</span>)]));</span><br></pre></td></tr></table></figure></li>
<li><code>append(&amp;mut self, other: &amp;mut Self)</code> Moves all elements from <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</li>
<li><code>range&lt;T: ?Sized, R&gt;(&amp;self, range: R) -&gt; Range&lt;&#39;_, K, V&gt;</code> Constructs a double-ended iterator over a sub-range of elements in the map.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"><span class="keyword">use</span> std::ops::Bound::Included;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = BTreeMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="number">3</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="number">5</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(<span class="number">8</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">for</span> (&amp;key, &amp;value) <span class="keyword">in</span> map.<span class="title function_ invoke__">range</span>((<span class="title function_ invoke__">Included</span>(&amp;<span class="number">4</span>), <span class="title function_ invoke__">Included</span>(&amp;<span class="number">8</span>))) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;key&#125;: &#123;value&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>((&amp;<span class="number">5</span>, &amp;<span class="string">&quot;b&quot;</span>)), map.<span class="title function_ invoke__">range</span>(<span class="number">4</span>..).<span class="title function_ invoke__">next</span>());</span><br></pre></td></tr></table></figure></li>
<li><code>range_mut&lt;T: ?Sized, R&gt;(&amp;mut self, range: R) -&gt; RangeMut&lt;&#39;_, K, V&gt;</code> </li>
<li><code>entry(&amp;mut self, key: K)</code> Gets the given key’s corresponding entry in the map for in-place manipulation.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span>: BTreeMap&lt;&amp;<span class="type">str</span>, <span class="type">usize</span>&gt; = BTreeMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="comment">// count the number of occurrences of letters in the vec</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>] &#123;</span><br><span class="line">    count.<span class="title function_ invoke__">entry</span>(x).<span class="title function_ invoke__">and_modify</span>(|curr| *curr += <span class="number">1</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(count[<span class="string">&quot;a&quot;</span>], <span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(count[<span class="string">&quot;b&quot;</span>], <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(count[<span class="string">&quot;c&quot;</span>], <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li><code>split_off&lt;Q: ?Sized + Ord&gt;(&amp;mut self, key: &amp;Q)</code> Splits the collection into two at the given key. Returns everything after the given key,</li>
<li><code>drain_filter&lt;F&gt;(&amp;mut self, pred: F)</code> Creates an iterator that visits all elements (key-value pairs) in ascending key order and uses a closure to determine if an element should be removed. If the closure returns <code>true</code>, the element is removed from the map and yielded. If the closure returns <code>false</code>, or panics, the element remains in the map and will not be yielded</li>
<li><code>into_keys(self)</code> Creates a consuming iterator visiting all the keys, in sorted order. The map cannot be used after calling this</li>
<li><code>into_values(self)</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/05/02/rust/rust_std/rust-std-data-structure-2/" data-id="clk5adu2v001w0psj15es4ohw" data-title="rust std data structure (2D)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust-std/" rel="tag">rust-std</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rust/rust_std/rust-std-data-structure-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/01/rust/rust_std/rust-std-data-structure-1/" class="article-date">
  <time class="dt-published" datetime="2023-05-01T14:04:38.000Z" itemprop="datePublished">2023-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/01/rust/rust_std/rust-std-data-structure-1/">rust std data structure (1D)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>A <strong>fixed-size</strong> array, denoted [T; N], for the element type, T, and the non-negative compile-time constant size, N.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">todo!()</span><br></pre></td></tr></table></figure>

<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>A <strong>dynamically-sized view</strong> into a contiguous sequence, [T].</p>
<ul>
<li><code>len()</code>: Returns the number of elements in the slice</li>
<li><code>is_empty()</code></li>
<li><code>first()</code> Returns the first element of the slice, or <code>None</code> if it is empty.</li>
<li><code>first_mut()</code> Returns a mutable <strong>pointer</strong> to the first element of the slice, or <code>None</code> if it is empty</li>
<li><code>split_first()</code> Returns the first and all the rest of the elements of the slice, or <code>None</code> if it is empty.</li>
<li><code>split_first_mut()</code> </li>
<li><code>split_last()</code></li>
<li><code>split_last_mut()</code></li>
<li><code>last()</code></li>
<li><code>last_mut()</code></li>
<li><code>get&lt;I&gt;(index: I)</code> Returns a reference to an element or subslice depending on the type of index.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(&amp;<span class="number">40</span>), v.<span class="title function_ invoke__">get</span>(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">Some</span>(&amp;[<span class="number">10</span>, <span class="number">40</span>][..]), v.<span class="title function_ invoke__">get</span>(<span class="number">0</span>..<span class="number">2</span>));</span><br></pre></td></tr></table></figure></li>
<li><code>get_mut&lt;I&gt;(index: I)</code></li>
<li><code>get_unchecked&lt;I&gt;(index: I)</code> Returns a reference to an element or subslice, without doing bounds checking</li>
<li><code>get_unchecked_mut&lt;I&gt;(index: I)</code></li>
<li><code>as_ptr(&amp;self) -&gt; *const T</code> Returns a raw pointer to the slice’s buffer<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x_ptr</span> = x.<span class="title function_ invoke__">as_ptr</span>();</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..x.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(x.<span class="title function_ invoke__">get_unchecked</span>(i), &amp;*x_ptr.<span class="title function_ invoke__">add</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>as_mut_ptr(&amp;mut self) -&gt; *mut T</code> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x_ptr</span> = x.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..x.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        *x_ptr.<span class="title function_ invoke__">add</span>(i) += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(x, &amp;[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure></li>
<li><code>as_ptr_range(&amp;self) -&gt; Range&lt;*const T&gt;</code> Returns the two raw pointers spanning the slice.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">as_ptr_range</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Range&lt;*<span class="keyword">const</span> T&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">start</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">as_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">end</span> = <span class="keyword">unsafe</span> &#123; start.<span class="title function_ invoke__">add</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">len</span>()) &#125;;</span><br><span class="line">    start..end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>as_mut_ptr_range(&amp;mut self) -&gt; Range&lt;*mut T&gt;</code></li>
<li><code>swap(&amp;mut self, a: usize, b: usize)</code> Swaps two elements in the slice.</li>
<li><code>reverse(&amp;mut self)</code> Reverses the order of elements in the slice, in place.</li>
<li><code>windows(&amp;self, size: usize)</code> Returns an iterator over all contiguous windows of length <code>size</code>. The windows overlap. If the slice is shorter than <code>size</code>, the iterator returns no values.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = slice.<span class="title function_ invoke__">windows</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;[<span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;s&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;[<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">is_none</span>());</span><br></pre></td></tr></table></figure></li>
<li><code>chunks(&amp;self, chunk_size: usize)</code> Returns an iterator over <code>chunk_size</code> elements of the slice at a time<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;m&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = slice.<span class="title function_ invoke__">chunks</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;[<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;[<span class="string">&#x27;m&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">is_none</span>());</span><br></pre></td></tr></table></figure></li>
<li><code>chunks_mut()</code></li>
<li><code>chunks_exact(&amp;self, chunk_size: usize)</code><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = [<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;m&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = slice.<span class="title function_ invoke__">chunks_exact</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;[<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>(), &amp;[<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert!</span>(iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">is_none</span>());</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">remainder</span>(), &amp;[<span class="string">&#x27;m&#x27;</span>]);</span><br></pre></td></tr></table></figure></li>
<li><code>as_chunks_unchecked&lt;const N: usize&gt;(&amp;self)</code> Splits the slice into a slice of <code>N</code>-element arrays, assuming that there’s no remainder</li>
<li><code>as_chunks&lt;const N: usize&gt;(&amp;self)</code> Splits the slice into a slice of <code>N</code>-element arrays, starting at the beginning of the slice, and a remainder slice with length strictly less than <code>N</code></li>
<li><code>as_rchunks&lt;const N: usize&gt;(&amp;self)</code> r means reverse</li>
<li><code>group_by&lt;F&gt;(&amp;self, pred: F)</code> Returns an iterator over the slice producing non-overlapping runs of elements using the predicate to separate them. The predicate is called on two elements following themselves, it means the predicate is called on <code>slice[0]</code> and <code>slice[1]</code> then on <code>slice[1]</code> and <code>slice[2]</code> and so on<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(slice_group_by)]</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">iter</span> = slice.<span class="title function_ invoke__">group_by</span>(|a, b| a &lt;= b);</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>][..]));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;[<span class="number">2</span>, <span class="number">3</span>][..]));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>][..]));</span><br><span class="line"><span class="built_in">assert_eq!</span>(iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure></li>
<li><code>split_at(&amp;self, mid: usize)</code> Divides one slice into two at an index.</li>
<li><code>split&lt;F&gt;(&amp;self, pred: F)</code> Returns an iterator over subslices separated by elements that match <code>pred</code>. The matched element is not contained in the subslices.</li>
<li><code>splitn&lt;F&gt;(&amp;self, n: usize, pred: F)</code> </li>
<li><code>contains(&amp;self, x: &amp;T)</code> Returns <code>true</code> if the slice contains an element with the given value.</li>
<li><code>starts_with(&amp;self, needle: &amp;[T])</code> eturns <code>true</code> if <code>needle</code> is a prefix of the slice<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];</span><br><span class="line"><span class="built_in">assert!</span>(v.<span class="title function_ invoke__">starts_with</span>(&amp;[<span class="number">10</span>]));</span><br><span class="line"><span class="built_in">assert!</span>(v.<span class="title function_ invoke__">starts_with</span>(&amp;[<span class="number">10</span>, <span class="number">40</span>]));</span><br><span class="line"><span class="built_in">assert!</span>(!v.<span class="title function_ invoke__">starts_with</span>(&amp;[<span class="number">50</span>]));</span><br></pre></td></tr></table></figure></li>
<li><code>ends_with(&amp;self, needle: &amp;[T])</code> </li>
<li><code>strip_prefix</code> Returns a subslice with the prefix removed.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = &amp;[<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">strip_prefix</span>(&amp;[<span class="number">10</span>]), <span class="title function_ invoke__">Some</span>(&amp;[<span class="number">40</span>, <span class="number">30</span>][..]));</span><br><span class="line"><span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">strip_prefix</span>(&amp;[<span class="number">50</span>]), <span class="literal">None</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">prefix</span> : &amp;<span class="type">str</span> = <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(<span class="string">b&quot;hello&quot;</span>.<span class="title function_ invoke__">strip_prefix</span>(prefix.<span class="title function_ invoke__">as_bytes</span>()),</span><br><span class="line">           <span class="title function_ invoke__">Some</span>(<span class="string">b&quot;llo&quot;</span>.<span class="title function_ invoke__">as_ref</span>()));</span><br></pre></td></tr></table></figure></li>
<li><code>strip_suffix</code></li>
<li><code>binary_search(&amp;self, x: &amp;T)</code>  Binary searches this slice for a given element.</li>
<li><code>sort_unstable(&amp;mut self)</code> Sorts the slice, but might not preserve the order of equal elements.</li>
<li><code>rotate_left(&amp;mut self, mid: usize)</code> Rotates the slice in-place such that the first <code>mid</code> elements of the slice move to the end while the last <code>self.len() - mid</code> elements move to the front.</li>
<li><code>fill(&amp;mut self, value: T)</code> Fills <code>self</code> with elements by cloning <code>value</code>.</li>
<li><code>clone_from_slice(&amp;mut self, src: &amp;[T])</code> Copies the elements from <code>src</code> into <code>self</code>.</li>
<li><code>copy_from_slice(&amp;mut self, src: &amp;[T])</code> </li>
<li><code>is_sorted(&amp;self)</code> </li>
<li><code>take&lt;&#39;a, R: OneSidedRange&lt;usize&gt;&gt;(self: &amp;mut &amp;&#39;a Self, range: R)</code> Removes the subslice corresponding to the given range</li>
<li><code>get_many_mut&lt;const N: usize&gt;</code> Returns mutable references to many indices at once.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(get_many_mut)]</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>([a, b]) = v.<span class="title function_ invoke__">get_many_mut</span>([<span class="number">0</span>, <span class="number">2</span>]) &#123;</span><br><span class="line">    *a = <span class="number">413</span>;</span><br><span class="line">    *b = <span class="number">612</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(v, &amp;[<span class="number">413</span>, <span class="number">2</span>, <span class="number">612</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="alloc-vec-Vec"><a href="#alloc-vec-Vec" class="headerlink" title="alloc::vec::Vec"></a>alloc::vec::Vec</h2><ul>
<li><code>fn truncate(&amp;mut self, len: usize)</code> Shortens the vector, keeping the first <code>len</code> elements and dropping the rest</li>
</ul>
<h2 id="std-collections-VecDeque"><a href="#std-collections-VecDeque" class="headerlink" title="std::collections::VecDeque"></a>std::collections::VecDeque</h2><p>A double-ended queue (deque) implemented with a growable ring buffer.<br>Since VecDeque is a ring buffer, its elements are not necessarily contiguous in memory. If you want to access the elements as a single slice, such as for efficient sorting, you can use make_contiguous. It rotates the VecDeque so that its elements do not wrap, and returns a mutable slice to the now-contiguous element sequence.</p>
<ul>
<li><code>swap(&amp;mut self, i: usize, j: usize)</code></li>
<li><code>reserve_exact(&amp;mut self, additional: usize)</code> Reserves the minimum capacity for at least <code>additional</code> more elements to be inserted in the given deque. Does nothing if the capacity is already sufficient.</li>
<li><code>reserve(&amp;mut self, additional: usize)</code></li>
<li><code>shrink_to_fit(&amp;mut self)</code> Shrinks the capacity of the deque as much as possible.</li>
<li><code>truncate(&amp;mut self, len: usize)</code> Shortens the deque, keeping the first <code>len</code> elements and dropping the rest.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = VecDeque::<span class="title function_ invoke__">new</span>();</span><br><span class="line">buf.<span class="title function_ invoke__">push_back</span>(<span class="number">5</span>);</span><br><span class="line">buf.<span class="title function_ invoke__">push_back</span>(<span class="number">10</span>);</span><br><span class="line">buf.<span class="title function_ invoke__">push_back</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(buf, [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]);</span><br><span class="line">buf.<span class="title function_ invoke__">truncate</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(buf, [<span class="number">5</span>]);</span><br></pre></td></tr></table></figure></li>
<li><code>iter(&amp;self)</code></li>
<li><code>as_slices(&amp;self)</code></li>
<li><code>slice_ranges&lt;R&gt;(&amp;self, range: R)</code> Given a range into the logical buffer of the deque, this function return two ranges into the physical buffer that correspond to the given range</li>
<li><code>range&lt;R&gt;(&amp;self, range: R)</code> Creates an iterator that covers the specified range in the deque.<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">deque</span>: VecDeque&lt;_&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_ invoke__">into</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">range</span> = deque.<span class="title function_ invoke__">range</span>(<span class="number">2</span>..).<span class="title function_ invoke__">copied</span>().collect::&lt;VecDeque&lt;_&gt;&gt;();</span><br><span class="line"><span class="built_in">assert_eq!</span>(range, [<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// A full range covers all contents</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">all</span> = deque.<span class="title function_ invoke__">range</span>(..);</span><br><span class="line"><span class="built_in">assert_eq!</span>(all.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
<li><code>drain&lt;R&gt;(&amp;mut self, range: R)</code> Removes the specified range from the deque in bulk, returning all removed elements as an iterator.</li>
<li><code>clear(&amp;mut self)</code></li>
<li><code>contains(&amp;self, x: &amp;T)</code> Returns <code>true</code> if the deque contains an element equal to the given value</li>
<li><code>front(&amp;self)</code> Provides a reference to the front element</li>
<li><code>front_mut(&amp;mut self)</code></li>
<li><code>back(&amp;self)</code></li>
<li><code>back_mut(&amp;mut self)</code></li>
<li><code>pop_front(&amp;mut self)</code></li>
<li><code>pop_back(&amp;mut self)</code></li>
<li><code>push_front(&amp;mut self, value: T)</code></li>
<li><code>push_back(&amp;mut self, value: T)</code></li>
</ul>
<h2 id="std-collections-LinkedList"><a href="#std-collections-LinkedList" class="headerlink" title="std::collections::LinkedList"></a><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">std::collections::LinkedList</a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://cliff0412.github.io/2023/05/01/rust/rust_std/rust-std-data-structure-1/" data-id="clk5adu2u001s0psj9swb19n8" data-title="rust std data structure (1D)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rust-std/" rel="tag">rust-std</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/blockchain/" rel="tag">blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cargo/" rel="tag">cargo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cryptography/" rel="tag">cryptography</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ecdsa/" rel="tag">ecdsa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/geth/" rel="tag">geth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mpc/" rel="tag">mpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust/" rel="tag">rust</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust-crate/" rel="tag">rust-crate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rust-std/" rel="tag">rust-std</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zkp/" rel="tag">zkp</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/blockchain/" style="font-size: 16px;">blockchain</a> <a href="/tags/cargo/" style="font-size: 10px;">cargo</a> <a href="/tags/cryptography/" style="font-size: 18px;">cryptography</a> <a href="/tags/ecdsa/" style="font-size: 10px;">ecdsa</a> <a href="/tags/geth/" style="font-size: 18px;">geth</a> <a href="/tags/golang/" style="font-size: 12px;">golang</a> <a href="/tags/mpc/" style="font-size: 10px;">mpc</a> <a href="/tags/rust/" style="font-size: 20px;">rust</a> <a href="/tags/rust-crate/" style="font-size: 10px;">rust-crate</a> <a href="/tags/rust-std/" style="font-size: 14px;">rust-std</a> <a href="/tags/zkp/" style="font-size: 10px;">zkp</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">February 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/06/27/cryptography/zkp/zkp-a-brief-understanding/">zkp a brief understanding (1)</a>
          </li>
        
          <li>
            <a href="/2023/06/20/cryptography/cryptography-04-digital-signature/">cryptography (4) digital signature</a>
          </li>
        
          <li>
            <a href="/2023/06/17/cryptography/cryptography-03-elliptic-curve/">cryptography (3) elliptic curve</a>
          </li>
        
          <li>
            <a href="/2023/06/10/cryptography/cryptography-02-rsa/">cryptography (2) RSA cryptosystem</a>
          </li>
        
          <li>
            <a href="/2023/06/08/rust/rust_std/rust-std-sync/">rust std sync</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 cliff<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>