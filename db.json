{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"source/2017-552.pdf","path":"2017-552.pdf","modified":1,"renderable":0},{"_id":"source/images/evm.drawio.google.png","path":"images/evm.drawio.google.png","modified":1,"renderable":0},{"_id":"source/images/evm.layout.png","path":"images/evm.layout.png","modified":1,"renderable":0},{"_id":"source/images/kademlia.locating.png","path":"images/kademlia.locating.png","modified":1,"renderable":0},{"_id":"source/images/kademlia.onlineprob.png","path":"images/kademlia.onlineprob.png","modified":1,"renderable":0},{"_id":"source/images/kademlia.subtree.png","path":"images/kademlia.subtree.png","modified":1,"renderable":0},{"_id":"source/images/geth_starts.drawio.png","path":"images/geth_starts.drawio.png","modified":1,"renderable":0},{"_id":"source/images/mpt.state.ref.png","path":"images/mpt.state.ref.png","modified":1,"renderable":0},{"_id":"source/images/mpt.png","path":"images/mpt.png","modified":1,"renderable":0},{"_id":"source/images/trie.prefix.png","path":"images/trie.prefix.png","modified":1,"renderable":0},{"_id":"source/images/paillier/carmichael_thorem.png","path":"images/paillier/carmichael_thorem.png","modified":1,"renderable":0},{"_id":"source/images/paillier/carmichael_thorem_2.png","path":"images/paillier/carmichael_thorem_2.png","modified":1,"renderable":0},{"_id":"source/images/paillier/homomorphic_addition.png","path":"images/paillier/homomorphic_addition.png","modified":1,"renderable":0},{"_id":"source/images/paillier/homomorphic_mul.png","path":"images/paillier/homomorphic_mul.png","modified":1,"renderable":0},{"_id":"source/images/two_party_ecdsa/paillier_enc.png","path":"images/two_party_ecdsa/paillier_enc.png","modified":1,"renderable":0},{"_id":"source/images/two_party_ecdsa/schnorr_ecdsa_comparison.png","path":"images/two_party_ecdsa/schnorr_ecdsa_comparison.png","modified":1,"renderable":0},{"_id":"source/images/rust/memory/trait_object_memory.png","path":"images/rust/memory/trait_object_memory.png","modified":1,"renderable":0},{"_id":"source/images/rust/macros/16.compile_process.png","path":"images/rust/macros/16.compile_process.png","modified":1,"renderable":0},{"_id":"source/images/rust/pointers/cycle.ref.png","path":"images/rust/pointers/cycle.ref.png","modified":1,"renderable":0},{"_id":"source/images/rust/pointers/rc.png","path":"images/rust/pointers/rc.png","modified":1,"renderable":0},{"_id":"source/images/rust/ownership/move-string.png","path":"images/rust/ownership/move-string.png","modified":1,"renderable":0},{"_id":"source/images/rust/ownership/move-string-2.png","path":"images/rust/ownership/move-string-2.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/blockchain.kademlia.md","hash":"0cb0522a114bc53d79f2db4a1bf2a02c29ef1c2f","modified":1681457596860},{"_id":"source/_posts/eth-sign.md","hash":"76a6376a62544d68438fb1759be07242a3e8e9ef","modified":1669607550181},{"_id":"source/_posts/geth.0.get.start.md","hash":"6cd5256bae5e43f3dfcd341e27c52eccf8848f60","modified":1682434784499},{"_id":"source/_posts/geth.1.rpc.md","hash":"623aec4f3cd8afb85b7b30d8bfde50bb2e5a4d4a","modified":1682614464069},{"_id":"source/_posts/geth-fine-tune.md","hash":"5431cd654f7152fd5c590891a53568f54eec4125","modified":1682416094119},{"_id":"source/_posts/geth.evm.md","hash":"ecea3e42003911dd58a2d6a9b8293f02ccb16a75","modified":1681441326144},{"_id":"source/_posts/hello-world.md","hash":"8241e671f980a667f875b9a6493f17bd333a1cfb","modified":1680799419107},{"_id":"source/_posts/MPT.md","hash":"1d0394f11c3361b4474dbe49ced5c5751144fe91","modified":1681534320319},{"_id":"source/_posts/paillier-encryption.md","hash":"4e43aa2d126bcb334563262563071c764c3ae19f","modified":1682317904177},{"_id":"source/_posts/rust-01-resource.md","hash":"a7c582fe2066639e3df2906f3b9b6d08ac4831c7","modified":1682950721628},{"_id":"source/_posts/rust-05-memory-layout.md","hash":"9a8c7dac3a23bca5f7692a3f6c0c8827dfd8c7e5","modified":1683082672719},{"_id":"source/_posts/rust-03-ownership.md","hash":"7d39498532088f438d76f1d0b42892bc985c0c95","modified":1682947052602},{"_id":"source/_posts/rust-02-basics.md","hash":"be1111d868417c54b8b019938b8144e8be35df1f","modified":1682932033124},{"_id":"source/_posts/rust-04-lifetime.md","hash":"d338498d7d159a3f94687082a10fc28ada706b16","modified":1682950129387},{"_id":"source/_posts/rust-06-smart-pointer.md","hash":"909ecf0ecf594651191e0953eca17aca7fa64669","modified":1683099103613},{"_id":"source/_posts/rust-08-project-management.md","hash":"2c1ab1e7b8c8510935a694e33aa2c676437f0fd1","modified":1683099708892},{"_id":"source/_posts/rust-cargo-doc.md","hash":"7d57cd4bc0f9249f78f533b635a5fead5bae81f3","modified":1683099946214},{"_id":"source/_posts/rust-07-macro.md","hash":"f6e51943ab413f5462baca1327c53ac20a8afcda","modified":1682950710350},{"_id":"source/_posts/two-party-ecdsa.md","hash":"e94506f2f21233958c8f48184fad671919f32f8b","modified":1682317913595},{"_id":"source/images/kademlia.onlineprob.png","hash":"98c55aa819ef7047b3749c89eb4546f0d799a239","modified":1681443973575},{"_id":"source/images/evm.layout.png","hash":"6927cb3b922b2bcec926ec5d797e7ea8ea2b5d00","modified":1681440784560},{"_id":"source/images/mpt.state.ref.png","hash":"ec747cf092820c0ab5f72d0f4f07f7705bb9ecf0","modified":1681533561017},{"_id":"source/images/paillier/homomorphic_mul.png","hash":"e8a2420501140a8d48db202065aa221df92f19dc","modified":1682317735470},{"_id":"source/images/paillier/homomorphic_addition.png","hash":"26b0e4a070a7e29710e2ceace09bbdb79b3a883e","modified":1682317632123},{"_id":"source/images/rust/memory/trait_object_memory.png","hash":"dd750cffa7bca5bde7856cfb65f4500de286c96f","modified":1683082638012},{"_id":"source/images/two_party_ecdsa/paillier_enc.png","hash":"132cdc74eb588951d1bd347b1b6e825912bc0460","modified":1682232953667},{"_id":"source/images/rust/ownership/move-string.png","hash":"d708edd6fb84b9d4ebe75556932f6b920934ca9a","modified":1682934539699},{"_id":"source/images/rust/pointers/rc.png","hash":"f568f69808ef0357ea5e6d42667d863b1139cbf1","modified":1683085079705},{"_id":"source/images/evm.drawio.google.png","hash":"413a44d66153c93e2c31172d988e051a2bed9940","modified":1681436195264},{"_id":"source/images/kademlia.subtree.png","hash":"d3198467460972151f4b2fe2b56fab0dd9e411ca","modified":1681442854122},{"_id":"source/images/geth_starts.drawio.png","hash":"3c426bd608121669f232aaa1b05ed7a342287fc8","modified":1682005494018},{"_id":"source/images/trie.prefix.png","hash":"67d26d416faf0cc43ee35b4acda598e88dad2949","modified":1681520956971},{"_id":"source/images/paillier/carmichael_thorem_2.png","hash":"29b103c94c36f4520ca8b675486af3d914998ac1","modified":1682316415073},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1669606834570},{"_id":"source/images/two_party_ecdsa/schnorr_ecdsa_comparison.png","hash":"69cbed302af467a4e99653dfb51dca45c4a5a6f3","modified":1682231680569},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1669606834570},{"_id":"source/images/rust/pointers/cycle.ref.png","hash":"ed99e2c6020833ccd5af751cf6eb2031cf47d9aa","modified":1683098263386},{"_id":"source/images/paillier/carmichael_thorem.png","hash":"75b4d32eb2233db653bca52cdea4a624555b5ce4","modified":1682316092261},{"_id":"source/images/rust/ownership/move-string-2.png","hash":"83342aed7ee254c099ada5d49ed8b9ba52a451a0","modified":1682934544128},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1669606834570},{"_id":"source/images/kademlia.locating.png","hash":"702d6b779294a3c6e033cc9bde14ef8950982310","modified":1681455579355},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1669606834570},{"_id":"source/images/rust/macros/16.compile_process.png","hash":"444080319ca2101672941346988f78ed9a37c32d","modified":1682908885234},{"_id":"source/images/mpt.png","hash":"700032035bdcd793f94da522330552727b00e5a3","modified":1681533347412},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1669606834570},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1669606834570},{"_id":"source/2017-552.pdf","hash":"b1a08857c1f6532f1fbb718c48a34fd48ea7da70","modified":1682236639612},{"_id":"public/2023/02/23/paillier-encryption/index.html","hash":"f442665309bcead9353d5d7c049169aa73c777bd","modified":1683099993675},{"_id":"public/2023/02/07/two-party-ecdsa/index.html","hash":"9b6411c6868a246291c9eb8bb6e8f7c1471aba0c","modified":1683099993675},{"_id":"public/2023/01/22/MPT/index.html","hash":"5855004a0f9ca2f267a5634562fe8442e83f1452","modified":1683099993675},{"_id":"public/2023/01/15/blockchain.kademlia/index.html","hash":"3138f9697f98c49d0be882a97a3b79fc613e31a7","modified":1683099993675},{"_id":"public/2022/11/28/eth-sign/index.html","hash":"e40faaf12ac382317a1fb3536383cdebae2540d1","modified":1683099993675},{"_id":"public/2023/01/01/geth-fine-tune/index.html","hash":"677ef58b5ed03169b61335cb75fde7bdd0f166f1","modified":1683099993675},{"_id":"public/2022/11/27/hello-world/index.html","hash":"e4f7d2e5a64c61c8f0bb880d81719f0d25a61a25","modified":1683099993675},{"_id":"public/2022/11/13/rust-cargo-doc/index.html","hash":"ac615639e8accad763797428c3198c6e55066f6a","modified":1683099993675},{"_id":"public/2022/11/08/geth.1.rpc/index.html","hash":"f8b28fbb7d057db69179e31b6c8664b73b498981","modified":1683099993675},{"_id":"public/2022/10/25/rust-05-memory-layout/index.html","hash":"645e98ef7faf754c03010820cf85346ea9f97387","modified":1683099993675},{"_id":"public/2022/09/27/rust-01-resource/index.html","hash":"70a1fec0a47e18648552c51ee991a23ba07547a0","modified":1683099993675},{"_id":"public/archives/page/2/index.html","hash":"6daa0855d233ee9b3136e6b334dea88a682cf513","modified":1683099993675},{"_id":"public/archives/index.html","hash":"3f0cac70a535e7c0c1da11aebbb32731998ac509","modified":1683099993675},{"_id":"public/archives/2022/index.html","hash":"0d1ea8ff8eabdda9bd1093cb64c45770dcdd95e3","modified":1683099993675},{"_id":"public/archives/2022/page/2/index.html","hash":"a6840eb8ad69115c84d115e2cdfca3915430799a","modified":1683099993675},{"_id":"public/archives/2022/11/index.html","hash":"eeeaaed8bf00c9120e658fb8af0a0a86474aed44","modified":1683099993675},{"_id":"public/archives/2022/09/index.html","hash":"559d791f9081d5a8163fc660fe0165c3c4a36ab7","modified":1683099993675},{"_id":"public/archives/2022/10/index.html","hash":"866c76f2b0d3d594fe91ea3f020c906512deb189","modified":1683099993675},{"_id":"public/archives/2022/12/index.html","hash":"b0aba1d720f28c8d04a1fb356b0f78f22a2a9501","modified":1683099993675},{"_id":"public/archives/2023/index.html","hash":"b50a57e74a9d0496807c4e305545133643494fcb","modified":1683099993675},{"_id":"public/archives/2023/01/index.html","hash":"37081c18711e39360d51b68e7ffdd3d818cec59b","modified":1683099993675},{"_id":"public/archives/2023/02/index.html","hash":"351aab7cd009cb24acb4c2d622bcf32b2a7b90e1","modified":1683099993675},{"_id":"public/tags/blockchain/index.html","hash":"43576c251dc218633a4df90a6bdd2c555ceeb7da","modified":1683099993675},{"_id":"public/tags/geth/index.html","hash":"a02598660b2ecc16222f0f7a0c68ad691aadc07c","modified":1683099993675},{"_id":"public/tags/cryptography/index.html","hash":"b11dd021874efba3db704c294d248f67b31bb751","modified":1683099993675},{"_id":"public/tags/rust/index.html","hash":"e1bd0d768d391d9432b8a3d52f5624f9753f00d8","modified":1683099993675},{"_id":"public/tags/cargo/index.html","hash":"cb0e074ec0dca331c40a473efbd8a9e12b5ffe7a","modified":1683099993675},{"_id":"public/tags/mpc/index.html","hash":"f647caea099cf7a032c88338bc2e8ec4972ed6e6","modified":1683099993675},{"_id":"public/tags/ecdsa/index.html","hash":"441880c955b09f35a3d0752577813604a092be37","modified":1683099993675},{"_id":"public/2023/01/08/geth.evm/index.html","hash":"9bf33836482b89817b62d5d46c70d79853d1b7c5","modified":1683099993675},{"_id":"public/2022/12/28/rust-07-macro/index.html","hash":"8c12d92d391cee4e5d25426c38e0df6ffc927845","modified":1683099993675},{"_id":"public/2022/11/06/rust-08-project-management/index.html","hash":"fd3d557187aea59629237e4c9519d69e7de8b03a","modified":1683099993675},{"_id":"public/2022/11/01/geth.0.get.start/index.html","hash":"a40c0be65953f35f99d13f95a8e61f2f7f2b3895","modified":1683099993675},{"_id":"public/2022/10/30/rust-06-smart-pointer/index.html","hash":"348e1e40962c19fdbc139a45dccaf1311cfc05cc","modified":1683099993675},{"_id":"public/2022/10/18/rust-04-lifetime/index.html","hash":"4ddccc2745c6846e58b27fa3b98a47a4e30ca5a2","modified":1683099993675},{"_id":"public/2022/10/11/rust-03-ownership/index.html","hash":"25f4caf60ecd2676bf0b84c59a51a5706a897766","modified":1683099993675},{"_id":"public/2022/10/04/rust-02-basics/index.html","hash":"fff6e5dde514d3735a42972d56b3cab2860febbe","modified":1683099993675},{"_id":"public/index.html","hash":"4172b46c3a10432f9800125531f2fed532ecc4ae","modified":1683099993675},{"_id":"public/page/2/index.html","hash":"4d1e3fe508eff5f643060cdf45797de86f64095c","modified":1683099993675},{"_id":"public/images/evm.layout.png","hash":"6927cb3b922b2bcec926ec5d797e7ea8ea2b5d00","modified":1683099993675},{"_id":"public/images/kademlia.onlineprob.png","hash":"98c55aa819ef7047b3749c89eb4546f0d799a239","modified":1683099993675},{"_id":"public/images/mpt.state.ref.png","hash":"ec747cf092820c0ab5f72d0f4f07f7705bb9ecf0","modified":1683099993675},{"_id":"public/images/paillier/homomorphic_mul.png","hash":"e8a2420501140a8d48db202065aa221df92f19dc","modified":1683099993675},{"_id":"public/images/two_party_ecdsa/paillier_enc.png","hash":"132cdc74eb588951d1bd347b1b6e825912bc0460","modified":1683099993675},{"_id":"public/images/rust/memory/trait_object_memory.png","hash":"dd750cffa7bca5bde7856cfb65f4500de286c96f","modified":1683099993675},{"_id":"public/images/rust/pointers/rc.png","hash":"f568f69808ef0357ea5e6d42667d863b1139cbf1","modified":1683099993675},{"_id":"public/images/paillier/homomorphic_addition.png","hash":"26b0e4a070a7e29710e2ceace09bbdb79b3a883e","modified":1683099993675},{"_id":"public/images/rust/ownership/move-string.png","hash":"d708edd6fb84b9d4ebe75556932f6b920934ca9a","modified":1683099993675},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1683099993675},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1683099993675},{"_id":"public/css/style.css","hash":"4da345d832a2682bcaee3ab3e22c15e3cd0e9cde","modified":1683099993675},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1683099993675},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1683099993675},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1683099993675},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1683099993675},{"_id":"public/images/evm.drawio.google.png","hash":"413a44d66153c93e2c31172d988e051a2bed9940","modified":1683099993675},{"_id":"public/images/kademlia.subtree.png","hash":"d3198467460972151f4b2fe2b56fab0dd9e411ca","modified":1683099993675},{"_id":"public/images/geth_starts.drawio.png","hash":"3c426bd608121669f232aaa1b05ed7a342287fc8","modified":1683099993675},{"_id":"public/images/trie.prefix.png","hash":"67d26d416faf0cc43ee35b4acda598e88dad2949","modified":1683099993675},{"_id":"public/images/paillier/carmichael_thorem_2.png","hash":"29b103c94c36f4520ca8b675486af3d914998ac1","modified":1683099993675},{"_id":"public/images/paillier/carmichael_thorem.png","hash":"75b4d32eb2233db653bca52cdea4a624555b5ce4","modified":1683099993675},{"_id":"public/images/two_party_ecdsa/schnorr_ecdsa_comparison.png","hash":"69cbed302af467a4e99653dfb51dca45c4a5a6f3","modified":1683099993675},{"_id":"public/images/rust/pointers/cycle.ref.png","hash":"ed99e2c6020833ccd5af751cf6eb2031cf47d9aa","modified":1683099993675},{"_id":"public/images/rust/ownership/move-string-2.png","hash":"83342aed7ee254c099ada5d49ed8b9ba52a451a0","modified":1683099993675},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1683099993675},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1683099993675},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1683099993675},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1683099993675},{"_id":"public/images/kademlia.locating.png","hash":"702d6b779294a3c6e033cc9bde14ef8950982310","modified":1683099993675},{"_id":"public/images/rust/macros/16.compile_process.png","hash":"444080319ca2101672941346988f78ed9a37c32d","modified":1683099993675},{"_id":"public/images/mpt.png","hash":"700032035bdcd793f94da522330552727b00e5a3","modified":1683099993675},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1683099993675},{"_id":"public/2017-552.pdf","hash":"b1a08857c1f6532f1fbb718c48a34fd48ea7da70","modified":1683099993675}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"eth_sign","date":"2022-11-28T03:47:56.000Z","_content":"\n# ethereum signing \n\n## ECDSA recap\n","source":"_posts/eth-sign.md","raw":"---\ntitle: eth_sign\ndate: 2022-11-28 11:47:56\ntags:\n---\n\n# ethereum signing \n\n## ECDSA recap\n","slug":"eth-sign","published":1,"updated":"2022-11-28T03:52:30.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tf00006usj139x39xb","content":"<h1 id=\"ethereum-signing\"><a href=\"#ethereum-signing\" class=\"headerlink\" title=\"ethereum signing\"></a>ethereum signing</h1><h2 id=\"ECDSA-recap\"><a href=\"#ECDSA-recap\" class=\"headerlink\" title=\"ECDSA recap\"></a>ECDSA recap</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ethereum-signing\"><a href=\"#ethereum-signing\" class=\"headerlink\" title=\"ethereum signing\"></a>ethereum signing</h1><h2 id=\"ECDSA-recap\"><a href=\"#ECDSA-recap\" class=\"headerlink\" title=\"ECDSA recap\"></a>ECDSA recap</h2>"},{"title":"understanding of kademlia protocol","date":"2023-01-15T03:00:30.000Z","_content":"\n# Introduction\nKademlia, a peer-to-peer distributed hash table(DHT). Some other DHT techniques are Chord. In the Kad network, each node has a unique 160-bit ID (ETH account address is 20 bytes, which is 160 bits) <key,value> pairs are stored in nodes whose ID is 'close' to the key for some notion of closeness. \n\n# system description\nKad effectively treats nodes as leaves in a binary tree, with each nodes's position determined by the shortest unique prefix of its ID. Figure 1 shows the position of a node with unique prefix 0011 in an example.\n\n![Figure 1](/images/kademlia.subtree.png)\nfor any given node, the binary tree is divided into a series of successively lower subtrees that don't contain the node.\n The highest-level subtree is composed of the other half of the whole tree that does not contain itself; the next level of subtree is composed of the remaining half that does not contain itself; and so on, until the complete tree is split into n subtrees. As shown in the figure, the part contained by the dotted line is the subtree of node 0011.\n\nif there is at least one node knwon in each subtree (in total, at least n nodes), a  recursive routing algorithm can be used to reach any node within the binary tree. Figure 2 shows an example of node 0011 locating node 1110 by successively querying the best node it knows of to find contacts in lower and lower subtrees; finaly the lookup converges to the target node.\n\n![Figure 2](/images/kademlia.locating.png)\n\n## node distance: XOR metric\nNode's id is 160 bit. Keys are also 160 bit. The Kad algorithm uses an XOR operation to calculate the distance between nodes.\nd(x,y) = x XOR y\n\n## node state\nfor each 0 <= i < 160, every node keeps k <IP address, UDP port, node ID> triples (as a list) for nodes of distance between 2^i and 2^i+1 from itself. it is called k-buckets.\neach k-bucket is kept sorted by time last seen--least recently seen node at the head, most-recently seen at the tail.\nfor small values of i, the k-buckets will generally be empty (as no approriate nodes will exist).\n\n The K value mentioned here is a system-level constant (must be an even number). It is set by the software system using Kad (for example, the Kad network used by BT download, K is set to 8). \n\n## update of k bucket\nThere are mainly the following ways to update the K bucket:\n\n- Actively collect nodes: Any node can initiate a FIND_NODE (query node) request to refresh the node information in the K-bucket.\n- Passive collection node: When receiving requests from other nodes (such as: FIND_NODE, FIND_VALUE), it will add the node ID of the other party to a certain K-bucket.\n- Detect invalid nodes: By initiating a PING request, determine whether a node in the K-bucket is online, and then clean up which offline nodes in the K-bucket.\n\nThe update principle is to insert the latest node into the tail of the queue, and not to remove the online nodes in the queue.\n\nAccording to the K-bucket update principle, nodes with a long online time are more likely to remain in the K-bucket list. Therefore, by keeping the nodes with a long online time in the K-bucket, Kad will significantly increase the number of nodes in the K-bucket. it can defend against DOS attacks to a certain extent, because only when the old node fails, Kad will update the K bucket information, which avoids flooding routing information through the addition of new nodes\n![probability of continuous online agains onlie duration](/images/kademlia.onlineprob.png)\n\n## RPC method\nThe Kademlia protocol includes four remote RPC operations: PING, STORE, FIND_NODE, FIND_VALUE.\n\n- PING probes a node to see if it is online.\n- STORE instructs a node to store a <key,value> pair for later retrieval.\n- FIND_NODE takes a 160bit ID as an argument. The receiver of this operation returns the (IP address, UDP port, Node ID) information of K nodes that it knows are closer to the target ID. The information of these nodes can be obtained from a single K-bucket, or from multiple K-buckets. In either case, the receiver will return the information of K nodes to the operation initiator. \n- The FIND_VALUE operation is similar to the FIND_NODE operation, with one exception. if the RPC receipients has received a STORE RPC for the key, it just returns the stored value.\n\n## node lookup\nKad participant must locate the k closest nodes to some given node ID. Kad employs a recursive algorithm for node lookups. It recursively send FIND_NODE requests to \\alpha (out of k) closest nodes it knows of. \n\n## find a <key,value> pair\nto find a <key,value> pair, a node starts by performing a lookup to find the k nodes with IDs closest to the key. However, value lookups use FIND_VLAUE rather than FIND_NODE RPCs.\n\n##  node join\nto join the network, a node u must have a contact to an already participating node w.\n\n## routing table\n\n# references\n- [kademlia paper](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)\n- [go implementation](https://github.com/libp2p/go-libp2p-kad-dht)\n- [kademlia stanford](https://codethechange.stanford.edu/guides/guide_kademlia.html)\n- [zhihu](https://zhuanlan.zhihu.com/p/388994038)","source":"_posts/blockchain.kademlia.md","raw":"---\ntitle: understanding of kademlia protocol\ndate: 2023-01-15 11:00:30\ntags: [blockchain]\n---\n\n# Introduction\nKademlia, a peer-to-peer distributed hash table(DHT). Some other DHT techniques are Chord. In the Kad network, each node has a unique 160-bit ID (ETH account address is 20 bytes, which is 160 bits) <key,value> pairs are stored in nodes whose ID is 'close' to the key for some notion of closeness. \n\n# system description\nKad effectively treats nodes as leaves in a binary tree, with each nodes's position determined by the shortest unique prefix of its ID. Figure 1 shows the position of a node with unique prefix 0011 in an example.\n\n![Figure 1](/images/kademlia.subtree.png)\nfor any given node, the binary tree is divided into a series of successively lower subtrees that don't contain the node.\n The highest-level subtree is composed of the other half of the whole tree that does not contain itself; the next level of subtree is composed of the remaining half that does not contain itself; and so on, until the complete tree is split into n subtrees. As shown in the figure, the part contained by the dotted line is the subtree of node 0011.\n\nif there is at least one node knwon in each subtree (in total, at least n nodes), a  recursive routing algorithm can be used to reach any node within the binary tree. Figure 2 shows an example of node 0011 locating node 1110 by successively querying the best node it knows of to find contacts in lower and lower subtrees; finaly the lookup converges to the target node.\n\n![Figure 2](/images/kademlia.locating.png)\n\n## node distance: XOR metric\nNode's id is 160 bit. Keys are also 160 bit. The Kad algorithm uses an XOR operation to calculate the distance between nodes.\nd(x,y) = x XOR y\n\n## node state\nfor each 0 <= i < 160, every node keeps k <IP address, UDP port, node ID> triples (as a list) for nodes of distance between 2^i and 2^i+1 from itself. it is called k-buckets.\neach k-bucket is kept sorted by time last seen--least recently seen node at the head, most-recently seen at the tail.\nfor small values of i, the k-buckets will generally be empty (as no approriate nodes will exist).\n\n The K value mentioned here is a system-level constant (must be an even number). It is set by the software system using Kad (for example, the Kad network used by BT download, K is set to 8). \n\n## update of k bucket\nThere are mainly the following ways to update the K bucket:\n\n- Actively collect nodes: Any node can initiate a FIND_NODE (query node) request to refresh the node information in the K-bucket.\n- Passive collection node: When receiving requests from other nodes (such as: FIND_NODE, FIND_VALUE), it will add the node ID of the other party to a certain K-bucket.\n- Detect invalid nodes: By initiating a PING request, determine whether a node in the K-bucket is online, and then clean up which offline nodes in the K-bucket.\n\nThe update principle is to insert the latest node into the tail of the queue, and not to remove the online nodes in the queue.\n\nAccording to the K-bucket update principle, nodes with a long online time are more likely to remain in the K-bucket list. Therefore, by keeping the nodes with a long online time in the K-bucket, Kad will significantly increase the number of nodes in the K-bucket. it can defend against DOS attacks to a certain extent, because only when the old node fails, Kad will update the K bucket information, which avoids flooding routing information through the addition of new nodes\n![probability of continuous online agains onlie duration](/images/kademlia.onlineprob.png)\n\n## RPC method\nThe Kademlia protocol includes four remote RPC operations: PING, STORE, FIND_NODE, FIND_VALUE.\n\n- PING probes a node to see if it is online.\n- STORE instructs a node to store a <key,value> pair for later retrieval.\n- FIND_NODE takes a 160bit ID as an argument. The receiver of this operation returns the (IP address, UDP port, Node ID) information of K nodes that it knows are closer to the target ID. The information of these nodes can be obtained from a single K-bucket, or from multiple K-buckets. In either case, the receiver will return the information of K nodes to the operation initiator. \n- The FIND_VALUE operation is similar to the FIND_NODE operation, with one exception. if the RPC receipients has received a STORE RPC for the key, it just returns the stored value.\n\n## node lookup\nKad participant must locate the k closest nodes to some given node ID. Kad employs a recursive algorithm for node lookups. It recursively send FIND_NODE requests to \\alpha (out of k) closest nodes it knows of. \n\n## find a <key,value> pair\nto find a <key,value> pair, a node starts by performing a lookup to find the k nodes with IDs closest to the key. However, value lookups use FIND_VLAUE rather than FIND_NODE RPCs.\n\n##  node join\nto join the network, a node u must have a contact to an already participating node w.\n\n## routing table\n\n# references\n- [kademlia paper](https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf)\n- [go implementation](https://github.com/libp2p/go-libp2p-kad-dht)\n- [kademlia stanford](https://codethechange.stanford.edu/guides/guide_kademlia.html)\n- [zhihu](https://zhuanlan.zhihu.com/p/388994038)","slug":"blockchain.kademlia","published":1,"updated":"2023-04-14T07:33:16.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2ti00016usj67y74gw9","content":"<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p>Kademlia, a peer-to-peer distributed hash table(DHT). Some other DHT techniques are Chord. In the Kad network, each node has a unique 160-bit ID (ETH account address is 20 bytes, which is 160 bits) &lt;key,value&gt; pairs are stored in nodes whose ID is ‘close’ to the key for some notion of closeness. </p>\n<h1 id=\"system-description\"><a href=\"#system-description\" class=\"headerlink\" title=\"system description\"></a>system description</h1><p>Kad effectively treats nodes as leaves in a binary tree, with each nodes’s position determined by the shortest unique prefix of its ID. Figure 1 shows the position of a node with unique prefix 0011 in an example.</p>\n<p><img src=\"/images/kademlia.subtree.png\" alt=\"Figure 1\"><br>for any given node, the binary tree is divided into a series of successively lower subtrees that don’t contain the node.<br> The highest-level subtree is composed of the other half of the whole tree that does not contain itself; the next level of subtree is composed of the remaining half that does not contain itself; and so on, until the complete tree is split into n subtrees. As shown in the figure, the part contained by the dotted line is the subtree of node 0011.</p>\n<p>if there is at least one node knwon in each subtree (in total, at least n nodes), a  recursive routing algorithm can be used to reach any node within the binary tree. Figure 2 shows an example of node 0011 locating node 1110 by successively querying the best node it knows of to find contacts in lower and lower subtrees; finaly the lookup converges to the target node.</p>\n<p><img src=\"/images/kademlia.locating.png\" alt=\"Figure 2\"></p>\n<h2 id=\"node-distance-XOR-metric\"><a href=\"#node-distance-XOR-metric\" class=\"headerlink\" title=\"node distance: XOR metric\"></a>node distance: XOR metric</h2><p>Node’s id is 160 bit. Keys are also 160 bit. The Kad algorithm uses an XOR operation to calculate the distance between nodes.<br>d(x,y) &#x3D; x XOR y</p>\n<h2 id=\"node-state\"><a href=\"#node-state\" class=\"headerlink\" title=\"node state\"></a>node state</h2><p>for each 0 &lt;&#x3D; i &lt; 160, every node keeps k &lt;IP address, UDP port, node ID&gt; triples (as a list) for nodes of distance between 2^i and 2^i+1 from itself. it is called k-buckets.<br>each k-bucket is kept sorted by time last seen–least recently seen node at the head, most-recently seen at the tail.<br>for small values of i, the k-buckets will generally be empty (as no approriate nodes will exist).</p>\n<p> The K value mentioned here is a system-level constant (must be an even number). It is set by the software system using Kad (for example, the Kad network used by BT download, K is set to 8). </p>\n<h2 id=\"update-of-k-bucket\"><a href=\"#update-of-k-bucket\" class=\"headerlink\" title=\"update of k bucket\"></a>update of k bucket</h2><p>There are mainly the following ways to update the K bucket:</p>\n<ul>\n<li>Actively collect nodes: Any node can initiate a FIND_NODE (query node) request to refresh the node information in the K-bucket.</li>\n<li>Passive collection node: When receiving requests from other nodes (such as: FIND_NODE, FIND_VALUE), it will add the node ID of the other party to a certain K-bucket.</li>\n<li>Detect invalid nodes: By initiating a PING request, determine whether a node in the K-bucket is online, and then clean up which offline nodes in the K-bucket.</li>\n</ul>\n<p>The update principle is to insert the latest node into the tail of the queue, and not to remove the online nodes in the queue.</p>\n<p>According to the K-bucket update principle, nodes with a long online time are more likely to remain in the K-bucket list. Therefore, by keeping the nodes with a long online time in the K-bucket, Kad will significantly increase the number of nodes in the K-bucket. it can defend against DOS attacks to a certain extent, because only when the old node fails, Kad will update the K bucket information, which avoids flooding routing information through the addition of new nodes<br><img src=\"/images/kademlia.onlineprob.png\" alt=\"probability of continuous online agains onlie duration\"></p>\n<h2 id=\"RPC-method\"><a href=\"#RPC-method\" class=\"headerlink\" title=\"RPC method\"></a>RPC method</h2><p>The Kademlia protocol includes four remote RPC operations: PING, STORE, FIND_NODE, FIND_VALUE.</p>\n<ul>\n<li>PING probes a node to see if it is online.</li>\n<li>STORE instructs a node to store a &lt;key,value&gt; pair for later retrieval.</li>\n<li>FIND_NODE takes a 160bit ID as an argument. The receiver of this operation returns the (IP address, UDP port, Node ID) information of K nodes that it knows are closer to the target ID. The information of these nodes can be obtained from a single K-bucket, or from multiple K-buckets. In either case, the receiver will return the information of K nodes to the operation initiator. </li>\n<li>The FIND_VALUE operation is similar to the FIND_NODE operation, with one exception. if the RPC receipients has received a STORE RPC for the key, it just returns the stored value.</li>\n</ul>\n<h2 id=\"node-lookup\"><a href=\"#node-lookup\" class=\"headerlink\" title=\"node lookup\"></a>node lookup</h2><p>Kad participant must locate the k closest nodes to some given node ID. Kad employs a recursive algorithm for node lookups. It recursively send FIND_NODE requests to \\alpha (out of k) closest nodes it knows of. </p>\n<h2 id=\"find-a-lt-key-value-gt-pair\"><a href=\"#find-a-lt-key-value-gt-pair\" class=\"headerlink\" title=\"find a &lt;key,value&gt; pair\"></a>find a &lt;key,value&gt; pair</h2><p>to find a &lt;key,value&gt; pair, a node starts by performing a lookup to find the k nodes with IDs closest to the key. However, value lookups use FIND_VLAUE rather than FIND_NODE RPCs.</p>\n<h2 id=\"node-join\"><a href=\"#node-join\" class=\"headerlink\" title=\"node join\"></a>node join</h2><p>to join the network, a node u must have a contact to an already participating node w.</p>\n<h2 id=\"routing-table\"><a href=\"#routing-table\" class=\"headerlink\" title=\"routing table\"></a>routing table</h2><h1 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h1><ul>\n<li><a href=\"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf\">kademlia paper</a></li>\n<li><a href=\"https://github.com/libp2p/go-libp2p-kad-dht\">go implementation</a></li>\n<li><a href=\"https://codethechange.stanford.edu/guides/guide_kademlia.html\">kademlia stanford</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/388994038\">zhihu</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><p>Kademlia, a peer-to-peer distributed hash table(DHT). Some other DHT techniques are Chord. In the Kad network, each node has a unique 160-bit ID (ETH account address is 20 bytes, which is 160 bits) &lt;key,value&gt; pairs are stored in nodes whose ID is ‘close’ to the key for some notion of closeness. </p>\n<h1 id=\"system-description\"><a href=\"#system-description\" class=\"headerlink\" title=\"system description\"></a>system description</h1><p>Kad effectively treats nodes as leaves in a binary tree, with each nodes’s position determined by the shortest unique prefix of its ID. Figure 1 shows the position of a node with unique prefix 0011 in an example.</p>\n<p><img src=\"/images/kademlia.subtree.png\" alt=\"Figure 1\"><br>for any given node, the binary tree is divided into a series of successively lower subtrees that don’t contain the node.<br> The highest-level subtree is composed of the other half of the whole tree that does not contain itself; the next level of subtree is composed of the remaining half that does not contain itself; and so on, until the complete tree is split into n subtrees. As shown in the figure, the part contained by the dotted line is the subtree of node 0011.</p>\n<p>if there is at least one node knwon in each subtree (in total, at least n nodes), a  recursive routing algorithm can be used to reach any node within the binary tree. Figure 2 shows an example of node 0011 locating node 1110 by successively querying the best node it knows of to find contacts in lower and lower subtrees; finaly the lookup converges to the target node.</p>\n<p><img src=\"/images/kademlia.locating.png\" alt=\"Figure 2\"></p>\n<h2 id=\"node-distance-XOR-metric\"><a href=\"#node-distance-XOR-metric\" class=\"headerlink\" title=\"node distance: XOR metric\"></a>node distance: XOR metric</h2><p>Node’s id is 160 bit. Keys are also 160 bit. The Kad algorithm uses an XOR operation to calculate the distance between nodes.<br>d(x,y) &#x3D; x XOR y</p>\n<h2 id=\"node-state\"><a href=\"#node-state\" class=\"headerlink\" title=\"node state\"></a>node state</h2><p>for each 0 &lt;&#x3D; i &lt; 160, every node keeps k &lt;IP address, UDP port, node ID&gt; triples (as a list) for nodes of distance between 2^i and 2^i+1 from itself. it is called k-buckets.<br>each k-bucket is kept sorted by time last seen–least recently seen node at the head, most-recently seen at the tail.<br>for small values of i, the k-buckets will generally be empty (as no approriate nodes will exist).</p>\n<p> The K value mentioned here is a system-level constant (must be an even number). It is set by the software system using Kad (for example, the Kad network used by BT download, K is set to 8). </p>\n<h2 id=\"update-of-k-bucket\"><a href=\"#update-of-k-bucket\" class=\"headerlink\" title=\"update of k bucket\"></a>update of k bucket</h2><p>There are mainly the following ways to update the K bucket:</p>\n<ul>\n<li>Actively collect nodes: Any node can initiate a FIND_NODE (query node) request to refresh the node information in the K-bucket.</li>\n<li>Passive collection node: When receiving requests from other nodes (such as: FIND_NODE, FIND_VALUE), it will add the node ID of the other party to a certain K-bucket.</li>\n<li>Detect invalid nodes: By initiating a PING request, determine whether a node in the K-bucket is online, and then clean up which offline nodes in the K-bucket.</li>\n</ul>\n<p>The update principle is to insert the latest node into the tail of the queue, and not to remove the online nodes in the queue.</p>\n<p>According to the K-bucket update principle, nodes with a long online time are more likely to remain in the K-bucket list. Therefore, by keeping the nodes with a long online time in the K-bucket, Kad will significantly increase the number of nodes in the K-bucket. it can defend against DOS attacks to a certain extent, because only when the old node fails, Kad will update the K bucket information, which avoids flooding routing information through the addition of new nodes<br><img src=\"/images/kademlia.onlineprob.png\" alt=\"probability of continuous online agains onlie duration\"></p>\n<h2 id=\"RPC-method\"><a href=\"#RPC-method\" class=\"headerlink\" title=\"RPC method\"></a>RPC method</h2><p>The Kademlia protocol includes four remote RPC operations: PING, STORE, FIND_NODE, FIND_VALUE.</p>\n<ul>\n<li>PING probes a node to see if it is online.</li>\n<li>STORE instructs a node to store a &lt;key,value&gt; pair for later retrieval.</li>\n<li>FIND_NODE takes a 160bit ID as an argument. The receiver of this operation returns the (IP address, UDP port, Node ID) information of K nodes that it knows are closer to the target ID. The information of these nodes can be obtained from a single K-bucket, or from multiple K-buckets. In either case, the receiver will return the information of K nodes to the operation initiator. </li>\n<li>The FIND_VALUE operation is similar to the FIND_NODE operation, with one exception. if the RPC receipients has received a STORE RPC for the key, it just returns the stored value.</li>\n</ul>\n<h2 id=\"node-lookup\"><a href=\"#node-lookup\" class=\"headerlink\" title=\"node lookup\"></a>node lookup</h2><p>Kad participant must locate the k closest nodes to some given node ID. Kad employs a recursive algorithm for node lookups. It recursively send FIND_NODE requests to \\alpha (out of k) closest nodes it knows of. </p>\n<h2 id=\"find-a-lt-key-value-gt-pair\"><a href=\"#find-a-lt-key-value-gt-pair\" class=\"headerlink\" title=\"find a &lt;key,value&gt; pair\"></a>find a &lt;key,value&gt; pair</h2><p>to find a &lt;key,value&gt; pair, a node starts by performing a lookup to find the k nodes with IDs closest to the key. However, value lookups use FIND_VLAUE rather than FIND_NODE RPCs.</p>\n<h2 id=\"node-join\"><a href=\"#node-join\" class=\"headerlink\" title=\"node join\"></a>node join</h2><p>to join the network, a node u must have a contact to an already participating node w.</p>\n<h2 id=\"routing-table\"><a href=\"#routing-table\" class=\"headerlink\" title=\"routing table\"></a>routing table</h2><h1 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h1><ul>\n<li><a href=\"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf\">kademlia paper</a></li>\n<li><a href=\"https://github.com/libp2p/go-libp2p-kad-dht\">go implementation</a></li>\n<li><a href=\"https://codethechange.stanford.edu/guides/guide_kademlia.html\">kademlia stanford</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/388994038\">zhihu</a></li>\n</ul>\n"},{"title":"geth start","date":"2022-11-01T10:15:12.000Z","_content":"\n## build from source\n```\ngit clone https://github.com/ethereum/go-ethereum.git\ncd go-ethereum\nmake geth\n```\n\n## understanding geth config\ngeth config type is defined in /cmd/geth/config.go\n```go\ntype gethConfig struct {\n\tEth      ethconfig.Config\n\tNode     node.Config\n\tEthstats ethstatsConfig\n\tMetrics  metrics.Config\n}\n```\n- **ethconfig** (eth/ethconfig/config.go)\ncontains configuration options for of the ETH and LES(light node) protocols, such as NetworkId, SyncMode, txpool.Config, database options\n- **nodeConfig** (node/config.go)\nrepresents a small collection of configuration values to fine tune the P2P network layer of a protocol stack. These values can be further extended by all registered services. such as p2p.Config, DataDir, KeyStoreDir, HTTPHost, HTTPModules(eth,net,web3), WSHost\n- **metrics.Config** (metrics/config.go)\ncontains the configuration for the metric collection, such as InfluxDBEndpoint, etc\n- **ethstatsConfig**\nonly one URL entry\n\ngeth provides default config in the above files. user config file path is given by the below flag\n```go\nconfigFileFlag = &cli.StringFlag{\n\t\tName:     \"config\",\n\t\tUsage:    \"TOML configuration file\",\n\t\tCategory: flags.EthCategory,\n\t}\n```\n\nThe config file should be a .toml file. A convenient way to create a config file is to get Geth to create one for you and use it as a template. To do this, use the dumpconfig command, saving the result to a .toml file. Note that you also need to explicitly provide the network_id on the command line for the public testnets such as Sepolia or Geoerli:\n```\n./geth --sepolia dumpconfig > geth-config.toml\n```\nto specify path to config file\n```\ngeth --sepolia --config geth-config.toml\n```\n\n## key configs\n- [Eth].TxLookupLimit \nNumber of recent blocks to maintain transactions index for (default = about one year, 0 = entire chain), default: 2350000\n- [Node].BootstrapNodes\nused to establish connectivity with the rest of the network.\ngeth provides default bootstrapNodes in file `params/bootnodes.go`\n- [Metrics_AND_STATS].ethstats\nReporting URL of a ethstats service (nodename:secret@host:port), [more detail](https://geth.ethereum.org/docs/monitoring/ethstats)\n- SyncMode\n- TrieDirtyCache\n- NoPruning\n- TrieCleanCacheJournal e.g triecache\n## how geth starts\n\n![geth starts](/images/geth_starts.drawio.png)\nthe main func is in `cmd/geth/main.go`\n```go\nfunc main() {\n\tif err := app.Run(os.Args); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}\n```\nthe main() function is very short, and its main function is to start a tool for parsing command line commands: `gopkg.in/urfave/cli.v1`. Going deeper, we will find that `app.Action = geth` will be called when the cli app is initialized to call the geth() function\n```go\nfunc init() {\n\t// Initialize the CLI app and start Geth\n\tapp.Action = geth\n    // ....\n}\n```\ngeth is the main entry point into the system if no special subcommand is run. It creates a default node based on the command line arguments and runs it in blocking mode, waiting for it to be shut down.\n```go\nfunc geth(ctx *cli.Context) error {\n\tif args := ctx.Args().Slice(); len(args) > 0 {\n\t\treturn fmt.Errorf(\"invalid command: %q\", args[0])\n\t}\n\n\tprepare(ctx)\n\tstack, backend := makeFullNode(ctx)\n\tdefer stack.Close()\n\n\tstartNode(ctx, stack, backend, false)\n\tstack.Wait()\n\treturn nil\n}\n```\nIn the geth() function, there are three important function calls, namely: `prepare()`, `makeFullNode()`, and `startNode()`.\n\n### prepare\nThe implementation of the prepare() function is in the current main.go file. It is mainly used to set some configurations required for node initialization.\n\n### makeFullNode\nThe implementation of the `makeFullNode()` function is located in the `cmd/geth/config.go` file. It will load the context of the command and apply user given configuration; and generate instances of `stack` and `backend`. Among them, `stack` is an instance of `Node` type (Node is the top-level instance in the life cycle of geth. It is responsible for managing high-level abstractions such as P2P Server, Http Server, and Database in the node. The definition of the Node type is located in the `node/node.go` file), which is initialized by calling `makeConfigNode()` function through `makeFullNode()` function. inside `makeFullNode`, it calls `node.New(&cfg.Node)` to initiate a node. During instantiating of node, it invokes `rpc.NewServer()` to create a new rpc server and put in the field `inprocHandler`. it registers `rpc` api namespace by default.\n\nThe `backend` here is an interface of `ethapi.Backend` type, which provides the basic functions needed to obtain the runtime of the Ethereum execution layer. Its definition is located in `internal/ethapi/backend.go`. Since there are many functions in this interface, we have selected some of the key functions as below for a glimpse of its functionality. `backend` is created by calling `backend, eth := utils.RegisterEthService(stack, &cfg.Eth)`. Inside, it calls `eth.New(stack, cfg)` to create `backend` instance. During `backend` initiating, it opens database (`chainDb, err := stack.OpenDatabaseWithFreezer(\"chaindata\", config.DatabaseCache, config.DatabaseHandles, config.DatabaseFreezer, \"eth/db/chaindata/\", false)`). Further, it creates consensus engine, `engine := ethconfig.CreateConsensusEngine(stack, &ethashConfig, cliqueConfig, config.Miner.Notify, config.Miner.Noverify, chainDb)`. goerli testnet use POA consensus (clique). \n```go\ntype Backend interface {\n\tSyncProgress() ethereum.SyncProgress\n\tSuggestGasTipCap(ctx context.Context) (*big.Int, error)\n\tChainDb() ethdb.Database\n\tAccountManager() *accounts.Manager\n\tExtRPCEnabled() bool\n\tRPCGasCap() uint64            // global gas cap for eth_call over rpc: DoS protection\n\tRPCEVMTimeout() time.Duration // global timeout for eth_call over rpc: DoS protection\n\tRPCTxFeeCap() float64         // global tx fee cap for all transaction related APIs\n\tUnprotectedAllowed() bool     // allows only for EIP155 transactions.\n\tSetHead(number uint64)\n\tHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Header, error)\n\tHeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, error)\n\tHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Header, error)\n\tCurrentHeader() *types.Header\n\tCurrentBlock() *types.Header\n\tBlockByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Block, error)\n\tBlockByHash(ctx context.Context, hash common.Hash) (*types.Block, error)\n\tBlockByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Block, error)\n\tStateAndHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*state.StateDB, *types.Header, error)\n\tStateAndHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*state.StateDB, *types.Header, error)\n\tPendingBlockAndReceipts() (*types.Block, types.Receipts)\n\tGetReceipts(ctx context.Context, hash common.Hash) (types.Receipts, error)\n\tGetTd(ctx context.Context, hash common.Hash) *big.Int\n\tGetEVM(ctx context.Context, msg *core.Message, state *state.StateDB, header *types.Header, vmConfig *vm.Config) (*vm.EVM, func() error, error)\n\tSubscribeChainEvent(ch chan<- core.ChainEvent) event.Subscription\n\tSubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription\n\tSubscribeChainSideEvent(ch chan<- core.ChainSideEvent) event.Subscription\n\tSendTx(ctx context.Context, signedTx *types.Transaction) error\n\tGetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, uint64, uint64, error)\n\tGetPoolTransactions() (types.Transactions, error)\n\tGetPoolTransaction(txHash common.Hash) *types.Transaction\n\tGetPoolNonce(ctx context.Context, addr common.Address) (uint64, error)\n\tStats() (pending int, queued int)\n\tTxPoolContent() (map[common.Address]types.Transactions, map[common.Address]types.Transactions)\n\tTxPoolContentFrom(addr common.Address) (types.Transactions, types.Transactions)\n\tSubscribeNewTxsEvent(chan<- core.NewTxsEvent) event.Subscription\n\tChainConfig() *params.ChainConfig\n\tEngine() consensus.Engine\n\tGetBody(ctx context.Context, hash common.Hash, number rpc.BlockNumber) (*types.Body, error)\n\tGetLogs(ctx context.Context, blockHash common.Hash, number uint64) ([][]*types.Log, error)\n\tSubscribeRemovedLogsEvent(ch chan<- core.RemovedLogsEvent) event.Subscription\n\tSubscribeLogsEvent(ch chan<- []*types.Log) event.Subscription\n\tSubscribePendingLogsEvent(ch chan<- []*types.Log) event.Subscription\n\tBloomStatus() (uint64, uint64)\n\tServiceFilter(ctx context.Context, session *bloombits.MatcherSession)\n}\n```\n\nIf readers want to customize some new RPC APIs, they can define functions in the /internal/ethapi.Backend interface and add specific implementations to EthAPIBackend\n\n### startNode\nThe last key function, `startNode()`, is to officially start an Ethereum execution layer node. It starts the Stack instance (Node) by calling the utils.StartNode() function which triggers the Node.Start() function. In the Node.Start() function, it traverses the backend instances registered in `Node.lifecycles` and starts them. In addition, in the startNode() function, the unlockAccounts() function is still called, and the unlocked wallet is registered in the stack, and the RPClient module that interacts with local Geth is created through the stack.Attach() function\n\nAt the end of the geth() function, the function executes `stack.Wait()`, so that the main thread enters the blocking state, and the services of other functional modules are distributed to other sub-coroutines for maintenance\n\n## Node\nAs we mentioned earlier, the Node type belongs to the top-level instance in the life cycle of geth, and it is responsible for being the administrator of the high-level abstract module communicating with the outside world, such as managing rpc server, http server, Web Socket, and P2P Server external interface . At the same time, Node maintains the back-end instances and services (lifecycles []Lifecycle) required for node operation, such as the Ethereum type we mentioned above that is responsible for the specific Service\n```go\ntype Node struct {\n\teventmux      *event.TypeMux\n\tconfig        *Config\n\taccman        *accounts.Manager\n\tlog           log.Logger\n\tkeyDir        string        // key store directory\n\tkeyDirTemp    bool          // If true, key directory will be removed by Stop\n\tdirLock       *flock.Flock  // prevents concurrent use of instance directory\n\tstop          chan struct{} // Channel to wait for termination notifications\n\tserver        *p2p.Server   // Currently running P2P networking layer\n\tstartStopLock sync.Mutex    // Start/Stop are protected by an additional lock\n\tstate         int           // Tracks state of node lifecycle\n\n\tlock          sync.Mutex\n\tlifecycles    []Lifecycle // All registered backends, services, and auxiliary services that have a lifecycle\n\trpcAPIs       []rpc.API   // List of APIs currently provided by the node\n\thttp          *httpServer //\n\tws            *httpServer //\n\thttpAuth      *httpServer //\n\twsAuth        *httpServer //\n\tipc           *ipcServer  // Stores information about the ipc http server\n\tinprocHandler *rpc.Server // In-process RPC request handler to process the API requests\n\n\tdatabases map[*closeTrackingDB]struct{} // All open databases\n}\n```\n\n### close node\nAs mentioned earlier, the main thread of the entire program is blocked because of calling `stack.Wait()`. We can see that a channel called `stop` is declared in the Node structure. Since this Channel has not been assigned a value, the main process of the entire geth enters the blocking state, and continues to execute other business coroutines concurrently\n```go\n// Wait blocks until the node is closed.\nfunc (n *Node) Wait() {\n <-n.stop\n}\n```\nWhen the Channel n.stop is assigned a value, the geth main function will stop the current blocking state and start to perform a series of corresponding resource release operations.\nIt is worth noting that in the current codebase of go-ethereum, the blocking state of the main process is not ended directly by assigning a value to the stop channel, but a more concise and rude way is used: call the close() function directly Close the Channel. We can find the related implementation in node.doClose(). close() is a native function of go language, used when closing Channel.\n```go\n// doClose releases resources acquired by New(), collecting errors.\nfunc (n *Node) doClose(errs []error) error {\n // Close databases. This needs the lock because it needs to\n // synchronize with OpenDatabase*.\n n.lock.Lock()\n n.state = closedState\n errs = append(errs, n.closeDatabases()...)\n n.lock.Unlock()\n\n if err := n.accman.Close(); err != nil {\n  errs = append(errs, err)\n }\n if n.keyDirTemp {\n  if err := os.RemoveAll(n.keyDir); err != nil {\n   errs = append(errs, err)\n  }\n }\n\n // Release instance directory lock.\n n.closeDataDir()\n\n // Unblock n.Wait.\n close(n.stop)\n\n // Report any errors that might have occurred.\n switch len(errs) {\n case 0:\n  return nil\n case 1:\n  return errs[0]\n default:\n  return fmt.Errorf(\"%v\", errs)\n }\n}\n```\n\n## Ethereum Backend\nWe can find the definition of the Ethereum structure in eth/backend.go. The member variables and receiving methods contained in this structure implement all the functions and data structures required by an Ethereum full node. We can see in the following code definition that the Ethereum structure contains several core data structures such as TxPool, Blockchain, consensus.Engine, and miner as member variables.\n```go\ntype Ethereum struct {\n\tconfig *ethconfig.Config\n\n\t// Handlers\n\ttxPool             *txpool.TxPool\n\tblockchain         *core.BlockChain\n\thandler            *handler\n\tethDialCandidates  enode.Iterator\n\tsnapDialCandidates enode.Iterator\n\tmerger             *consensus.Merger\n\n\t// DB interfaces\n\tchainDb ethdb.Database // Block chain database\n\n\teventMux       *event.TypeMux\n\tengine         consensus.Engine\n\taccountManager *accounts.Manager\n\n\tbloomRequests     chan chan *bloombits.Retrieval // Channel receiving bloom data retrieval requests\n\tbloomIndexer      *core.ChainIndexer             // Bloom indexer operating during block imports\n\tcloseBloomHandler chan struct{}\n\n\tAPIBackend *EthAPIBackend\n\n\tminer     *miner.Miner\n\tgasPrice  *big.Int\n\tetherbase common.Address\n\n\tnetworkID     uint64\n\tnetRPCService *ethapi.NetAPI\n\n\tp2pServer *p2p.Server\n\n\tlock sync.RWMutex // Protects the variadic fields (e.g. gas price and etherbase)\n\n\tshutdownTracker *shutdowncheck.ShutdownTracker // Tracks if and when the node has shutdown ungracefully\n}\n```\nNodes start and stop Mining by calling `Ethereum.StartMining()` and `Ethereum.StopMining()`. Setting the profit account of Mining is achieved by calling `Ethereum.SetEtherbase()`\nHere we pay extra attention to the member variable `handler`. The definition of `handler` is in `eth/handler.go`.\nFrom a macro point of view, the main workflow of a node needs to: 1. Obtain/synchronize Transaction and Block data from the network 2. Add the Block obtained from the network to the Blockchain. The handler is responsible for providing the function of synchronizing blocks and transaction data, for example, `downloader.Downloader` is responsible for synchronizing Block from the network, and `fetcher.TxFetcher` is responsible for synchronizing transactions from the network","source":"_posts/geth.0.get.start.md","raw":"---\ntitle: geth start\ndate: 2022-11-01 18:15:12\ntags: [blockchain,geth]\n---\n\n## build from source\n```\ngit clone https://github.com/ethereum/go-ethereum.git\ncd go-ethereum\nmake geth\n```\n\n## understanding geth config\ngeth config type is defined in /cmd/geth/config.go\n```go\ntype gethConfig struct {\n\tEth      ethconfig.Config\n\tNode     node.Config\n\tEthstats ethstatsConfig\n\tMetrics  metrics.Config\n}\n```\n- **ethconfig** (eth/ethconfig/config.go)\ncontains configuration options for of the ETH and LES(light node) protocols, such as NetworkId, SyncMode, txpool.Config, database options\n- **nodeConfig** (node/config.go)\nrepresents a small collection of configuration values to fine tune the P2P network layer of a protocol stack. These values can be further extended by all registered services. such as p2p.Config, DataDir, KeyStoreDir, HTTPHost, HTTPModules(eth,net,web3), WSHost\n- **metrics.Config** (metrics/config.go)\ncontains the configuration for the metric collection, such as InfluxDBEndpoint, etc\n- **ethstatsConfig**\nonly one URL entry\n\ngeth provides default config in the above files. user config file path is given by the below flag\n```go\nconfigFileFlag = &cli.StringFlag{\n\t\tName:     \"config\",\n\t\tUsage:    \"TOML configuration file\",\n\t\tCategory: flags.EthCategory,\n\t}\n```\n\nThe config file should be a .toml file. A convenient way to create a config file is to get Geth to create one for you and use it as a template. To do this, use the dumpconfig command, saving the result to a .toml file. Note that you also need to explicitly provide the network_id on the command line for the public testnets such as Sepolia or Geoerli:\n```\n./geth --sepolia dumpconfig > geth-config.toml\n```\nto specify path to config file\n```\ngeth --sepolia --config geth-config.toml\n```\n\n## key configs\n- [Eth].TxLookupLimit \nNumber of recent blocks to maintain transactions index for (default = about one year, 0 = entire chain), default: 2350000\n- [Node].BootstrapNodes\nused to establish connectivity with the rest of the network.\ngeth provides default bootstrapNodes in file `params/bootnodes.go`\n- [Metrics_AND_STATS].ethstats\nReporting URL of a ethstats service (nodename:secret@host:port), [more detail](https://geth.ethereum.org/docs/monitoring/ethstats)\n- SyncMode\n- TrieDirtyCache\n- NoPruning\n- TrieCleanCacheJournal e.g triecache\n## how geth starts\n\n![geth starts](/images/geth_starts.drawio.png)\nthe main func is in `cmd/geth/main.go`\n```go\nfunc main() {\n\tif err := app.Run(os.Args); err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}\n```\nthe main() function is very short, and its main function is to start a tool for parsing command line commands: `gopkg.in/urfave/cli.v1`. Going deeper, we will find that `app.Action = geth` will be called when the cli app is initialized to call the geth() function\n```go\nfunc init() {\n\t// Initialize the CLI app and start Geth\n\tapp.Action = geth\n    // ....\n}\n```\ngeth is the main entry point into the system if no special subcommand is run. It creates a default node based on the command line arguments and runs it in blocking mode, waiting for it to be shut down.\n```go\nfunc geth(ctx *cli.Context) error {\n\tif args := ctx.Args().Slice(); len(args) > 0 {\n\t\treturn fmt.Errorf(\"invalid command: %q\", args[0])\n\t}\n\n\tprepare(ctx)\n\tstack, backend := makeFullNode(ctx)\n\tdefer stack.Close()\n\n\tstartNode(ctx, stack, backend, false)\n\tstack.Wait()\n\treturn nil\n}\n```\nIn the geth() function, there are three important function calls, namely: `prepare()`, `makeFullNode()`, and `startNode()`.\n\n### prepare\nThe implementation of the prepare() function is in the current main.go file. It is mainly used to set some configurations required for node initialization.\n\n### makeFullNode\nThe implementation of the `makeFullNode()` function is located in the `cmd/geth/config.go` file. It will load the context of the command and apply user given configuration; and generate instances of `stack` and `backend`. Among them, `stack` is an instance of `Node` type (Node is the top-level instance in the life cycle of geth. It is responsible for managing high-level abstractions such as P2P Server, Http Server, and Database in the node. The definition of the Node type is located in the `node/node.go` file), which is initialized by calling `makeConfigNode()` function through `makeFullNode()` function. inside `makeFullNode`, it calls `node.New(&cfg.Node)` to initiate a node. During instantiating of node, it invokes `rpc.NewServer()` to create a new rpc server and put in the field `inprocHandler`. it registers `rpc` api namespace by default.\n\nThe `backend` here is an interface of `ethapi.Backend` type, which provides the basic functions needed to obtain the runtime of the Ethereum execution layer. Its definition is located in `internal/ethapi/backend.go`. Since there are many functions in this interface, we have selected some of the key functions as below for a glimpse of its functionality. `backend` is created by calling `backend, eth := utils.RegisterEthService(stack, &cfg.Eth)`. Inside, it calls `eth.New(stack, cfg)` to create `backend` instance. During `backend` initiating, it opens database (`chainDb, err := stack.OpenDatabaseWithFreezer(\"chaindata\", config.DatabaseCache, config.DatabaseHandles, config.DatabaseFreezer, \"eth/db/chaindata/\", false)`). Further, it creates consensus engine, `engine := ethconfig.CreateConsensusEngine(stack, &ethashConfig, cliqueConfig, config.Miner.Notify, config.Miner.Noverify, chainDb)`. goerli testnet use POA consensus (clique). \n```go\ntype Backend interface {\n\tSyncProgress() ethereum.SyncProgress\n\tSuggestGasTipCap(ctx context.Context) (*big.Int, error)\n\tChainDb() ethdb.Database\n\tAccountManager() *accounts.Manager\n\tExtRPCEnabled() bool\n\tRPCGasCap() uint64            // global gas cap for eth_call over rpc: DoS protection\n\tRPCEVMTimeout() time.Duration // global timeout for eth_call over rpc: DoS protection\n\tRPCTxFeeCap() float64         // global tx fee cap for all transaction related APIs\n\tUnprotectedAllowed() bool     // allows only for EIP155 transactions.\n\tSetHead(number uint64)\n\tHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Header, error)\n\tHeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, error)\n\tHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Header, error)\n\tCurrentHeader() *types.Header\n\tCurrentBlock() *types.Header\n\tBlockByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Block, error)\n\tBlockByHash(ctx context.Context, hash common.Hash) (*types.Block, error)\n\tBlockByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Block, error)\n\tStateAndHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*state.StateDB, *types.Header, error)\n\tStateAndHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*state.StateDB, *types.Header, error)\n\tPendingBlockAndReceipts() (*types.Block, types.Receipts)\n\tGetReceipts(ctx context.Context, hash common.Hash) (types.Receipts, error)\n\tGetTd(ctx context.Context, hash common.Hash) *big.Int\n\tGetEVM(ctx context.Context, msg *core.Message, state *state.StateDB, header *types.Header, vmConfig *vm.Config) (*vm.EVM, func() error, error)\n\tSubscribeChainEvent(ch chan<- core.ChainEvent) event.Subscription\n\tSubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription\n\tSubscribeChainSideEvent(ch chan<- core.ChainSideEvent) event.Subscription\n\tSendTx(ctx context.Context, signedTx *types.Transaction) error\n\tGetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, uint64, uint64, error)\n\tGetPoolTransactions() (types.Transactions, error)\n\tGetPoolTransaction(txHash common.Hash) *types.Transaction\n\tGetPoolNonce(ctx context.Context, addr common.Address) (uint64, error)\n\tStats() (pending int, queued int)\n\tTxPoolContent() (map[common.Address]types.Transactions, map[common.Address]types.Transactions)\n\tTxPoolContentFrom(addr common.Address) (types.Transactions, types.Transactions)\n\tSubscribeNewTxsEvent(chan<- core.NewTxsEvent) event.Subscription\n\tChainConfig() *params.ChainConfig\n\tEngine() consensus.Engine\n\tGetBody(ctx context.Context, hash common.Hash, number rpc.BlockNumber) (*types.Body, error)\n\tGetLogs(ctx context.Context, blockHash common.Hash, number uint64) ([][]*types.Log, error)\n\tSubscribeRemovedLogsEvent(ch chan<- core.RemovedLogsEvent) event.Subscription\n\tSubscribeLogsEvent(ch chan<- []*types.Log) event.Subscription\n\tSubscribePendingLogsEvent(ch chan<- []*types.Log) event.Subscription\n\tBloomStatus() (uint64, uint64)\n\tServiceFilter(ctx context.Context, session *bloombits.MatcherSession)\n}\n```\n\nIf readers want to customize some new RPC APIs, they can define functions in the /internal/ethapi.Backend interface and add specific implementations to EthAPIBackend\n\n### startNode\nThe last key function, `startNode()`, is to officially start an Ethereum execution layer node. It starts the Stack instance (Node) by calling the utils.StartNode() function which triggers the Node.Start() function. In the Node.Start() function, it traverses the backend instances registered in `Node.lifecycles` and starts them. In addition, in the startNode() function, the unlockAccounts() function is still called, and the unlocked wallet is registered in the stack, and the RPClient module that interacts with local Geth is created through the stack.Attach() function\n\nAt the end of the geth() function, the function executes `stack.Wait()`, so that the main thread enters the blocking state, and the services of other functional modules are distributed to other sub-coroutines for maintenance\n\n## Node\nAs we mentioned earlier, the Node type belongs to the top-level instance in the life cycle of geth, and it is responsible for being the administrator of the high-level abstract module communicating with the outside world, such as managing rpc server, http server, Web Socket, and P2P Server external interface . At the same time, Node maintains the back-end instances and services (lifecycles []Lifecycle) required for node operation, such as the Ethereum type we mentioned above that is responsible for the specific Service\n```go\ntype Node struct {\n\teventmux      *event.TypeMux\n\tconfig        *Config\n\taccman        *accounts.Manager\n\tlog           log.Logger\n\tkeyDir        string        // key store directory\n\tkeyDirTemp    bool          // If true, key directory will be removed by Stop\n\tdirLock       *flock.Flock  // prevents concurrent use of instance directory\n\tstop          chan struct{} // Channel to wait for termination notifications\n\tserver        *p2p.Server   // Currently running P2P networking layer\n\tstartStopLock sync.Mutex    // Start/Stop are protected by an additional lock\n\tstate         int           // Tracks state of node lifecycle\n\n\tlock          sync.Mutex\n\tlifecycles    []Lifecycle // All registered backends, services, and auxiliary services that have a lifecycle\n\trpcAPIs       []rpc.API   // List of APIs currently provided by the node\n\thttp          *httpServer //\n\tws            *httpServer //\n\thttpAuth      *httpServer //\n\twsAuth        *httpServer //\n\tipc           *ipcServer  // Stores information about the ipc http server\n\tinprocHandler *rpc.Server // In-process RPC request handler to process the API requests\n\n\tdatabases map[*closeTrackingDB]struct{} // All open databases\n}\n```\n\n### close node\nAs mentioned earlier, the main thread of the entire program is blocked because of calling `stack.Wait()`. We can see that a channel called `stop` is declared in the Node structure. Since this Channel has not been assigned a value, the main process of the entire geth enters the blocking state, and continues to execute other business coroutines concurrently\n```go\n// Wait blocks until the node is closed.\nfunc (n *Node) Wait() {\n <-n.stop\n}\n```\nWhen the Channel n.stop is assigned a value, the geth main function will stop the current blocking state and start to perform a series of corresponding resource release operations.\nIt is worth noting that in the current codebase of go-ethereum, the blocking state of the main process is not ended directly by assigning a value to the stop channel, but a more concise and rude way is used: call the close() function directly Close the Channel. We can find the related implementation in node.doClose(). close() is a native function of go language, used when closing Channel.\n```go\n// doClose releases resources acquired by New(), collecting errors.\nfunc (n *Node) doClose(errs []error) error {\n // Close databases. This needs the lock because it needs to\n // synchronize with OpenDatabase*.\n n.lock.Lock()\n n.state = closedState\n errs = append(errs, n.closeDatabases()...)\n n.lock.Unlock()\n\n if err := n.accman.Close(); err != nil {\n  errs = append(errs, err)\n }\n if n.keyDirTemp {\n  if err := os.RemoveAll(n.keyDir); err != nil {\n   errs = append(errs, err)\n  }\n }\n\n // Release instance directory lock.\n n.closeDataDir()\n\n // Unblock n.Wait.\n close(n.stop)\n\n // Report any errors that might have occurred.\n switch len(errs) {\n case 0:\n  return nil\n case 1:\n  return errs[0]\n default:\n  return fmt.Errorf(\"%v\", errs)\n }\n}\n```\n\n## Ethereum Backend\nWe can find the definition of the Ethereum structure in eth/backend.go. The member variables and receiving methods contained in this structure implement all the functions and data structures required by an Ethereum full node. We can see in the following code definition that the Ethereum structure contains several core data structures such as TxPool, Blockchain, consensus.Engine, and miner as member variables.\n```go\ntype Ethereum struct {\n\tconfig *ethconfig.Config\n\n\t// Handlers\n\ttxPool             *txpool.TxPool\n\tblockchain         *core.BlockChain\n\thandler            *handler\n\tethDialCandidates  enode.Iterator\n\tsnapDialCandidates enode.Iterator\n\tmerger             *consensus.Merger\n\n\t// DB interfaces\n\tchainDb ethdb.Database // Block chain database\n\n\teventMux       *event.TypeMux\n\tengine         consensus.Engine\n\taccountManager *accounts.Manager\n\n\tbloomRequests     chan chan *bloombits.Retrieval // Channel receiving bloom data retrieval requests\n\tbloomIndexer      *core.ChainIndexer             // Bloom indexer operating during block imports\n\tcloseBloomHandler chan struct{}\n\n\tAPIBackend *EthAPIBackend\n\n\tminer     *miner.Miner\n\tgasPrice  *big.Int\n\tetherbase common.Address\n\n\tnetworkID     uint64\n\tnetRPCService *ethapi.NetAPI\n\n\tp2pServer *p2p.Server\n\n\tlock sync.RWMutex // Protects the variadic fields (e.g. gas price and etherbase)\n\n\tshutdownTracker *shutdowncheck.ShutdownTracker // Tracks if and when the node has shutdown ungracefully\n}\n```\nNodes start and stop Mining by calling `Ethereum.StartMining()` and `Ethereum.StopMining()`. Setting the profit account of Mining is achieved by calling `Ethereum.SetEtherbase()`\nHere we pay extra attention to the member variable `handler`. The definition of `handler` is in `eth/handler.go`.\nFrom a macro point of view, the main workflow of a node needs to: 1. Obtain/synchronize Transaction and Block data from the network 2. Add the Block obtained from the network to the Blockchain. The handler is responsible for providing the function of synchronizing blocks and transaction data, for example, `downloader.Downloader` is responsible for synchronizing Block from the network, and `fetcher.TxFetcher` is responsible for synchronizing transactions from the network","slug":"geth.0.get.start","published":1,"updated":"2023-04-25T14:59:44.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2ti00026usjc8dm063h","content":"<h2 id=\"build-from-source\"><a href=\"#build-from-source\" class=\"headerlink\" title=\"build from source\"></a>build from source</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/ethereum/go-ethereum.git</span><br><span class=\"line\">cd go-ethereum</span><br><span class=\"line\">make geth</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"understanding-geth-config\"><a href=\"#understanding-geth-config\" class=\"headerlink\" title=\"understanding geth config\"></a>understanding geth config</h2><p>geth config type is defined in &#x2F;cmd&#x2F;geth&#x2F;config.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> gethConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tEth      ethconfig.Config</span><br><span class=\"line\">\tNode     node.Config</span><br><span class=\"line\">\tEthstats ethstatsConfig</span><br><span class=\"line\">\tMetrics  metrics.Config</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>ethconfig</strong> (eth&#x2F;ethconfig&#x2F;config.go)<br>contains configuration options for of the ETH and LES(light node) protocols, such as NetworkId, SyncMode, txpool.Config, database options</li>\n<li><strong>nodeConfig</strong> (node&#x2F;config.go)<br>represents a small collection of configuration values to fine tune the P2P network layer of a protocol stack. These values can be further extended by all registered services. such as p2p.Config, DataDir, KeyStoreDir, HTTPHost, HTTPModules(eth,net,web3), WSHost</li>\n<li><strong>metrics.Config</strong> (metrics&#x2F;config.go)<br>contains the configuration for the metric collection, such as InfluxDBEndpoint, etc</li>\n<li><strong>ethstatsConfig</strong><br>only one URL entry</li>\n</ul>\n<p>geth provides default config in the above files. user config file path is given by the below flag</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configFileFlag = &amp;cli.StringFlag&#123;</span><br><span class=\"line\">\t\tName:     <span class=\"string\">&quot;config&quot;</span>,</span><br><span class=\"line\">\t\tUsage:    <span class=\"string\">&quot;TOML configuration file&quot;</span>,</span><br><span class=\"line\">\t\tCategory: flags.EthCategory,</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The config file should be a .toml file. A convenient way to create a config file is to get Geth to create one for you and use it as a template. To do this, use the dumpconfig command, saving the result to a .toml file. Note that you also need to explicitly provide the network_id on the command line for the public testnets such as Sepolia or Geoerli:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./geth --sepolia dumpconfig &gt; geth-config.toml</span><br></pre></td></tr></table></figure>\n<p>to specify path to config file</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">geth --sepolia --config geth-config.toml</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"key-configs\"><a href=\"#key-configs\" class=\"headerlink\" title=\"key configs\"></a>key configs</h2><ul>\n<li>[Eth].TxLookupLimit<br>Number of recent blocks to maintain transactions index for (default &#x3D; about one year, 0 &#x3D; entire chain), default: 2350000</li>\n<li>[Node].BootstrapNodes<br>used to establish connectivity with the rest of the network.<br>geth provides default bootstrapNodes in file <code>params/bootnodes.go</code></li>\n<li>[Metrics_AND_STATS].ethstats<br>Reporting URL of a ethstats service (nodename:secret@host:port), <a href=\"https://geth.ethereum.org/docs/monitoring/ethstats\">more detail</a></li>\n<li>SyncMode</li>\n<li>TrieDirtyCache</li>\n<li>NoPruning</li>\n<li>TrieCleanCacheJournal e.g triecache</li>\n</ul>\n<h2 id=\"how-geth-starts\"><a href=\"#how-geth-starts\" class=\"headerlink\" title=\"how geth starts\"></a>how geth starts</h2><p><img src=\"/images/geth_starts.drawio.png\" alt=\"geth starts\"><br>the main func is in <code>cmd/geth/main.go</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := app.Run(os.Args); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Fprintln(os.Stderr, err)</span><br><span class=\"line\">\t\tos.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>the main() function is very short, and its main function is to start a tool for parsing command line commands: <code>gopkg.in/urfave/cli.v1</code>. Going deeper, we will find that <code>app.Action = geth</code> will be called when the cli app is initialized to call the geth() function</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Initialize the CLI app and start Geth</span></span><br><span class=\"line\">\tapp.Action = geth</span><br><span class=\"line\">    <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>geth is the main entry point into the system if no special subcommand is run. It creates a default node based on the command line arguments and runs it in blocking mode, waiting for it to be shut down.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">geth</span><span class=\"params\">(ctx *cli.Context)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> args := ctx.Args().Slice(); <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;invalid command: %q&quot;</span>, args[<span class=\"number\">0</span>])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprepare(ctx)</span><br><span class=\"line\">\tstack, backend := makeFullNode(ctx)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> stack.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tstartNode(ctx, stack, backend, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\tstack.Wait()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>In the geth() function, there are three important function calls, namely: <code>prepare()</code>, <code>makeFullNode()</code>, and <code>startNode()</code>.</p>\n<h3 id=\"prepare\"><a href=\"#prepare\" class=\"headerlink\" title=\"prepare\"></a>prepare</h3><p>The implementation of the prepare() function is in the current main.go file. It is mainly used to set some configurations required for node initialization.</p>\n<h3 id=\"makeFullNode\"><a href=\"#makeFullNode\" class=\"headerlink\" title=\"makeFullNode\"></a>makeFullNode</h3><p>The implementation of the <code>makeFullNode()</code> function is located in the <code>cmd/geth/config.go</code> file. It will load the context of the command and apply user given configuration; and generate instances of <code>stack</code> and <code>backend</code>. Among them, <code>stack</code> is an instance of <code>Node</code> type (Node is the top-level instance in the life cycle of geth. It is responsible for managing high-level abstractions such as P2P Server, Http Server, and Database in the node. The definition of the Node type is located in the <code>node/node.go</code> file), which is initialized by calling <code>makeConfigNode()</code> function through <code>makeFullNode()</code> function. inside <code>makeFullNode</code>, it calls <code>node.New(&amp;cfg.Node)</code> to initiate a node. During instantiating of node, it invokes <code>rpc.NewServer()</code> to create a new rpc server and put in the field <code>inprocHandler</code>. it registers <code>rpc</code> api namespace by default.</p>\n<p>The <code>backend</code> here is an interface of <code>ethapi.Backend</code> type, which provides the basic functions needed to obtain the runtime of the Ethereum execution layer. Its definition is located in <code>internal/ethapi/backend.go</code>. Since there are many functions in this interface, we have selected some of the key functions as below for a glimpse of its functionality. <code>backend</code> is created by calling <code>backend, eth := utils.RegisterEthService(stack, &amp;cfg.Eth)</code>. Inside, it calls <code>eth.New(stack, cfg)</code> to create <code>backend</code> instance. During <code>backend</code> initiating, it opens database (<code>chainDb, err := stack.OpenDatabaseWithFreezer(&quot;chaindata&quot;, config.DatabaseCache, config.DatabaseHandles, config.DatabaseFreezer, &quot;eth/db/chaindata/&quot;, false)</code>). Further, it creates consensus engine, <code>engine := ethconfig.CreateConsensusEngine(stack, &amp;ethashConfig, cliqueConfig, config.Miner.Notify, config.Miner.Noverify, chainDb)</code>. goerli testnet use POA consensus (clique). </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Backend <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tSyncProgress() ethereum.SyncProgress</span><br><span class=\"line\">\tSuggestGasTipCap(ctx context.Context) (*big.Int, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tChainDb() ethdb.Database</span><br><span class=\"line\">\tAccountManager() *accounts.Manager</span><br><span class=\"line\">\tExtRPCEnabled() <span class=\"type\">bool</span></span><br><span class=\"line\">\tRPCGasCap() <span class=\"type\">uint64</span>            <span class=\"comment\">// global gas cap for eth_call over rpc: DoS protection</span></span><br><span class=\"line\">\tRPCEVMTimeout() time.Duration <span class=\"comment\">// global timeout for eth_call over rpc: DoS protection</span></span><br><span class=\"line\">\tRPCTxFeeCap() <span class=\"type\">float64</span>         <span class=\"comment\">// global tx fee cap for all transaction related APIs</span></span><br><span class=\"line\">\tUnprotectedAllowed() <span class=\"type\">bool</span>     <span class=\"comment\">// allows only for EIP155 transactions.</span></span><br><span class=\"line\">\tSetHead(number <span class=\"type\">uint64</span>)</span><br><span class=\"line\">\tHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tHeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tCurrentHeader() *types.Header</span><br><span class=\"line\">\tCurrentBlock() *types.Header</span><br><span class=\"line\">\tBlockByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Block, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tBlockByHash(ctx context.Context, hash common.Hash) (*types.Block, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tBlockByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Block, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tStateAndHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*state.StateDB, *types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tStateAndHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*state.StateDB, *types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tPendingBlockAndReceipts() (*types.Block, types.Receipts)</span><br><span class=\"line\">\tGetReceipts(ctx context.Context, hash common.Hash) (types.Receipts, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tGetTd(ctx context.Context, hash common.Hash) *big.Int</span><br><span class=\"line\">\tGetEVM(ctx context.Context, msg *core.Message, state *state.StateDB, header *types.Header, vmConfig *vm.Config) (*vm.EVM, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">error</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tSubscribeChainEvent(ch <span class=\"keyword\">chan</span>&lt;- core.ChainEvent) event.Subscription</span><br><span class=\"line\">\tSubscribeChainHeadEvent(ch <span class=\"keyword\">chan</span>&lt;- core.ChainHeadEvent) event.Subscription</span><br><span class=\"line\">\tSubscribeChainSideEvent(ch <span class=\"keyword\">chan</span>&lt;- core.ChainSideEvent) event.Subscription</span><br><span class=\"line\">\tSendTx(ctx context.Context, signedTx *types.Transaction) <span class=\"type\">error</span></span><br><span class=\"line\">\tGetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, <span class=\"type\">uint64</span>, <span class=\"type\">uint64</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tGetPoolTransactions() (types.Transactions, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tGetPoolTransaction(txHash common.Hash) *types.Transaction</span><br><span class=\"line\">\tGetPoolNonce(ctx context.Context, addr common.Address) (<span class=\"type\">uint64</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tStats() (pending <span class=\"type\">int</span>, queued <span class=\"type\">int</span>)</span><br><span class=\"line\">\tTxPoolContent() (<span class=\"keyword\">map</span>[common.Address]types.Transactions, <span class=\"keyword\">map</span>[common.Address]types.Transactions)</span><br><span class=\"line\">\tTxPoolContentFrom(addr common.Address) (types.Transactions, types.Transactions)</span><br><span class=\"line\">\tSubscribeNewTxsEvent(<span class=\"keyword\">chan</span>&lt;- core.NewTxsEvent) event.Subscription</span><br><span class=\"line\">\tChainConfig() *params.ChainConfig</span><br><span class=\"line\">\tEngine() consensus.Engine</span><br><span class=\"line\">\tGetBody(ctx context.Context, hash common.Hash, number rpc.BlockNumber) (*types.Body, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tGetLogs(ctx context.Context, blockHash common.Hash, number <span class=\"type\">uint64</span>) ([][]*types.Log, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tSubscribeRemovedLogsEvent(ch <span class=\"keyword\">chan</span>&lt;- core.RemovedLogsEvent) event.Subscription</span><br><span class=\"line\">\tSubscribeLogsEvent(ch <span class=\"keyword\">chan</span>&lt;- []*types.Log) event.Subscription</span><br><span class=\"line\">\tSubscribePendingLogsEvent(ch <span class=\"keyword\">chan</span>&lt;- []*types.Log) event.Subscription</span><br><span class=\"line\">\tBloomStatus() (<span class=\"type\">uint64</span>, <span class=\"type\">uint64</span>)</span><br><span class=\"line\">\tServiceFilter(ctx context.Context, session *bloombits.MatcherSession)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>If readers want to customize some new RPC APIs, they can define functions in the &#x2F;internal&#x2F;ethapi.Backend interface and add specific implementations to EthAPIBackend</p>\n<h3 id=\"startNode\"><a href=\"#startNode\" class=\"headerlink\" title=\"startNode\"></a>startNode</h3><p>The last key function, <code>startNode()</code>, is to officially start an Ethereum execution layer node. It starts the Stack instance (Node) by calling the utils.StartNode() function which triggers the Node.Start() function. In the Node.Start() function, it traverses the backend instances registered in <code>Node.lifecycles</code> and starts them. In addition, in the startNode() function, the unlockAccounts() function is still called, and the unlocked wallet is registered in the stack, and the RPClient module that interacts with local Geth is created through the stack.Attach() function</p>\n<p>At the end of the geth() function, the function executes <code>stack.Wait()</code>, so that the main thread enters the blocking state, and the services of other functional modules are distributed to other sub-coroutines for maintenance</p>\n<h2 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h2><p>As we mentioned earlier, the Node type belongs to the top-level instance in the life cycle of geth, and it is responsible for being the administrator of the high-level abstract module communicating with the outside world, such as managing rpc server, http server, Web Socket, and P2P Server external interface . At the same time, Node maintains the back-end instances and services (lifecycles []Lifecycle) required for node operation, such as the Ethereum type we mentioned above that is responsible for the specific Service</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\teventmux      *event.TypeMux</span><br><span class=\"line\">\tconfig        *Config</span><br><span class=\"line\">\taccman        *accounts.Manager</span><br><span class=\"line\">\tlog           log.Logger</span><br><span class=\"line\">\tkeyDir        <span class=\"type\">string</span>        <span class=\"comment\">// key store directory</span></span><br><span class=\"line\">\tkeyDirTemp    <span class=\"type\">bool</span>          <span class=\"comment\">// If true, key directory will be removed by Stop</span></span><br><span class=\"line\">\tdirLock       *flock.Flock  <span class=\"comment\">// prevents concurrent use of instance directory</span></span><br><span class=\"line\">\tstop          <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125; <span class=\"comment\">// Channel to wait for termination notifications</span></span><br><span class=\"line\">\tserver        *p2p.Server   <span class=\"comment\">// Currently running P2P networking layer</span></span><br><span class=\"line\">\tstartStopLock sync.Mutex    <span class=\"comment\">// Start/Stop are protected by an additional lock</span></span><br><span class=\"line\">\tstate         <span class=\"type\">int</span>           <span class=\"comment\">// Tracks state of node lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlock          sync.Mutex</span><br><span class=\"line\">\tlifecycles    []Lifecycle <span class=\"comment\">// All registered backends, services, and auxiliary services that have a lifecycle</span></span><br><span class=\"line\">\trpcAPIs       []rpc.API   <span class=\"comment\">// List of APIs currently provided by the node</span></span><br><span class=\"line\">\thttp          *httpServer <span class=\"comment\">//</span></span><br><span class=\"line\">\tws            *httpServer <span class=\"comment\">//</span></span><br><span class=\"line\">\thttpAuth      *httpServer <span class=\"comment\">//</span></span><br><span class=\"line\">\twsAuth        *httpServer <span class=\"comment\">//</span></span><br><span class=\"line\">\tipc           *ipcServer  <span class=\"comment\">// Stores information about the ipc http server</span></span><br><span class=\"line\">\tinprocHandler *rpc.Server <span class=\"comment\">// In-process RPC request handler to process the API requests</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tdatabases <span class=\"keyword\">map</span>[*closeTrackingDB]<span class=\"keyword\">struct</span>&#123;&#125; <span class=\"comment\">// All open databases</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"close-node\"><a href=\"#close-node\" class=\"headerlink\" title=\"close node\"></a>close node</h3><p>As mentioned earlier, the main thread of the entire program is blocked because of calling <code>stack.Wait()</code>. We can see that a channel called <code>stop</code> is declared in the Node structure. Since this Channel has not been assigned a value, the main process of the entire geth enters the blocking state, and continues to execute other business coroutines concurrently</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Wait blocks until the node is closed.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *Node)</span></span> Wait() &#123;</span><br><span class=\"line\"> &lt;-n.stop</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>When the Channel n.stop is assigned a value, the geth main function will stop the current blocking state and start to perform a series of corresponding resource release operations.<br>It is worth noting that in the current codebase of go-ethereum, the blocking state of the main process is not ended directly by assigning a value to the stop channel, but a more concise and rude way is used: call the close() function directly Close the Channel. We can find the related implementation in node.doClose(). close() is a native function of go language, used when closing Channel.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// doClose releases resources acquired by New(), collecting errors.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *Node)</span></span> doClose(errs []<span class=\"type\">error</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// Close databases. This needs the lock because it needs to</span></span><br><span class=\"line\"> <span class=\"comment\">// synchronize with OpenDatabase*.</span></span><br><span class=\"line\"> n.lock.Lock()</span><br><span class=\"line\"> n.state = closedState</span><br><span class=\"line\"> errs = <span class=\"built_in\">append</span>(errs, n.closeDatabases()...)</span><br><span class=\"line\"> n.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> err := n.accman.Close(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">  errs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> n.keyDirTemp &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := os.RemoveAll(n.keyDir); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">   errs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// Release instance directory lock.</span></span><br><span class=\"line\"> n.closeDataDir()</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// Unblock n.Wait.</span></span><br><span class=\"line\"> <span class=\"built_in\">close</span>(n.stop)</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// Report any errors that might have occurred.</span></span><br><span class=\"line\"> <span class=\"keyword\">switch</span> <span class=\"built_in\">len</span>(errs) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errs[<span class=\"number\">0</span>]</span><br><span class=\"line\"> <span class=\"keyword\">default</span>:</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%v&quot;</span>, errs)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ethereum-Backend\"><a href=\"#Ethereum-Backend\" class=\"headerlink\" title=\"Ethereum Backend\"></a>Ethereum Backend</h2><p>We can find the definition of the Ethereum structure in eth&#x2F;backend.go. The member variables and receiving methods contained in this structure implement all the functions and data structures required by an Ethereum full node. We can see in the following code definition that the Ethereum structure contains several core data structures such as TxPool, Blockchain, consensus.Engine, and miner as member variables.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Ethereum <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tconfig *ethconfig.Config</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Handlers</span></span><br><span class=\"line\">\ttxPool             *txpool.TxPool</span><br><span class=\"line\">\tblockchain         *core.BlockChain</span><br><span class=\"line\">\thandler            *handler</span><br><span class=\"line\">\tethDialCandidates  enode.Iterator</span><br><span class=\"line\">\tsnapDialCandidates enode.Iterator</span><br><span class=\"line\">\tmerger             *consensus.Merger</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// DB interfaces</span></span><br><span class=\"line\">\tchainDb ethdb.Database <span class=\"comment\">// Block chain database</span></span><br><span class=\"line\"></span><br><span class=\"line\">\teventMux       *event.TypeMux</span><br><span class=\"line\">\tengine         consensus.Engine</span><br><span class=\"line\">\taccountManager *accounts.Manager</span><br><span class=\"line\"></span><br><span class=\"line\">\tbloomRequests     <span class=\"keyword\">chan</span> <span class=\"keyword\">chan</span> *bloombits.Retrieval <span class=\"comment\">// Channel receiving bloom data retrieval requests</span></span><br><span class=\"line\">\tbloomIndexer      *core.ChainIndexer             <span class=\"comment\">// Bloom indexer operating during block imports</span></span><br><span class=\"line\">\tcloseBloomHandler <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAPIBackend *EthAPIBackend</span><br><span class=\"line\"></span><br><span class=\"line\">\tminer     *miner.Miner</span><br><span class=\"line\">\tgasPrice  *big.Int</span><br><span class=\"line\">\tetherbase common.Address</span><br><span class=\"line\"></span><br><span class=\"line\">\tnetworkID     <span class=\"type\">uint64</span></span><br><span class=\"line\">\tnetRPCService *ethapi.NetAPI</span><br><span class=\"line\"></span><br><span class=\"line\">\tp2pServer *p2p.Server</span><br><span class=\"line\"></span><br><span class=\"line\">\tlock sync.RWMutex <span class=\"comment\">// Protects the variadic fields (e.g. gas price and etherbase)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tshutdownTracker *shutdowncheck.ShutdownTracker <span class=\"comment\">// Tracks if and when the node has shutdown ungracefully</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Nodes start and stop Mining by calling <code>Ethereum.StartMining()</code> and <code>Ethereum.StopMining()</code>. Setting the profit account of Mining is achieved by calling <code>Ethereum.SetEtherbase()</code><br>Here we pay extra attention to the member variable <code>handler</code>. The definition of <code>handler</code> is in <code>eth/handler.go</code>.<br>From a macro point of view, the main workflow of a node needs to: 1. Obtain&#x2F;synchronize Transaction and Block data from the network 2. Add the Block obtained from the network to the Blockchain. The handler is responsible for providing the function of synchronizing blocks and transaction data, for example, <code>downloader.Downloader</code> is responsible for synchronizing Block from the network, and <code>fetcher.TxFetcher</code> is responsible for synchronizing transactions from the network</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"build-from-source\"><a href=\"#build-from-source\" class=\"headerlink\" title=\"build from source\"></a>build from source</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/ethereum/go-ethereum.git</span><br><span class=\"line\">cd go-ethereum</span><br><span class=\"line\">make geth</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"understanding-geth-config\"><a href=\"#understanding-geth-config\" class=\"headerlink\" title=\"understanding geth config\"></a>understanding geth config</h2><p>geth config type is defined in &#x2F;cmd&#x2F;geth&#x2F;config.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> gethConfig <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tEth      ethconfig.Config</span><br><span class=\"line\">\tNode     node.Config</span><br><span class=\"line\">\tEthstats ethstatsConfig</span><br><span class=\"line\">\tMetrics  metrics.Config</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>ethconfig</strong> (eth&#x2F;ethconfig&#x2F;config.go)<br>contains configuration options for of the ETH and LES(light node) protocols, such as NetworkId, SyncMode, txpool.Config, database options</li>\n<li><strong>nodeConfig</strong> (node&#x2F;config.go)<br>represents a small collection of configuration values to fine tune the P2P network layer of a protocol stack. These values can be further extended by all registered services. such as p2p.Config, DataDir, KeyStoreDir, HTTPHost, HTTPModules(eth,net,web3), WSHost</li>\n<li><strong>metrics.Config</strong> (metrics&#x2F;config.go)<br>contains the configuration for the metric collection, such as InfluxDBEndpoint, etc</li>\n<li><strong>ethstatsConfig</strong><br>only one URL entry</li>\n</ul>\n<p>geth provides default config in the above files. user config file path is given by the below flag</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configFileFlag = &amp;cli.StringFlag&#123;</span><br><span class=\"line\">\t\tName:     <span class=\"string\">&quot;config&quot;</span>,</span><br><span class=\"line\">\t\tUsage:    <span class=\"string\">&quot;TOML configuration file&quot;</span>,</span><br><span class=\"line\">\t\tCategory: flags.EthCategory,</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The config file should be a .toml file. A convenient way to create a config file is to get Geth to create one for you and use it as a template. To do this, use the dumpconfig command, saving the result to a .toml file. Note that you also need to explicitly provide the network_id on the command line for the public testnets such as Sepolia or Geoerli:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./geth --sepolia dumpconfig &gt; geth-config.toml</span><br></pre></td></tr></table></figure>\n<p>to specify path to config file</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">geth --sepolia --config geth-config.toml</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"key-configs\"><a href=\"#key-configs\" class=\"headerlink\" title=\"key configs\"></a>key configs</h2><ul>\n<li>[Eth].TxLookupLimit<br>Number of recent blocks to maintain transactions index for (default &#x3D; about one year, 0 &#x3D; entire chain), default: 2350000</li>\n<li>[Node].BootstrapNodes<br>used to establish connectivity with the rest of the network.<br>geth provides default bootstrapNodes in file <code>params/bootnodes.go</code></li>\n<li>[Metrics_AND_STATS].ethstats<br>Reporting URL of a ethstats service (nodename:secret@host:port), <a href=\"https://geth.ethereum.org/docs/monitoring/ethstats\">more detail</a></li>\n<li>SyncMode</li>\n<li>TrieDirtyCache</li>\n<li>NoPruning</li>\n<li>TrieCleanCacheJournal e.g triecache</li>\n</ul>\n<h2 id=\"how-geth-starts\"><a href=\"#how-geth-starts\" class=\"headerlink\" title=\"how geth starts\"></a>how geth starts</h2><p><img src=\"/images/geth_starts.drawio.png\" alt=\"geth starts\"><br>the main func is in <code>cmd/geth/main.go</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := app.Run(os.Args); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Fprintln(os.Stderr, err)</span><br><span class=\"line\">\t\tos.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>the main() function is very short, and its main function is to start a tool for parsing command line commands: <code>gopkg.in/urfave/cli.v1</code>. Going deeper, we will find that <code>app.Action = geth</code> will be called when the cli app is initialized to call the geth() function</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Initialize the CLI app and start Geth</span></span><br><span class=\"line\">\tapp.Action = geth</span><br><span class=\"line\">    <span class=\"comment\">// ....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>geth is the main entry point into the system if no special subcommand is run. It creates a default node based on the command line arguments and runs it in blocking mode, waiting for it to be shut down.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">geth</span><span class=\"params\">(ctx *cli.Context)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> args := ctx.Args().Slice(); <span class=\"built_in\">len</span>(args) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;invalid command: %q&quot;</span>, args[<span class=\"number\">0</span>])</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprepare(ctx)</span><br><span class=\"line\">\tstack, backend := makeFullNode(ctx)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> stack.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tstartNode(ctx, stack, backend, <span class=\"literal\">false</span>)</span><br><span class=\"line\">\tstack.Wait()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>In the geth() function, there are three important function calls, namely: <code>prepare()</code>, <code>makeFullNode()</code>, and <code>startNode()</code>.</p>\n<h3 id=\"prepare\"><a href=\"#prepare\" class=\"headerlink\" title=\"prepare\"></a>prepare</h3><p>The implementation of the prepare() function is in the current main.go file. It is mainly used to set some configurations required for node initialization.</p>\n<h3 id=\"makeFullNode\"><a href=\"#makeFullNode\" class=\"headerlink\" title=\"makeFullNode\"></a>makeFullNode</h3><p>The implementation of the <code>makeFullNode()</code> function is located in the <code>cmd/geth/config.go</code> file. It will load the context of the command and apply user given configuration; and generate instances of <code>stack</code> and <code>backend</code>. Among them, <code>stack</code> is an instance of <code>Node</code> type (Node is the top-level instance in the life cycle of geth. It is responsible for managing high-level abstractions such as P2P Server, Http Server, and Database in the node. The definition of the Node type is located in the <code>node/node.go</code> file), which is initialized by calling <code>makeConfigNode()</code> function through <code>makeFullNode()</code> function. inside <code>makeFullNode</code>, it calls <code>node.New(&amp;cfg.Node)</code> to initiate a node. During instantiating of node, it invokes <code>rpc.NewServer()</code> to create a new rpc server and put in the field <code>inprocHandler</code>. it registers <code>rpc</code> api namespace by default.</p>\n<p>The <code>backend</code> here is an interface of <code>ethapi.Backend</code> type, which provides the basic functions needed to obtain the runtime of the Ethereum execution layer. Its definition is located in <code>internal/ethapi/backend.go</code>. Since there are many functions in this interface, we have selected some of the key functions as below for a glimpse of its functionality. <code>backend</code> is created by calling <code>backend, eth := utils.RegisterEthService(stack, &amp;cfg.Eth)</code>. Inside, it calls <code>eth.New(stack, cfg)</code> to create <code>backend</code> instance. During <code>backend</code> initiating, it opens database (<code>chainDb, err := stack.OpenDatabaseWithFreezer(&quot;chaindata&quot;, config.DatabaseCache, config.DatabaseHandles, config.DatabaseFreezer, &quot;eth/db/chaindata/&quot;, false)</code>). Further, it creates consensus engine, <code>engine := ethconfig.CreateConsensusEngine(stack, &amp;ethashConfig, cliqueConfig, config.Miner.Notify, config.Miner.Noverify, chainDb)</code>. goerli testnet use POA consensus (clique). </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Backend <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tSyncProgress() ethereum.SyncProgress</span><br><span class=\"line\">\tSuggestGasTipCap(ctx context.Context) (*big.Int, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tChainDb() ethdb.Database</span><br><span class=\"line\">\tAccountManager() *accounts.Manager</span><br><span class=\"line\">\tExtRPCEnabled() <span class=\"type\">bool</span></span><br><span class=\"line\">\tRPCGasCap() <span class=\"type\">uint64</span>            <span class=\"comment\">// global gas cap for eth_call over rpc: DoS protection</span></span><br><span class=\"line\">\tRPCEVMTimeout() time.Duration <span class=\"comment\">// global timeout for eth_call over rpc: DoS protection</span></span><br><span class=\"line\">\tRPCTxFeeCap() <span class=\"type\">float64</span>         <span class=\"comment\">// global tx fee cap for all transaction related APIs</span></span><br><span class=\"line\">\tUnprotectedAllowed() <span class=\"type\">bool</span>     <span class=\"comment\">// allows only for EIP155 transactions.</span></span><br><span class=\"line\">\tSetHead(number <span class=\"type\">uint64</span>)</span><br><span class=\"line\">\tHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tHeaderByHash(ctx context.Context, hash common.Hash) (*types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tCurrentHeader() *types.Header</span><br><span class=\"line\">\tCurrentBlock() *types.Header</span><br><span class=\"line\">\tBlockByNumber(ctx context.Context, number rpc.BlockNumber) (*types.Block, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tBlockByHash(ctx context.Context, hash common.Hash) (*types.Block, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tBlockByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*types.Block, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tStateAndHeaderByNumber(ctx context.Context, number rpc.BlockNumber) (*state.StateDB, *types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tStateAndHeaderByNumberOrHash(ctx context.Context, blockNrOrHash rpc.BlockNumberOrHash) (*state.StateDB, *types.Header, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tPendingBlockAndReceipts() (*types.Block, types.Receipts)</span><br><span class=\"line\">\tGetReceipts(ctx context.Context, hash common.Hash) (types.Receipts, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tGetTd(ctx context.Context, hash common.Hash) *big.Int</span><br><span class=\"line\">\tGetEVM(ctx context.Context, msg *core.Message, state *state.StateDB, header *types.Header, vmConfig *vm.Config) (*vm.EVM, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"type\">error</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tSubscribeChainEvent(ch <span class=\"keyword\">chan</span>&lt;- core.ChainEvent) event.Subscription</span><br><span class=\"line\">\tSubscribeChainHeadEvent(ch <span class=\"keyword\">chan</span>&lt;- core.ChainHeadEvent) event.Subscription</span><br><span class=\"line\">\tSubscribeChainSideEvent(ch <span class=\"keyword\">chan</span>&lt;- core.ChainSideEvent) event.Subscription</span><br><span class=\"line\">\tSendTx(ctx context.Context, signedTx *types.Transaction) <span class=\"type\">error</span></span><br><span class=\"line\">\tGetTransaction(ctx context.Context, txHash common.Hash) (*types.Transaction, common.Hash, <span class=\"type\">uint64</span>, <span class=\"type\">uint64</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tGetPoolTransactions() (types.Transactions, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tGetPoolTransaction(txHash common.Hash) *types.Transaction</span><br><span class=\"line\">\tGetPoolNonce(ctx context.Context, addr common.Address) (<span class=\"type\">uint64</span>, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tStats() (pending <span class=\"type\">int</span>, queued <span class=\"type\">int</span>)</span><br><span class=\"line\">\tTxPoolContent() (<span class=\"keyword\">map</span>[common.Address]types.Transactions, <span class=\"keyword\">map</span>[common.Address]types.Transactions)</span><br><span class=\"line\">\tTxPoolContentFrom(addr common.Address) (types.Transactions, types.Transactions)</span><br><span class=\"line\">\tSubscribeNewTxsEvent(<span class=\"keyword\">chan</span>&lt;- core.NewTxsEvent) event.Subscription</span><br><span class=\"line\">\tChainConfig() *params.ChainConfig</span><br><span class=\"line\">\tEngine() consensus.Engine</span><br><span class=\"line\">\tGetBody(ctx context.Context, hash common.Hash, number rpc.BlockNumber) (*types.Body, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tGetLogs(ctx context.Context, blockHash common.Hash, number <span class=\"type\">uint64</span>) ([][]*types.Log, <span class=\"type\">error</span>)</span><br><span class=\"line\">\tSubscribeRemovedLogsEvent(ch <span class=\"keyword\">chan</span>&lt;- core.RemovedLogsEvent) event.Subscription</span><br><span class=\"line\">\tSubscribeLogsEvent(ch <span class=\"keyword\">chan</span>&lt;- []*types.Log) event.Subscription</span><br><span class=\"line\">\tSubscribePendingLogsEvent(ch <span class=\"keyword\">chan</span>&lt;- []*types.Log) event.Subscription</span><br><span class=\"line\">\tBloomStatus() (<span class=\"type\">uint64</span>, <span class=\"type\">uint64</span>)</span><br><span class=\"line\">\tServiceFilter(ctx context.Context, session *bloombits.MatcherSession)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>If readers want to customize some new RPC APIs, they can define functions in the &#x2F;internal&#x2F;ethapi.Backend interface and add specific implementations to EthAPIBackend</p>\n<h3 id=\"startNode\"><a href=\"#startNode\" class=\"headerlink\" title=\"startNode\"></a>startNode</h3><p>The last key function, <code>startNode()</code>, is to officially start an Ethereum execution layer node. It starts the Stack instance (Node) by calling the utils.StartNode() function which triggers the Node.Start() function. In the Node.Start() function, it traverses the backend instances registered in <code>Node.lifecycles</code> and starts them. In addition, in the startNode() function, the unlockAccounts() function is still called, and the unlocked wallet is registered in the stack, and the RPClient module that interacts with local Geth is created through the stack.Attach() function</p>\n<p>At the end of the geth() function, the function executes <code>stack.Wait()</code>, so that the main thread enters the blocking state, and the services of other functional modules are distributed to other sub-coroutines for maintenance</p>\n<h2 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h2><p>As we mentioned earlier, the Node type belongs to the top-level instance in the life cycle of geth, and it is responsible for being the administrator of the high-level abstract module communicating with the outside world, such as managing rpc server, http server, Web Socket, and P2P Server external interface . At the same time, Node maintains the back-end instances and services (lifecycles []Lifecycle) required for node operation, such as the Ethereum type we mentioned above that is responsible for the specific Service</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\teventmux      *event.TypeMux</span><br><span class=\"line\">\tconfig        *Config</span><br><span class=\"line\">\taccman        *accounts.Manager</span><br><span class=\"line\">\tlog           log.Logger</span><br><span class=\"line\">\tkeyDir        <span class=\"type\">string</span>        <span class=\"comment\">// key store directory</span></span><br><span class=\"line\">\tkeyDirTemp    <span class=\"type\">bool</span>          <span class=\"comment\">// If true, key directory will be removed by Stop</span></span><br><span class=\"line\">\tdirLock       *flock.Flock  <span class=\"comment\">// prevents concurrent use of instance directory</span></span><br><span class=\"line\">\tstop          <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125; <span class=\"comment\">// Channel to wait for termination notifications</span></span><br><span class=\"line\">\tserver        *p2p.Server   <span class=\"comment\">// Currently running P2P networking layer</span></span><br><span class=\"line\">\tstartStopLock sync.Mutex    <span class=\"comment\">// Start/Stop are protected by an additional lock</span></span><br><span class=\"line\">\tstate         <span class=\"type\">int</span>           <span class=\"comment\">// Tracks state of node lifecycle</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tlock          sync.Mutex</span><br><span class=\"line\">\tlifecycles    []Lifecycle <span class=\"comment\">// All registered backends, services, and auxiliary services that have a lifecycle</span></span><br><span class=\"line\">\trpcAPIs       []rpc.API   <span class=\"comment\">// List of APIs currently provided by the node</span></span><br><span class=\"line\">\thttp          *httpServer <span class=\"comment\">//</span></span><br><span class=\"line\">\tws            *httpServer <span class=\"comment\">//</span></span><br><span class=\"line\">\thttpAuth      *httpServer <span class=\"comment\">//</span></span><br><span class=\"line\">\twsAuth        *httpServer <span class=\"comment\">//</span></span><br><span class=\"line\">\tipc           *ipcServer  <span class=\"comment\">// Stores information about the ipc http server</span></span><br><span class=\"line\">\tinprocHandler *rpc.Server <span class=\"comment\">// In-process RPC request handler to process the API requests</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tdatabases <span class=\"keyword\">map</span>[*closeTrackingDB]<span class=\"keyword\">struct</span>&#123;&#125; <span class=\"comment\">// All open databases</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"close-node\"><a href=\"#close-node\" class=\"headerlink\" title=\"close node\"></a>close node</h3><p>As mentioned earlier, the main thread of the entire program is blocked because of calling <code>stack.Wait()</code>. We can see that a channel called <code>stop</code> is declared in the Node structure. Since this Channel has not been assigned a value, the main process of the entire geth enters the blocking state, and continues to execute other business coroutines concurrently</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Wait blocks until the node is closed.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *Node)</span></span> Wait() &#123;</span><br><span class=\"line\"> &lt;-n.stop</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>When the Channel n.stop is assigned a value, the geth main function will stop the current blocking state and start to perform a series of corresponding resource release operations.<br>It is worth noting that in the current codebase of go-ethereum, the blocking state of the main process is not ended directly by assigning a value to the stop channel, but a more concise and rude way is used: call the close() function directly Close the Channel. We can find the related implementation in node.doClose(). close() is a native function of go language, used when closing Channel.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// doClose releases resources acquired by New(), collecting errors.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *Node)</span></span> doClose(errs []<span class=\"type\">error</span>) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\"> <span class=\"comment\">// Close databases. This needs the lock because it needs to</span></span><br><span class=\"line\"> <span class=\"comment\">// synchronize with OpenDatabase*.</span></span><br><span class=\"line\"> n.lock.Lock()</span><br><span class=\"line\"> n.state = closedState</span><br><span class=\"line\"> errs = <span class=\"built_in\">append</span>(errs, n.closeDatabases()...)</span><br><span class=\"line\"> n.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">if</span> err := n.accman.Close(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">  errs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> n.keyDirTemp &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err := os.RemoveAll(n.keyDir); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">   errs = <span class=\"built_in\">append</span>(errs, err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// Release instance directory lock.</span></span><br><span class=\"line\"> n.closeDataDir()</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// Unblock n.Wait.</span></span><br><span class=\"line\"> <span class=\"built_in\">close</span>(n.stop)</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// Report any errors that might have occurred.</span></span><br><span class=\"line\"> <span class=\"keyword\">switch</span> <span class=\"built_in\">len</span>(errs) &#123;</span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\"> <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">  <span class=\"keyword\">return</span> errs[<span class=\"number\">0</span>]</span><br><span class=\"line\"> <span class=\"keyword\">default</span>:</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%v&quot;</span>, errs)</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Ethereum-Backend\"><a href=\"#Ethereum-Backend\" class=\"headerlink\" title=\"Ethereum Backend\"></a>Ethereum Backend</h2><p>We can find the definition of the Ethereum structure in eth&#x2F;backend.go. The member variables and receiving methods contained in this structure implement all the functions and data structures required by an Ethereum full node. We can see in the following code definition that the Ethereum structure contains several core data structures such as TxPool, Blockchain, consensus.Engine, and miner as member variables.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Ethereum <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tconfig *ethconfig.Config</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Handlers</span></span><br><span class=\"line\">\ttxPool             *txpool.TxPool</span><br><span class=\"line\">\tblockchain         *core.BlockChain</span><br><span class=\"line\">\thandler            *handler</span><br><span class=\"line\">\tethDialCandidates  enode.Iterator</span><br><span class=\"line\">\tsnapDialCandidates enode.Iterator</span><br><span class=\"line\">\tmerger             *consensus.Merger</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// DB interfaces</span></span><br><span class=\"line\">\tchainDb ethdb.Database <span class=\"comment\">// Block chain database</span></span><br><span class=\"line\"></span><br><span class=\"line\">\teventMux       *event.TypeMux</span><br><span class=\"line\">\tengine         consensus.Engine</span><br><span class=\"line\">\taccountManager *accounts.Manager</span><br><span class=\"line\"></span><br><span class=\"line\">\tbloomRequests     <span class=\"keyword\">chan</span> <span class=\"keyword\">chan</span> *bloombits.Retrieval <span class=\"comment\">// Channel receiving bloom data retrieval requests</span></span><br><span class=\"line\">\tbloomIndexer      *core.ChainIndexer             <span class=\"comment\">// Bloom indexer operating during block imports</span></span><br><span class=\"line\">\tcloseBloomHandler <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAPIBackend *EthAPIBackend</span><br><span class=\"line\"></span><br><span class=\"line\">\tminer     *miner.Miner</span><br><span class=\"line\">\tgasPrice  *big.Int</span><br><span class=\"line\">\tetherbase common.Address</span><br><span class=\"line\"></span><br><span class=\"line\">\tnetworkID     <span class=\"type\">uint64</span></span><br><span class=\"line\">\tnetRPCService *ethapi.NetAPI</span><br><span class=\"line\"></span><br><span class=\"line\">\tp2pServer *p2p.Server</span><br><span class=\"line\"></span><br><span class=\"line\">\tlock sync.RWMutex <span class=\"comment\">// Protects the variadic fields (e.g. gas price and etherbase)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tshutdownTracker *shutdowncheck.ShutdownTracker <span class=\"comment\">// Tracks if and when the node has shutdown ungracefully</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Nodes start and stop Mining by calling <code>Ethereum.StartMining()</code> and <code>Ethereum.StopMining()</code>. Setting the profit account of Mining is achieved by calling <code>Ethereum.SetEtherbase()</code><br>Here we pay extra attention to the member variable <code>handler</code>. The definition of <code>handler</code> is in <code>eth/handler.go</code>.<br>From a macro point of view, the main workflow of a node needs to: 1. Obtain&#x2F;synchronize Transaction and Block data from the network 2. Add the Block obtained from the network to the Blockchain. The handler is responsible for providing the function of synchronizing blocks and transaction data, for example, <code>downloader.Downloader</code> is responsible for synchronizing Block from the network, and <code>fetcher.TxFetcher</code> is responsible for synchronizing transactions from the network</p>\n"},{"title":"rpc","date":"2022-11-08T06:23:08.000Z","_content":"\n\n## overview\npackage rpc implements bi-directional JSON-RPC 2.0 on multiple transports (http, ws, ipc). After creating a server or client instance, objects can be registered to make them visible as 'services'. Exported methods that follow specific conventions can be called remotely. It also has support for the publish/subscribe pattern.\n\n## methods\n### rpc endpoints (callback)\nMethods that satisfy the following criteria are made available for remote access:\n  - method must be exported\n  - method returns 0, 1 (response or error) or 2 (response and error) values\n\nThe server offers the ServeCodec method which accepts a ServerCodec instance. It will read requests from the codec, process the request and sends the response back to the client using the codec. The server can execute requests concurrently. Responses can be sent back to the client out of order.\n\nAn example server which uses the JSON codec:\n```go\ntype CalculatorService struct {}\n\nfunc (s *CalculatorService) Add(a, b int) int {\n    return a + b\n}\n\nfunc (s *CalculatorService) Div(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New(\"divide by zero\")\n    }\n    return a/b, nil\n}\n\ncalculator := new(CalculatorService)\nserver := NewServer()\nserver.RegisterName(\"calculator\", calculator)\nl, _ := net.ListenUnix(\"unix\", &net.UnixAddr{Net: \"unix\", Name: \"/tmp/calculator.sock\"})\nserver.ServeListener(l)\n```\n\n### subscriptions\nThe package also supports the publish subscribe pattern through the use of subscriptions.\nA method that is considered eligible for notifications must satisfy the following\ncriteria:\n  - method must be exported\n  - first method argument type must be context.Context\n  - method must have return types (rpc.Subscription, error)\n\nAn example method:\n```go\nfunc (s *BlockChainService) NewBlocks(ctx context.Context) (rpc.Subscription, error) {\n\t\t...\n\t}\n```\n\n### Reverse Calls\nIn any method handler, an instance of rpc.Client can be accessed through the `ClientFromContext` method. Using this client instance, server-to-client method calls can be performed on the RPC connection.\n\n## server\nto start rpc service, the invoking chain is as below\n```\nnode/node.go[func (n *Node) Start()] -> node/node.go[func (n *Node) openEndpoints()] -> node/node.go[func (n *Node) startRPC()]\n```\n\n### API registration\n","source":"_posts/geth.1.rpc.md","raw":"---\ntitle: rpc\ndate: 2022-11-08 14:23:08\ntags: [blockchain, geth]\n---\n\n\n## overview\npackage rpc implements bi-directional JSON-RPC 2.0 on multiple transports (http, ws, ipc). After creating a server or client instance, objects can be registered to make them visible as 'services'. Exported methods that follow specific conventions can be called remotely. It also has support for the publish/subscribe pattern.\n\n## methods\n### rpc endpoints (callback)\nMethods that satisfy the following criteria are made available for remote access:\n  - method must be exported\n  - method returns 0, 1 (response or error) or 2 (response and error) values\n\nThe server offers the ServeCodec method which accepts a ServerCodec instance. It will read requests from the codec, process the request and sends the response back to the client using the codec. The server can execute requests concurrently. Responses can be sent back to the client out of order.\n\nAn example server which uses the JSON codec:\n```go\ntype CalculatorService struct {}\n\nfunc (s *CalculatorService) Add(a, b int) int {\n    return a + b\n}\n\nfunc (s *CalculatorService) Div(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New(\"divide by zero\")\n    }\n    return a/b, nil\n}\n\ncalculator := new(CalculatorService)\nserver := NewServer()\nserver.RegisterName(\"calculator\", calculator)\nl, _ := net.ListenUnix(\"unix\", &net.UnixAddr{Net: \"unix\", Name: \"/tmp/calculator.sock\"})\nserver.ServeListener(l)\n```\n\n### subscriptions\nThe package also supports the publish subscribe pattern through the use of subscriptions.\nA method that is considered eligible for notifications must satisfy the following\ncriteria:\n  - method must be exported\n  - first method argument type must be context.Context\n  - method must have return types (rpc.Subscription, error)\n\nAn example method:\n```go\nfunc (s *BlockChainService) NewBlocks(ctx context.Context) (rpc.Subscription, error) {\n\t\t...\n\t}\n```\n\n### Reverse Calls\nIn any method handler, an instance of rpc.Client can be accessed through the `ClientFromContext` method. Using this client instance, server-to-client method calls can be performed on the RPC connection.\n\n## server\nto start rpc service, the invoking chain is as below\n```\nnode/node.go[func (n *Node) Start()] -> node/node.go[func (n *Node) openEndpoints()] -> node/node.go[func (n *Node) startRPC()]\n```\n\n### API registration\n","slug":"geth.1.rpc","published":1,"updated":"2023-04-27T16:54:24.069Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tj00046usj9cm2fgsm","content":"<h2 id=\"overview\"><a href=\"#overview\" class=\"headerlink\" title=\"overview\"></a>overview</h2><p>package rpc implements bi-directional JSON-RPC 2.0 on multiple transports (http, ws, ipc). After creating a server or client instance, objects can be registered to make them visible as ‘services’. Exported methods that follow specific conventions can be called remotely. It also has support for the publish&#x2F;subscribe pattern.</p>\n<h2 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h2><h3 id=\"rpc-endpoints-callback\"><a href=\"#rpc-endpoints-callback\" class=\"headerlink\" title=\"rpc endpoints (callback)\"></a>rpc endpoints (callback)</h3><p>Methods that satisfy the following criteria are made available for remote access:</p>\n<ul>\n<li>method must be exported</li>\n<li>method returns 0, 1 (response or error) or 2 (response and error) values</li>\n</ul>\n<p>The server offers the ServeCodec method which accepts a ServerCodec instance. It will read requests from the codec, process the request and sends the response back to the client using the codec. The server can execute requests concurrently. Responses can be sent back to the client out of order.</p>\n<p>An example server which uses the JSON codec:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CalculatorService <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *CalculatorService)</span></span> Add(a, b <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *CalculatorService)</span></span> Div(a, b <span class=\"type\">int</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, errors.New(<span class=\"string\">&quot;divide by zero&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a/b, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">calculator := <span class=\"built_in\">new</span>(CalculatorService)</span><br><span class=\"line\">server := NewServer()</span><br><span class=\"line\">server.RegisterName(<span class=\"string\">&quot;calculator&quot;</span>, calculator)</span><br><span class=\"line\">l, _ := net.ListenUnix(<span class=\"string\">&quot;unix&quot;</span>, &amp;net.UnixAddr&#123;Net: <span class=\"string\">&quot;unix&quot;</span>, Name: <span class=\"string\">&quot;/tmp/calculator.sock&quot;</span>&#125;)</span><br><span class=\"line\">server.ServeListener(l)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"subscriptions\"><a href=\"#subscriptions\" class=\"headerlink\" title=\"subscriptions\"></a>subscriptions</h3><p>The package also supports the publish subscribe pattern through the use of subscriptions.<br>A method that is considered eligible for notifications must satisfy the following<br>criteria:</p>\n<ul>\n<li>method must be exported</li>\n<li>first method argument type must be context.Context</li>\n<li>method must have return types (rpc.Subscription, error)</li>\n</ul>\n<p>An example method:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *BlockChainService)</span></span> NewBlocks(ctx context.Context) (rpc.Subscription, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Reverse-Calls\"><a href=\"#Reverse-Calls\" class=\"headerlink\" title=\"Reverse Calls\"></a>Reverse Calls</h3><p>In any method handler, an instance of rpc.Client can be accessed through the <code>ClientFromContext</code> method. Using this client instance, server-to-client method calls can be performed on the RPC connection.</p>\n<h2 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h2><p>to start rpc service, the invoking chain is as below</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node/node.go[func (n *Node) Start()] -&gt; node/node.go[func (n *Node) openEndpoints()] -&gt; node/node.go[func (n *Node) startRPC()]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"API-registration\"><a href=\"#API-registration\" class=\"headerlink\" title=\"API registration\"></a>API registration</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"overview\"><a href=\"#overview\" class=\"headerlink\" title=\"overview\"></a>overview</h2><p>package rpc implements bi-directional JSON-RPC 2.0 on multiple transports (http, ws, ipc). After creating a server or client instance, objects can be registered to make them visible as ‘services’. Exported methods that follow specific conventions can be called remotely. It also has support for the publish&#x2F;subscribe pattern.</p>\n<h2 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h2><h3 id=\"rpc-endpoints-callback\"><a href=\"#rpc-endpoints-callback\" class=\"headerlink\" title=\"rpc endpoints (callback)\"></a>rpc endpoints (callback)</h3><p>Methods that satisfy the following criteria are made available for remote access:</p>\n<ul>\n<li>method must be exported</li>\n<li>method returns 0, 1 (response or error) or 2 (response and error) values</li>\n</ul>\n<p>The server offers the ServeCodec method which accepts a ServerCodec instance. It will read requests from the codec, process the request and sends the response back to the client using the codec. The server can execute requests concurrently. Responses can be sent back to the client out of order.</p>\n<p>An example server which uses the JSON codec:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> CalculatorService <span class=\"keyword\">struct</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *CalculatorService)</span></span> Add(a, b <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *CalculatorService)</span></span> Div(a, b <span class=\"type\">int</span>) (<span class=\"type\">int</span>, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>, errors.New(<span class=\"string\">&quot;divide by zero&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a/b, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">calculator := <span class=\"built_in\">new</span>(CalculatorService)</span><br><span class=\"line\">server := NewServer()</span><br><span class=\"line\">server.RegisterName(<span class=\"string\">&quot;calculator&quot;</span>, calculator)</span><br><span class=\"line\">l, _ := net.ListenUnix(<span class=\"string\">&quot;unix&quot;</span>, &amp;net.UnixAddr&#123;Net: <span class=\"string\">&quot;unix&quot;</span>, Name: <span class=\"string\">&quot;/tmp/calculator.sock&quot;</span>&#125;)</span><br><span class=\"line\">server.ServeListener(l)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"subscriptions\"><a href=\"#subscriptions\" class=\"headerlink\" title=\"subscriptions\"></a>subscriptions</h3><p>The package also supports the publish subscribe pattern through the use of subscriptions.<br>A method that is considered eligible for notifications must satisfy the following<br>criteria:</p>\n<ul>\n<li>method must be exported</li>\n<li>first method argument type must be context.Context</li>\n<li>method must have return types (rpc.Subscription, error)</li>\n</ul>\n<p>An example method:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *BlockChainService)</span></span> NewBlocks(ctx context.Context) (rpc.Subscription, <span class=\"type\">error</span>) &#123;</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Reverse-Calls\"><a href=\"#Reverse-Calls\" class=\"headerlink\" title=\"Reverse Calls\"></a>Reverse Calls</h3><p>In any method handler, an instance of rpc.Client can be accessed through the <code>ClientFromContext</code> method. Using this client instance, server-to-client method calls can be performed on the RPC connection.</p>\n<h2 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h2><p>to start rpc service, the invoking chain is as below</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node/node.go[func (n *Node) Start()] -&gt; node/node.go[func (n *Node) openEndpoints()] -&gt; node/node.go[func (n *Node) startRPC()]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"API-registration\"><a href=\"#API-registration\" class=\"headerlink\" title=\"API registration\"></a>API registration</h3>"},{"title":"geth_fine_tune","date":"2023-01-01T08:29:43.000Z","_content":"\n\nIf we're a full node on mainnet without --cache specified, bump default cache allowance\nctx.Set(utils.CacheFlag.Name, strconv.Itoa(4096))","source":"_posts/geth-fine-tune.md","raw":"---\ntitle: geth_fine_tune\ndate: 2023-01-01 16:29:43\ntags:\n---\n\n\nIf we're a full node on mainnet without --cache specified, bump default cache allowance\nctx.Set(utils.CacheFlag.Name, strconv.Itoa(4096))","slug":"geth-fine-tune","published":1,"updated":"2023-04-25T09:48:14.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tk00056usjfz194rqp","content":"<p>If we’re a full node on mainnet without –cache specified, bump default cache allowance<br>ctx.Set(utils.CacheFlag.Name, strconv.Itoa(4096))</p>\n","site":{"data":{}},"excerpt":"","more":"<p>If we’re a full node on mainnet without –cache specified, bump default cache allowance<br>ctx.Set(utils.CacheFlag.Name, strconv.Itoa(4096))</p>\n"},{"title":"geth evm source analysis","date":"2023-01-08T08:24:54.000Z","_content":"\n# overall\nthe code is under path `core/vm`\noverview of the whole evm module ![evm](/images/evm.drawio.google.png)\n\nthe core is `EVM` struct (in evm.go), with main function in creating or call contract. a new `EVM` object is created every time when processing a transaction. inside the EVM struct, the main items are `Interpreter`, and `StateDB` (for state persistence). `Interpreter` loops through contract call instructions.Before each instruction is executed, some checks are performed to ensure sufficient gas and stack space. actual instruction execution code is recorded in `JumpTable` (256 sized array of `operation`)\n\ndepending on the version of Ethereum, JumpTable may point to four different instruction sets: constantinopleInstructionSet, byzantiumInstructionSet, homesteadInstructionSet, frontierInstructionSet. Most of the instructions of these four sets of instruction sets are the same, but as the version is updated, the new version supports more instruction sets than the old version.\n\n# evm\nThe `EVM` object is the most important object exported by the evm module, which represents an Ethereum virtual machine\n\n## creating evm\nEvery time a transaction is processed, an EVM is created to execute the transaction. This is reflected in the function `ApplyTransaction` (core/state_processor.go)\n\n## creating contract\nIf the `to` of the transaction is empty, it means that this transaction is to create a contract, so call `EVM.Create` to perform related functions\n- CREATE\n```\ncontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n```\n- CREATE2\n```\ncodeAndHash := &codeAndHash{code: code}\n\tcontractAddr = crypto.CreateAddress2(caller.Address(), salt.Bytes32(), codeAndHash.Hash().Bytes())\n```\nduring create contract, an object `Contract` is created. A Contract object contains and maintains the necessary information during the execution of the contract, such as the contract creator, the address of the contract itself, the remaining gas of the contract, the contract code and the `jumpdests` record of the code.\n\nthen, it invokes below method to create contract\n```\nret, err := evm.interpreter.Run(contract, nil, false)\nevm.StateDB.SetCode(address, ret)\n```\nIf the operation is successful and the contract code does not exceed the length limit, call StateDB.SetCode to store the contract code in the contract account of the Ethereum state database. Of course, the storage needs to consume a certain amount of gas.\n\nYou may wonder why the stored contract code is the return code after the contract runs, not the data in the original transaction (ie Transaction.data.Payload). This is because when the contract source code is compiled into binary data, in addition to the original code of the contract, the compiler also inserts some codes to perform related functions. For creation, the compiler inserts code that executes the contract's \"constructor\" (that is, the contract object's constructor method). Therefore, when the binary compiled by the compiler is submitted to the Ethereum node to create a contract, the EVM executes this binary code, in fact, it mainly executes the constructor method of the contract, and then returns other codes of the contract, so there is a `ret` variable here Stored in the state database as the actual code of the contract\n\n## call contract\nThe EVM object has three methods to implement the call of the contract, they are:\n\n- EVM. Call\n- EVM. CallCode\n- EVM. DelegateCall\n- EVM.StaticCall\nThe basic contract call function implemented by EVM.Call is nothing special. The following three calling methods are the differences compared with EVM.Call. So here we only introduce the particularity of the last three calling methods\n\n### EVM.CallCode & EVM.DelegateCall\nThe existence of EVM.CallCode and EVM.DelegateCall is to realize the characteristics of the \"library\" of the contract. If the code written by solidity is to be called as a library, it must be deployed on the blockchain to obtain a fixed address like a normal contract. , other contracts can call the method provided by this \"library contract\". But the contract also involves some unique attributes, such as the caller of the contract, contract address, the amount of ether it owns, etc. If we directly call the code of the \"library contract\", these properties must be the properties of the \"library contract\" itself, but this may not be what we want\n\nas an example\n```\nA -> contractB - delegateCall -> libC\n```\n`EVM.DelegateCall` sets the caller (msg.sender) of the \"library contract\" (libC) to A, rather than contractB; sets the address of the \"library contract\" (libC) to contractB. \n`EVM.CallCode` is similar to `EVM.DelegateCall`. the only difference is that `EVM.CallCode` only change the address of the \"library contract\" (libC) to contractB, without chanding the caller to A.\n`EVM.StaticCall` is similar to `EVM.Call`, the only difference is that EVM.StaticCall does not allow execution of instructions that modify permanently stored data\n\nduring contract call, it first check whether it is precompiled contract. some precompiled contracts are\n- common.BytesToAddress([]byte{1}): &ecrecover{},\n- common.BytesToAddress([]byte{2}): &sha256hash{},\n- common.BytesToAddress([]byte{3}): &ripemd160hash{},\n- common.BytesToAddress([]byte{4}): &dataCopy{},\n\n# EVMInterpreter\nThe interpreter object EVMInterpreter is used to interpret and execute specified contract instructions. However, note that the actual instruction interpretation and execution is not really completed by the interpreter object, but by the operation object JumpTable. The interpreter object is only responsible for parsing instruction codes one by one, and then obtains the corresponding operation object, and check objects such as the stack before calling the operation.execute function that actually executre the instruction. It can also be said that the interpreter object is only responsible for the scheduling of interpretation.\n\n## execution layout\n![layout](/images/evm.layout.png)\n\n## intrinsic gas\nThe intrinsic gas for a transaction is the amount of gas that the transaction uses before any code runs. It is a constant transaction fee (currently 21000 gas) plus a fee for every byte of data supplied with the transaction (4 gas for a zero byte, 68 gas for non-zeros). These constants are all currently defined for geth in params/protocol_params.go.\n\n## gas cost\nthe gas cost of each instruction is stored in `JumpTable.operation.dynamicGas` or `JumpTable.operation.constantGas`. constantGas means the operation gas cost is a fixed constant. dynamicGas is a function which will return gas during runtime.\n\nIn fact, not only the interpretation and execution of the instruction itself consumes gas, but also consumes gas when using memory storage and StateDB permanent storage. For most instructions, the latter two are not used (memory & storage), but for some instructions (such as CODECOPY or SSTORE), their gasCost function will take memory and StateDB usage into account.\n\na method `memoryGasCost`is used to calculate the gas consumption of memory usage. only when the required space size exceeds the current space size, the excess part needs to consume gas.\n\n# JumpTable\njumptable is 256 sized array of `operation`\n\n## jump instruction\nAmong the instructions of the contract, there are two jump instructions (excluding CALL): JUMP and JUMPI. Their special feature is that the first instruction of the target address after the jump must be JUMPDEST\n```\nfunc opJump(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {\n    pos := stack.pop()\n    if !contract.validJumpdest(pos) {\n        nop := contract.GetOp(pos.Uint64())\n        return nil, fmt.Errorf(\"invalid jump destination (%v) %v\", nop, pos)\n    }\n    *pc = pos.Uint64()\n\n    interpreter.intPool.put(pos)\n    return nil, nil\n}\n```\nA function interprets and executes the JUMP instruction. The code first fetches a value from the stack as the jump destination. This value is actually an offset relative to field 0 of the contract code. Then the code will call Contract.validJumpdest to determine whether the first instruction of this destination is JUMPDEST, if it is not, an error will occur.\n\nTo judge whether the first instruction of the destination is JUMPDEST, two points must be guaranteed: first, its value is the value of the opcode of the JUMPDEST instruction; second, it is an instruction, not ordinary data.\n\nLet's introduce how Contract.validJumpdest works. In addition to comparing opcode (this is very simple), Contract will also create a bit vector object (ie bitvec, bit vector). This object will analyze the contract instructions from the beginning to the end. If the byte at a certain offset of the contract belongs to ordinary data, the \"bit\" corresponding to the offset value in bitvec is set to 1, and if it is an instruction, it is set to 0. In Contract.validJumpdest, it is judged whether this is a normal instruction by checking whether the \"bit\" of the offset value of the jump destination in this bit vector object is 0\n\n# references\n- [yangzhe_blog](https://yangzhe.me/2019/08/12/ethereum-evm/#%E8%A7%A3%E9%87%8A%E5%99%A8%E5%AF%B9%E8%B1%A1evminterpreter)\n- [op code manual](https://www.evm.codes/?fork=shanghai)","source":"_posts/geth.evm.md","raw":"---\ntitle: geth evm source analysis\ndate: 2023-01-08 16:24:54\ntags: [blockchain,geth]\n---\n\n# overall\nthe code is under path `core/vm`\noverview of the whole evm module ![evm](/images/evm.drawio.google.png)\n\nthe core is `EVM` struct (in evm.go), with main function in creating or call contract. a new `EVM` object is created every time when processing a transaction. inside the EVM struct, the main items are `Interpreter`, and `StateDB` (for state persistence). `Interpreter` loops through contract call instructions.Before each instruction is executed, some checks are performed to ensure sufficient gas and stack space. actual instruction execution code is recorded in `JumpTable` (256 sized array of `operation`)\n\ndepending on the version of Ethereum, JumpTable may point to four different instruction sets: constantinopleInstructionSet, byzantiumInstructionSet, homesteadInstructionSet, frontierInstructionSet. Most of the instructions of these four sets of instruction sets are the same, but as the version is updated, the new version supports more instruction sets than the old version.\n\n# evm\nThe `EVM` object is the most important object exported by the evm module, which represents an Ethereum virtual machine\n\n## creating evm\nEvery time a transaction is processed, an EVM is created to execute the transaction. This is reflected in the function `ApplyTransaction` (core/state_processor.go)\n\n## creating contract\nIf the `to` of the transaction is empty, it means that this transaction is to create a contract, so call `EVM.Create` to perform related functions\n- CREATE\n```\ncontractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))\n```\n- CREATE2\n```\ncodeAndHash := &codeAndHash{code: code}\n\tcontractAddr = crypto.CreateAddress2(caller.Address(), salt.Bytes32(), codeAndHash.Hash().Bytes())\n```\nduring create contract, an object `Contract` is created. A Contract object contains and maintains the necessary information during the execution of the contract, such as the contract creator, the address of the contract itself, the remaining gas of the contract, the contract code and the `jumpdests` record of the code.\n\nthen, it invokes below method to create contract\n```\nret, err := evm.interpreter.Run(contract, nil, false)\nevm.StateDB.SetCode(address, ret)\n```\nIf the operation is successful and the contract code does not exceed the length limit, call StateDB.SetCode to store the contract code in the contract account of the Ethereum state database. Of course, the storage needs to consume a certain amount of gas.\n\nYou may wonder why the stored contract code is the return code after the contract runs, not the data in the original transaction (ie Transaction.data.Payload). This is because when the contract source code is compiled into binary data, in addition to the original code of the contract, the compiler also inserts some codes to perform related functions. For creation, the compiler inserts code that executes the contract's \"constructor\" (that is, the contract object's constructor method). Therefore, when the binary compiled by the compiler is submitted to the Ethereum node to create a contract, the EVM executes this binary code, in fact, it mainly executes the constructor method of the contract, and then returns other codes of the contract, so there is a `ret` variable here Stored in the state database as the actual code of the contract\n\n## call contract\nThe EVM object has three methods to implement the call of the contract, they are:\n\n- EVM. Call\n- EVM. CallCode\n- EVM. DelegateCall\n- EVM.StaticCall\nThe basic contract call function implemented by EVM.Call is nothing special. The following three calling methods are the differences compared with EVM.Call. So here we only introduce the particularity of the last three calling methods\n\n### EVM.CallCode & EVM.DelegateCall\nThe existence of EVM.CallCode and EVM.DelegateCall is to realize the characteristics of the \"library\" of the contract. If the code written by solidity is to be called as a library, it must be deployed on the blockchain to obtain a fixed address like a normal contract. , other contracts can call the method provided by this \"library contract\". But the contract also involves some unique attributes, such as the caller of the contract, contract address, the amount of ether it owns, etc. If we directly call the code of the \"library contract\", these properties must be the properties of the \"library contract\" itself, but this may not be what we want\n\nas an example\n```\nA -> contractB - delegateCall -> libC\n```\n`EVM.DelegateCall` sets the caller (msg.sender) of the \"library contract\" (libC) to A, rather than contractB; sets the address of the \"library contract\" (libC) to contractB. \n`EVM.CallCode` is similar to `EVM.DelegateCall`. the only difference is that `EVM.CallCode` only change the address of the \"library contract\" (libC) to contractB, without chanding the caller to A.\n`EVM.StaticCall` is similar to `EVM.Call`, the only difference is that EVM.StaticCall does not allow execution of instructions that modify permanently stored data\n\nduring contract call, it first check whether it is precompiled contract. some precompiled contracts are\n- common.BytesToAddress([]byte{1}): &ecrecover{},\n- common.BytesToAddress([]byte{2}): &sha256hash{},\n- common.BytesToAddress([]byte{3}): &ripemd160hash{},\n- common.BytesToAddress([]byte{4}): &dataCopy{},\n\n# EVMInterpreter\nThe interpreter object EVMInterpreter is used to interpret and execute specified contract instructions. However, note that the actual instruction interpretation and execution is not really completed by the interpreter object, but by the operation object JumpTable. The interpreter object is only responsible for parsing instruction codes one by one, and then obtains the corresponding operation object, and check objects such as the stack before calling the operation.execute function that actually executre the instruction. It can also be said that the interpreter object is only responsible for the scheduling of interpretation.\n\n## execution layout\n![layout](/images/evm.layout.png)\n\n## intrinsic gas\nThe intrinsic gas for a transaction is the amount of gas that the transaction uses before any code runs. It is a constant transaction fee (currently 21000 gas) plus a fee for every byte of data supplied with the transaction (4 gas for a zero byte, 68 gas for non-zeros). These constants are all currently defined for geth in params/protocol_params.go.\n\n## gas cost\nthe gas cost of each instruction is stored in `JumpTable.operation.dynamicGas` or `JumpTable.operation.constantGas`. constantGas means the operation gas cost is a fixed constant. dynamicGas is a function which will return gas during runtime.\n\nIn fact, not only the interpretation and execution of the instruction itself consumes gas, but also consumes gas when using memory storage and StateDB permanent storage. For most instructions, the latter two are not used (memory & storage), but for some instructions (such as CODECOPY or SSTORE), their gasCost function will take memory and StateDB usage into account.\n\na method `memoryGasCost`is used to calculate the gas consumption of memory usage. only when the required space size exceeds the current space size, the excess part needs to consume gas.\n\n# JumpTable\njumptable is 256 sized array of `operation`\n\n## jump instruction\nAmong the instructions of the contract, there are two jump instructions (excluding CALL): JUMP and JUMPI. Their special feature is that the first instruction of the target address after the jump must be JUMPDEST\n```\nfunc opJump(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {\n    pos := stack.pop()\n    if !contract.validJumpdest(pos) {\n        nop := contract.GetOp(pos.Uint64())\n        return nil, fmt.Errorf(\"invalid jump destination (%v) %v\", nop, pos)\n    }\n    *pc = pos.Uint64()\n\n    interpreter.intPool.put(pos)\n    return nil, nil\n}\n```\nA function interprets and executes the JUMP instruction. The code first fetches a value from the stack as the jump destination. This value is actually an offset relative to field 0 of the contract code. Then the code will call Contract.validJumpdest to determine whether the first instruction of this destination is JUMPDEST, if it is not, an error will occur.\n\nTo judge whether the first instruction of the destination is JUMPDEST, two points must be guaranteed: first, its value is the value of the opcode of the JUMPDEST instruction; second, it is an instruction, not ordinary data.\n\nLet's introduce how Contract.validJumpdest works. In addition to comparing opcode (this is very simple), Contract will also create a bit vector object (ie bitvec, bit vector). This object will analyze the contract instructions from the beginning to the end. If the byte at a certain offset of the contract belongs to ordinary data, the \"bit\" corresponding to the offset value in bitvec is set to 1, and if it is an instruction, it is set to 0. In Contract.validJumpdest, it is judged whether this is a normal instruction by checking whether the \"bit\" of the offset value of the jump destination in this bit vector object is 0\n\n# references\n- [yangzhe_blog](https://yangzhe.me/2019/08/12/ethereum-evm/#%E8%A7%A3%E9%87%8A%E5%99%A8%E5%AF%B9%E8%B1%A1evminterpreter)\n- [op code manual](https://www.evm.codes/?fork=shanghai)","slug":"geth.evm","published":1,"updated":"2023-04-14T03:02:06.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tk00066usjhifj5ge1","content":"<h1 id=\"overall\"><a href=\"#overall\" class=\"headerlink\" title=\"overall\"></a>overall</h1><p>the code is under path <code>core/vm</code><br>overview of the whole evm module <img src=\"/images/evm.drawio.google.png\" alt=\"evm\"></p>\n<p>the core is <code>EVM</code> struct (in evm.go), with main function in creating or call contract. a new <code>EVM</code> object is created every time when processing a transaction. inside the EVM struct, the main items are <code>Interpreter</code>, and <code>StateDB</code> (for state persistence). <code>Interpreter</code> loops through contract call instructions.Before each instruction is executed, some checks are performed to ensure sufficient gas and stack space. actual instruction execution code is recorded in <code>JumpTable</code> (256 sized array of <code>operation</code>)</p>\n<p>depending on the version of Ethereum, JumpTable may point to four different instruction sets: constantinopleInstructionSet, byzantiumInstructionSet, homesteadInstructionSet, frontierInstructionSet. Most of the instructions of these four sets of instruction sets are the same, but as the version is updated, the new version supports more instruction sets than the old version.</p>\n<h1 id=\"evm\"><a href=\"#evm\" class=\"headerlink\" title=\"evm\"></a>evm</h1><p>The <code>EVM</code> object is the most important object exported by the evm module, which represents an Ethereum virtual machine</p>\n<h2 id=\"creating-evm\"><a href=\"#creating-evm\" class=\"headerlink\" title=\"creating evm\"></a>creating evm</h2><p>Every time a transaction is processed, an EVM is created to execute the transaction. This is reflected in the function <code>ApplyTransaction</code> (core&#x2F;state_processor.go)</p>\n<h2 id=\"creating-contract\"><a href=\"#creating-contract\" class=\"headerlink\" title=\"creating contract\"></a>creating contract</h2><p>If the <code>to</code> of the transaction is empty, it means that this transaction is to create a contract, so call <code>EVM.Create</code> to perform related functions</p>\n<ul>\n<li>CREATE<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))</span><br></pre></td></tr></table></figure></li>\n<li>CREATE2<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codeAndHash := &amp;codeAndHash&#123;code: code&#125;</span><br><span class=\"line\">\tcontractAddr = crypto.CreateAddress2(caller.Address(), salt.Bytes32(), codeAndHash.Hash().Bytes())</span><br></pre></td></tr></table></figure>\nduring create contract, an object <code>Contract</code> is created. A Contract object contains and maintains the necessary information during the execution of the contract, such as the contract creator, the address of the contract itself, the remaining gas of the contract, the contract code and the <code>jumpdests</code> record of the code.</li>\n</ul>\n<p>then, it invokes below method to create contract</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret, err := evm.interpreter.Run(contract, nil, false)</span><br><span class=\"line\">evm.StateDB.SetCode(address, ret)</span><br></pre></td></tr></table></figure>\n<p>If the operation is successful and the contract code does not exceed the length limit, call StateDB.SetCode to store the contract code in the contract account of the Ethereum state database. Of course, the storage needs to consume a certain amount of gas.</p>\n<p>You may wonder why the stored contract code is the return code after the contract runs, not the data in the original transaction (ie Transaction.data.Payload). This is because when the contract source code is compiled into binary data, in addition to the original code of the contract, the compiler also inserts some codes to perform related functions. For creation, the compiler inserts code that executes the contract’s “constructor” (that is, the contract object’s constructor method). Therefore, when the binary compiled by the compiler is submitted to the Ethereum node to create a contract, the EVM executes this binary code, in fact, it mainly executes the constructor method of the contract, and then returns other codes of the contract, so there is a <code>ret</code> variable here Stored in the state database as the actual code of the contract</p>\n<h2 id=\"call-contract\"><a href=\"#call-contract\" class=\"headerlink\" title=\"call contract\"></a>call contract</h2><p>The EVM object has three methods to implement the call of the contract, they are:</p>\n<ul>\n<li>EVM. Call</li>\n<li>EVM. CallCode</li>\n<li>EVM. DelegateCall</li>\n<li>EVM.StaticCall<br>The basic contract call function implemented by EVM.Call is nothing special. The following three calling methods are the differences compared with EVM.Call. So here we only introduce the particularity of the last three calling methods</li>\n</ul>\n<h3 id=\"EVM-CallCode-amp-EVM-DelegateCall\"><a href=\"#EVM-CallCode-amp-EVM-DelegateCall\" class=\"headerlink\" title=\"EVM.CallCode &amp; EVM.DelegateCall\"></a>EVM.CallCode &amp; EVM.DelegateCall</h3><p>The existence of EVM.CallCode and EVM.DelegateCall is to realize the characteristics of the “library” of the contract. If the code written by solidity is to be called as a library, it must be deployed on the blockchain to obtain a fixed address like a normal contract. , other contracts can call the method provided by this “library contract”. But the contract also involves some unique attributes, such as the caller of the contract, contract address, the amount of ether it owns, etc. If we directly call the code of the “library contract”, these properties must be the properties of the “library contract” itself, but this may not be what we want</p>\n<p>as an example</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A -&gt; contractB - delegateCall -&gt; libC</span><br></pre></td></tr></table></figure>\n<p><code>EVM.DelegateCall</code> sets the caller (msg.sender) of the “library contract” (libC) to A, rather than contractB; sets the address of the “library contract” (libC) to contractB.<br><code>EVM.CallCode</code> is similar to <code>EVM.DelegateCall</code>. the only difference is that <code>EVM.CallCode</code> only change the address of the “library contract” (libC) to contractB, without chanding the caller to A.<br><code>EVM.StaticCall</code> is similar to <code>EVM.Call</code>, the only difference is that EVM.StaticCall does not allow execution of instructions that modify permanently stored data</p>\n<p>during contract call, it first check whether it is precompiled contract. some precompiled contracts are</p>\n<ul>\n<li>common.BytesToAddress([]byte{1}): &amp;ecrecover{},</li>\n<li>common.BytesToAddress([]byte{2}): &amp;sha256hash{},</li>\n<li>common.BytesToAddress([]byte{3}): &amp;ripemd160hash{},</li>\n<li>common.BytesToAddress([]byte{4}): &amp;dataCopy{},</li>\n</ul>\n<h1 id=\"EVMInterpreter\"><a href=\"#EVMInterpreter\" class=\"headerlink\" title=\"EVMInterpreter\"></a>EVMInterpreter</h1><p>The interpreter object EVMInterpreter is used to interpret and execute specified contract instructions. However, note that the actual instruction interpretation and execution is not really completed by the interpreter object, but by the operation object JumpTable. The interpreter object is only responsible for parsing instruction codes one by one, and then obtains the corresponding operation object, and check objects such as the stack before calling the operation.execute function that actually executre the instruction. It can also be said that the interpreter object is only responsible for the scheduling of interpretation.</p>\n<h2 id=\"execution-layout\"><a href=\"#execution-layout\" class=\"headerlink\" title=\"execution layout\"></a>execution layout</h2><p><img src=\"/images/evm.layout.png\" alt=\"layout\"></p>\n<h2 id=\"intrinsic-gas\"><a href=\"#intrinsic-gas\" class=\"headerlink\" title=\"intrinsic gas\"></a>intrinsic gas</h2><p>The intrinsic gas for a transaction is the amount of gas that the transaction uses before any code runs. It is a constant transaction fee (currently 21000 gas) plus a fee for every byte of data supplied with the transaction (4 gas for a zero byte, 68 gas for non-zeros). These constants are all currently defined for geth in params&#x2F;protocol_params.go.</p>\n<h2 id=\"gas-cost\"><a href=\"#gas-cost\" class=\"headerlink\" title=\"gas cost\"></a>gas cost</h2><p>the gas cost of each instruction is stored in <code>JumpTable.operation.dynamicGas</code> or <code>JumpTable.operation.constantGas</code>. constantGas means the operation gas cost is a fixed constant. dynamicGas is a function which will return gas during runtime.</p>\n<p>In fact, not only the interpretation and execution of the instruction itself consumes gas, but also consumes gas when using memory storage and StateDB permanent storage. For most instructions, the latter two are not used (memory &amp; storage), but for some instructions (such as CODECOPY or SSTORE), their gasCost function will take memory and StateDB usage into account.</p>\n<p>a method <code>memoryGasCost</code>is used to calculate the gas consumption of memory usage. only when the required space size exceeds the current space size, the excess part needs to consume gas.</p>\n<h1 id=\"JumpTable\"><a href=\"#JumpTable\" class=\"headerlink\" title=\"JumpTable\"></a>JumpTable</h1><p>jumptable is 256 sized array of <code>operation</code></p>\n<h2 id=\"jump-instruction\"><a href=\"#jump-instruction\" class=\"headerlink\" title=\"jump instruction\"></a>jump instruction</h2><p>Among the instructions of the contract, there are two jump instructions (excluding CALL): JUMP and JUMPI. Their special feature is that the first instruction of the target address after the jump must be JUMPDEST</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func opJump(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) &#123;</span><br><span class=\"line\">    pos := stack.pop()</span><br><span class=\"line\">    if !contract.validJumpdest(pos) &#123;</span><br><span class=\"line\">        nop := contract.GetOp(pos.Uint64())</span><br><span class=\"line\">        return nil, fmt.Errorf(&quot;invalid jump destination (%v) %v&quot;, nop, pos)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *pc = pos.Uint64()</span><br><span class=\"line\"></span><br><span class=\"line\">    interpreter.intPool.put(pos)</span><br><span class=\"line\">    return nil, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A function interprets and executes the JUMP instruction. The code first fetches a value from the stack as the jump destination. This value is actually an offset relative to field 0 of the contract code. Then the code will call Contract.validJumpdest to determine whether the first instruction of this destination is JUMPDEST, if it is not, an error will occur.</p>\n<p>To judge whether the first instruction of the destination is JUMPDEST, two points must be guaranteed: first, its value is the value of the opcode of the JUMPDEST instruction; second, it is an instruction, not ordinary data.</p>\n<p>Let’s introduce how Contract.validJumpdest works. In addition to comparing opcode (this is very simple), Contract will also create a bit vector object (ie bitvec, bit vector). This object will analyze the contract instructions from the beginning to the end. If the byte at a certain offset of the contract belongs to ordinary data, the “bit” corresponding to the offset value in bitvec is set to 1, and if it is an instruction, it is set to 0. In Contract.validJumpdest, it is judged whether this is a normal instruction by checking whether the “bit” of the offset value of the jump destination in this bit vector object is 0</p>\n<h1 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h1><ul>\n<li><a href=\"https://yangzhe.me/2019/08/12/ethereum-evm/#%E8%A7%A3%E9%87%8A%E5%99%A8%E5%AF%B9%E8%B1%A1evminterpreter\">yangzhe_blog</a></li>\n<li><a href=\"https://www.evm.codes/?fork=shanghai\">op code manual</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"overall\"><a href=\"#overall\" class=\"headerlink\" title=\"overall\"></a>overall</h1><p>the code is under path <code>core/vm</code><br>overview of the whole evm module <img src=\"/images/evm.drawio.google.png\" alt=\"evm\"></p>\n<p>the core is <code>EVM</code> struct (in evm.go), with main function in creating or call contract. a new <code>EVM</code> object is created every time when processing a transaction. inside the EVM struct, the main items are <code>Interpreter</code>, and <code>StateDB</code> (for state persistence). <code>Interpreter</code> loops through contract call instructions.Before each instruction is executed, some checks are performed to ensure sufficient gas and stack space. actual instruction execution code is recorded in <code>JumpTable</code> (256 sized array of <code>operation</code>)</p>\n<p>depending on the version of Ethereum, JumpTable may point to four different instruction sets: constantinopleInstructionSet, byzantiumInstructionSet, homesteadInstructionSet, frontierInstructionSet. Most of the instructions of these four sets of instruction sets are the same, but as the version is updated, the new version supports more instruction sets than the old version.</p>\n<h1 id=\"evm\"><a href=\"#evm\" class=\"headerlink\" title=\"evm\"></a>evm</h1><p>The <code>EVM</code> object is the most important object exported by the evm module, which represents an Ethereum virtual machine</p>\n<h2 id=\"creating-evm\"><a href=\"#creating-evm\" class=\"headerlink\" title=\"creating evm\"></a>creating evm</h2><p>Every time a transaction is processed, an EVM is created to execute the transaction. This is reflected in the function <code>ApplyTransaction</code> (core&#x2F;state_processor.go)</p>\n<h2 id=\"creating-contract\"><a href=\"#creating-contract\" class=\"headerlink\" title=\"creating contract\"></a>creating contract</h2><p>If the <code>to</code> of the transaction is empty, it means that this transaction is to create a contract, so call <code>EVM.Create</code> to perform related functions</p>\n<ul>\n<li>CREATE<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contractAddr = crypto.CreateAddress(caller.Address(), evm.StateDB.GetNonce(caller.Address()))</span><br></pre></td></tr></table></figure></li>\n<li>CREATE2<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codeAndHash := &amp;codeAndHash&#123;code: code&#125;</span><br><span class=\"line\">\tcontractAddr = crypto.CreateAddress2(caller.Address(), salt.Bytes32(), codeAndHash.Hash().Bytes())</span><br></pre></td></tr></table></figure>\nduring create contract, an object <code>Contract</code> is created. A Contract object contains and maintains the necessary information during the execution of the contract, such as the contract creator, the address of the contract itself, the remaining gas of the contract, the contract code and the <code>jumpdests</code> record of the code.</li>\n</ul>\n<p>then, it invokes below method to create contract</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret, err := evm.interpreter.Run(contract, nil, false)</span><br><span class=\"line\">evm.StateDB.SetCode(address, ret)</span><br></pre></td></tr></table></figure>\n<p>If the operation is successful and the contract code does not exceed the length limit, call StateDB.SetCode to store the contract code in the contract account of the Ethereum state database. Of course, the storage needs to consume a certain amount of gas.</p>\n<p>You may wonder why the stored contract code is the return code after the contract runs, not the data in the original transaction (ie Transaction.data.Payload). This is because when the contract source code is compiled into binary data, in addition to the original code of the contract, the compiler also inserts some codes to perform related functions. For creation, the compiler inserts code that executes the contract’s “constructor” (that is, the contract object’s constructor method). Therefore, when the binary compiled by the compiler is submitted to the Ethereum node to create a contract, the EVM executes this binary code, in fact, it mainly executes the constructor method of the contract, and then returns other codes of the contract, so there is a <code>ret</code> variable here Stored in the state database as the actual code of the contract</p>\n<h2 id=\"call-contract\"><a href=\"#call-contract\" class=\"headerlink\" title=\"call contract\"></a>call contract</h2><p>The EVM object has three methods to implement the call of the contract, they are:</p>\n<ul>\n<li>EVM. Call</li>\n<li>EVM. CallCode</li>\n<li>EVM. DelegateCall</li>\n<li>EVM.StaticCall<br>The basic contract call function implemented by EVM.Call is nothing special. The following three calling methods are the differences compared with EVM.Call. So here we only introduce the particularity of the last three calling methods</li>\n</ul>\n<h3 id=\"EVM-CallCode-amp-EVM-DelegateCall\"><a href=\"#EVM-CallCode-amp-EVM-DelegateCall\" class=\"headerlink\" title=\"EVM.CallCode &amp; EVM.DelegateCall\"></a>EVM.CallCode &amp; EVM.DelegateCall</h3><p>The existence of EVM.CallCode and EVM.DelegateCall is to realize the characteristics of the “library” of the contract. If the code written by solidity is to be called as a library, it must be deployed on the blockchain to obtain a fixed address like a normal contract. , other contracts can call the method provided by this “library contract”. But the contract also involves some unique attributes, such as the caller of the contract, contract address, the amount of ether it owns, etc. If we directly call the code of the “library contract”, these properties must be the properties of the “library contract” itself, but this may not be what we want</p>\n<p>as an example</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A -&gt; contractB - delegateCall -&gt; libC</span><br></pre></td></tr></table></figure>\n<p><code>EVM.DelegateCall</code> sets the caller (msg.sender) of the “library contract” (libC) to A, rather than contractB; sets the address of the “library contract” (libC) to contractB.<br><code>EVM.CallCode</code> is similar to <code>EVM.DelegateCall</code>. the only difference is that <code>EVM.CallCode</code> only change the address of the “library contract” (libC) to contractB, without chanding the caller to A.<br><code>EVM.StaticCall</code> is similar to <code>EVM.Call</code>, the only difference is that EVM.StaticCall does not allow execution of instructions that modify permanently stored data</p>\n<p>during contract call, it first check whether it is precompiled contract. some precompiled contracts are</p>\n<ul>\n<li>common.BytesToAddress([]byte{1}): &amp;ecrecover{},</li>\n<li>common.BytesToAddress([]byte{2}): &amp;sha256hash{},</li>\n<li>common.BytesToAddress([]byte{3}): &amp;ripemd160hash{},</li>\n<li>common.BytesToAddress([]byte{4}): &amp;dataCopy{},</li>\n</ul>\n<h1 id=\"EVMInterpreter\"><a href=\"#EVMInterpreter\" class=\"headerlink\" title=\"EVMInterpreter\"></a>EVMInterpreter</h1><p>The interpreter object EVMInterpreter is used to interpret and execute specified contract instructions. However, note that the actual instruction interpretation and execution is not really completed by the interpreter object, but by the operation object JumpTable. The interpreter object is only responsible for parsing instruction codes one by one, and then obtains the corresponding operation object, and check objects such as the stack before calling the operation.execute function that actually executre the instruction. It can also be said that the interpreter object is only responsible for the scheduling of interpretation.</p>\n<h2 id=\"execution-layout\"><a href=\"#execution-layout\" class=\"headerlink\" title=\"execution layout\"></a>execution layout</h2><p><img src=\"/images/evm.layout.png\" alt=\"layout\"></p>\n<h2 id=\"intrinsic-gas\"><a href=\"#intrinsic-gas\" class=\"headerlink\" title=\"intrinsic gas\"></a>intrinsic gas</h2><p>The intrinsic gas for a transaction is the amount of gas that the transaction uses before any code runs. It is a constant transaction fee (currently 21000 gas) plus a fee for every byte of data supplied with the transaction (4 gas for a zero byte, 68 gas for non-zeros). These constants are all currently defined for geth in params&#x2F;protocol_params.go.</p>\n<h2 id=\"gas-cost\"><a href=\"#gas-cost\" class=\"headerlink\" title=\"gas cost\"></a>gas cost</h2><p>the gas cost of each instruction is stored in <code>JumpTable.operation.dynamicGas</code> or <code>JumpTable.operation.constantGas</code>. constantGas means the operation gas cost is a fixed constant. dynamicGas is a function which will return gas during runtime.</p>\n<p>In fact, not only the interpretation and execution of the instruction itself consumes gas, but also consumes gas when using memory storage and StateDB permanent storage. For most instructions, the latter two are not used (memory &amp; storage), but for some instructions (such as CODECOPY or SSTORE), their gasCost function will take memory and StateDB usage into account.</p>\n<p>a method <code>memoryGasCost</code>is used to calculate the gas consumption of memory usage. only when the required space size exceeds the current space size, the excess part needs to consume gas.</p>\n<h1 id=\"JumpTable\"><a href=\"#JumpTable\" class=\"headerlink\" title=\"JumpTable\"></a>JumpTable</h1><p>jumptable is 256 sized array of <code>operation</code></p>\n<h2 id=\"jump-instruction\"><a href=\"#jump-instruction\" class=\"headerlink\" title=\"jump instruction\"></a>jump instruction</h2><p>Among the instructions of the contract, there are two jump instructions (excluding CALL): JUMP and JUMPI. Their special feature is that the first instruction of the target address after the jump must be JUMPDEST</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func opJump(pc *uint64, interpreter *EVMInterpreter, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) &#123;</span><br><span class=\"line\">    pos := stack.pop()</span><br><span class=\"line\">    if !contract.validJumpdest(pos) &#123;</span><br><span class=\"line\">        nop := contract.GetOp(pos.Uint64())</span><br><span class=\"line\">        return nil, fmt.Errorf(&quot;invalid jump destination (%v) %v&quot;, nop, pos)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *pc = pos.Uint64()</span><br><span class=\"line\"></span><br><span class=\"line\">    interpreter.intPool.put(pos)</span><br><span class=\"line\">    return nil, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>A function interprets and executes the JUMP instruction. The code first fetches a value from the stack as the jump destination. This value is actually an offset relative to field 0 of the contract code. Then the code will call Contract.validJumpdest to determine whether the first instruction of this destination is JUMPDEST, if it is not, an error will occur.</p>\n<p>To judge whether the first instruction of the destination is JUMPDEST, two points must be guaranteed: first, its value is the value of the opcode of the JUMPDEST instruction; second, it is an instruction, not ordinary data.</p>\n<p>Let’s introduce how Contract.validJumpdest works. In addition to comparing opcode (this is very simple), Contract will also create a bit vector object (ie bitvec, bit vector). This object will analyze the contract instructions from the beginning to the end. If the byte at a certain offset of the contract belongs to ordinary data, the “bit” corresponding to the offset value in bitvec is set to 1, and if it is an instruction, it is set to 0. In Contract.validJumpdest, it is judged whether this is a normal instruction by checking whether the “bit” of the offset value of the jump destination in this bit vector object is 0</p>\n<h1 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h1><ul>\n<li><a href=\"https://yangzhe.me/2019/08/12/ethereum-evm/#%E8%A7%A3%E9%87%8A%E5%99%A8%E5%AF%B9%E8%B1%A1evminterpreter\">yangzhe_blog</a></li>\n<li><a href=\"https://www.evm.codes/?fork=shanghai\">op code manual</a></li>\n</ul>\n"},{"title":"MPT","date":"2023-01-22T09:25:36.000Z","_content":"\n# trie\na trie, also called prefix tree, is a type of k-ary search tree. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. In order to access a key, the trie is traversed depth-first, following the links between nodes, which represent each character in the key.\n\n![prefix trie](/images/trie.prefix.png)\nIn general, the nodes of a Trie look like this:\n```\n[ [Ia, Ib, … I*], value]\n```\n[Ia, Ib, ... I*] is the index array of the node, which takes the next character in the key as the index, and each element I* points to the corresponding child node. value represents the value\n\n# MPT\nEach block of Ethereum contains three MPT trees, respectively\n\n- Transaction tree\n- Receipt tree\n- State tree\n\nIn the figure below are two block headers, where state root, tx root receipt root stores the roots of the three trees, and the second block shows when the data of account 175 changes (27 -> 45). Only need to store 3 nodes related to this account, and the data in the old block can still be accessed normally. (This is somewhat similar to the implementation of an immutable data structure in a functional programming language.) The detailed structure is\n\n![state reference](/images/mpt.state.ref.png)\n\n- use []byte as key, other than string\n- nibble: the smallest unit of the key type (4 bit)\n- Use hashes to refer to nodes instead of memory pointers\n\nthere are two types of node: full nodes (fullNode) and short nodes (shortNode). Full nodes have 17 elements, while shortNode nodes have two elements. Their schematic expressions are as follows\n```\nfullNode: [i0, i1, i2, … i15, hash]  \nshortNode： [ [k0, k1, … kn], hash ] // first element is an array\n```\nif the hash pointing to a value, it is a leaf node; if pointing another node, a non leaf node. shortNode contains extension and leaf node. full node is branch node.\n\n![mpt](/images/mpt.png)\n\nUse the upper 4 bits of the first byte of the []byte value composed of nibbles as storage flag. The 0th bit stores the parity information, and the 1st bit stores the type represented by the value\n|hex char| bits | pointing to | odd/even | 2nd niddle padding |\n| -----|:----:|:----:|:----:|-------|\n|0| 0000 | node | even | no |\n|1| 0001 | node | odd | yes |\n|2| 0010 | value | even | no |\n|3| 0011 | value | odd | yes |\n\nthis encoding method is only used when accessing the database. After reading into memory, the key is directly stored in []byte type\n\nIn the trie module, there is a `Database` object, which you can understand as a cache layer of the underlying database. In actual use, the Trie object uses the Database as a database. However, the important function of Database is not caching, but the reference counting of node data during caching, and provides Database.Reference and Database.Dereference to reference and dereference a trie node. If the reference count of a node becomes 0, the node will be deleted from memory, so it will not be written to the real database\n\n# reference\n- [github](https://github.com/agiletechvn/go-ethereum-code-analysis/blob/master/trie-analysis.md)\n- [yangzhe's blog](http://yangzhe.me/2019/01/12/ethereum-trie-part-1/)\n- [yangzhe's blod](http://yangzhe.me/2019/01/18/ethereum-trie-part-2/)","source":"_posts/MPT.md","raw":"---\ntitle: MPT\ndate: 2023-01-22 17:25:36\ntags: [blockchain, geth]\n---\n\n# trie\na trie, also called prefix tree, is a type of k-ary search tree. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. In order to access a key, the trie is traversed depth-first, following the links between nodes, which represent each character in the key.\n\n![prefix trie](/images/trie.prefix.png)\nIn general, the nodes of a Trie look like this:\n```\n[ [Ia, Ib, … I*], value]\n```\n[Ia, Ib, ... I*] is the index array of the node, which takes the next character in the key as the index, and each element I* points to the corresponding child node. value represents the value\n\n# MPT\nEach block of Ethereum contains three MPT trees, respectively\n\n- Transaction tree\n- Receipt tree\n- State tree\n\nIn the figure below are two block headers, where state root, tx root receipt root stores the roots of the three trees, and the second block shows when the data of account 175 changes (27 -> 45). Only need to store 3 nodes related to this account, and the data in the old block can still be accessed normally. (This is somewhat similar to the implementation of an immutable data structure in a functional programming language.) The detailed structure is\n\n![state reference](/images/mpt.state.ref.png)\n\n- use []byte as key, other than string\n- nibble: the smallest unit of the key type (4 bit)\n- Use hashes to refer to nodes instead of memory pointers\n\nthere are two types of node: full nodes (fullNode) and short nodes (shortNode). Full nodes have 17 elements, while shortNode nodes have two elements. Their schematic expressions are as follows\n```\nfullNode: [i0, i1, i2, … i15, hash]  \nshortNode： [ [k0, k1, … kn], hash ] // first element is an array\n```\nif the hash pointing to a value, it is a leaf node; if pointing another node, a non leaf node. shortNode contains extension and leaf node. full node is branch node.\n\n![mpt](/images/mpt.png)\n\nUse the upper 4 bits of the first byte of the []byte value composed of nibbles as storage flag. The 0th bit stores the parity information, and the 1st bit stores the type represented by the value\n|hex char| bits | pointing to | odd/even | 2nd niddle padding |\n| -----|:----:|:----:|:----:|-------|\n|0| 0000 | node | even | no |\n|1| 0001 | node | odd | yes |\n|2| 0010 | value | even | no |\n|3| 0011 | value | odd | yes |\n\nthis encoding method is only used when accessing the database. After reading into memory, the key is directly stored in []byte type\n\nIn the trie module, there is a `Database` object, which you can understand as a cache layer of the underlying database. In actual use, the Trie object uses the Database as a database. However, the important function of Database is not caching, but the reference counting of node data during caching, and provides Database.Reference and Database.Dereference to reference and dereference a trie node. If the reference count of a node becomes 0, the node will be deleted from memory, so it will not be written to the real database\n\n# reference\n- [github](https://github.com/agiletechvn/go-ethereum-code-analysis/blob/master/trie-analysis.md)\n- [yangzhe's blog](http://yangzhe.me/2019/01/12/ethereum-trie-part-1/)\n- [yangzhe's blod](http://yangzhe.me/2019/01/18/ethereum-trie-part-2/)","slug":"MPT","published":1,"updated":"2023-04-15T04:52:00.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tl00096usj8zec85nf","content":"<h1 id=\"trie\"><a href=\"#trie\" class=\"headerlink\" title=\"trie\"></a>trie</h1><p>a trie, also called prefix tree, is a type of k-ary search tree. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. In order to access a key, the trie is traversed depth-first, following the links between nodes, which represent each character in the key.</p>\n<p><img src=\"/images/trie.prefix.png\" alt=\"prefix trie\"><br>In general, the nodes of a Trie look like this:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ [Ia, Ib, … I*], value]</span><br></pre></td></tr></table></figure>\n<p>[Ia, Ib, … I*] is the index array of the node, which takes the next character in the key as the index, and each element I* points to the corresponding child node. value represents the value</p>\n<h1 id=\"MPT\"><a href=\"#MPT\" class=\"headerlink\" title=\"MPT\"></a>MPT</h1><p>Each block of Ethereum contains three MPT trees, respectively</p>\n<ul>\n<li>Transaction tree</li>\n<li>Receipt tree</li>\n<li>State tree</li>\n</ul>\n<p>In the figure below are two block headers, where state root, tx root receipt root stores the roots of the three trees, and the second block shows when the data of account 175 changes (27 -&gt; 45). Only need to store 3 nodes related to this account, and the data in the old block can still be accessed normally. (This is somewhat similar to the implementation of an immutable data structure in a functional programming language.) The detailed structure is</p>\n<p><img src=\"/images/mpt.state.ref.png\" alt=\"state reference\"></p>\n<ul>\n<li>use []byte as key, other than string</li>\n<li>nibble: the smallest unit of the key type (4 bit)</li>\n<li>Use hashes to refer to nodes instead of memory pointers</li>\n</ul>\n<p>there are two types of node: full nodes (fullNode) and short nodes (shortNode). Full nodes have 17 elements, while shortNode nodes have two elements. Their schematic expressions are as follows</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fullNode: [i0, i1, i2, … i15, hash]  </span><br><span class=\"line\">shortNode： [ [k0, k1, … kn], hash ] // first element is an array</span><br></pre></td></tr></table></figure>\n<p>if the hash pointing to a value, it is a leaf node; if pointing another node, a non leaf node. shortNode contains extension and leaf node. full node is branch node.</p>\n<p><img src=\"/images/mpt.png\" alt=\"mpt\"></p>\n<p>Use the upper 4 bits of the first byte of the []byte value composed of nibbles as storage flag. The 0th bit stores the parity information, and the 1st bit stores the type represented by the value</p>\n<table>\n<thead>\n<tr>\n<th>hex char</th>\n<th align=\"center\">bits</th>\n<th align=\"center\">pointing to</th>\n<th align=\"center\">odd&#x2F;even</th>\n<th>2nd niddle padding</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td align=\"center\">0000</td>\n<td align=\"center\">node</td>\n<td align=\"center\">even</td>\n<td>no</td>\n</tr>\n<tr>\n<td>1</td>\n<td align=\"center\">0001</td>\n<td align=\"center\">node</td>\n<td align=\"center\">odd</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"center\">0010</td>\n<td align=\"center\">value</td>\n<td align=\"center\">even</td>\n<td>no</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"center\">0011</td>\n<td align=\"center\">value</td>\n<td align=\"center\">odd</td>\n<td>yes</td>\n</tr>\n</tbody></table>\n<p>this encoding method is only used when accessing the database. After reading into memory, the key is directly stored in []byte type</p>\n<p>In the trie module, there is a <code>Database</code> object, which you can understand as a cache layer of the underlying database. In actual use, the Trie object uses the Database as a database. However, the important function of Database is not caching, but the reference counting of node data during caching, and provides Database.Reference and Database.Dereference to reference and dereference a trie node. If the reference count of a node becomes 0, the node will be deleted from memory, so it will not be written to the real database</p>\n<h1 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h1><ul>\n<li><a href=\"https://github.com/agiletechvn/go-ethereum-code-analysis/blob/master/trie-analysis.md\">github</a></li>\n<li><a href=\"http://yangzhe.me/2019/01/12/ethereum-trie-part-1/\">yangzhe’s blog</a></li>\n<li><a href=\"http://yangzhe.me/2019/01/18/ethereum-trie-part-2/\">yangzhe’s blod</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"trie\"><a href=\"#trie\" class=\"headerlink\" title=\"trie\"></a>trie</h1><p>a trie, also called prefix tree, is a type of k-ary search tree. These keys are most often strings, with links between nodes defined not by the entire key, but by individual characters. In order to access a key, the trie is traversed depth-first, following the links between nodes, which represent each character in the key.</p>\n<p><img src=\"/images/trie.prefix.png\" alt=\"prefix trie\"><br>In general, the nodes of a Trie look like this:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ [Ia, Ib, … I*], value]</span><br></pre></td></tr></table></figure>\n<p>[Ia, Ib, … I*] is the index array of the node, which takes the next character in the key as the index, and each element I* points to the corresponding child node. value represents the value</p>\n<h1 id=\"MPT\"><a href=\"#MPT\" class=\"headerlink\" title=\"MPT\"></a>MPT</h1><p>Each block of Ethereum contains three MPT trees, respectively</p>\n<ul>\n<li>Transaction tree</li>\n<li>Receipt tree</li>\n<li>State tree</li>\n</ul>\n<p>In the figure below are two block headers, where state root, tx root receipt root stores the roots of the three trees, and the second block shows when the data of account 175 changes (27 -&gt; 45). Only need to store 3 nodes related to this account, and the data in the old block can still be accessed normally. (This is somewhat similar to the implementation of an immutable data structure in a functional programming language.) The detailed structure is</p>\n<p><img src=\"/images/mpt.state.ref.png\" alt=\"state reference\"></p>\n<ul>\n<li>use []byte as key, other than string</li>\n<li>nibble: the smallest unit of the key type (4 bit)</li>\n<li>Use hashes to refer to nodes instead of memory pointers</li>\n</ul>\n<p>there are two types of node: full nodes (fullNode) and short nodes (shortNode). Full nodes have 17 elements, while shortNode nodes have two elements. Their schematic expressions are as follows</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fullNode: [i0, i1, i2, … i15, hash]  </span><br><span class=\"line\">shortNode： [ [k0, k1, … kn], hash ] // first element is an array</span><br></pre></td></tr></table></figure>\n<p>if the hash pointing to a value, it is a leaf node; if pointing another node, a non leaf node. shortNode contains extension and leaf node. full node is branch node.</p>\n<p><img src=\"/images/mpt.png\" alt=\"mpt\"></p>\n<p>Use the upper 4 bits of the first byte of the []byte value composed of nibbles as storage flag. The 0th bit stores the parity information, and the 1st bit stores the type represented by the value</p>\n<table>\n<thead>\n<tr>\n<th>hex char</th>\n<th align=\"center\">bits</th>\n<th align=\"center\">pointing to</th>\n<th align=\"center\">odd&#x2F;even</th>\n<th>2nd niddle padding</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td align=\"center\">0000</td>\n<td align=\"center\">node</td>\n<td align=\"center\">even</td>\n<td>no</td>\n</tr>\n<tr>\n<td>1</td>\n<td align=\"center\">0001</td>\n<td align=\"center\">node</td>\n<td align=\"center\">odd</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"center\">0010</td>\n<td align=\"center\">value</td>\n<td align=\"center\">even</td>\n<td>no</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"center\">0011</td>\n<td align=\"center\">value</td>\n<td align=\"center\">odd</td>\n<td>yes</td>\n</tr>\n</tbody></table>\n<p>this encoding method is only used when accessing the database. After reading into memory, the key is directly stored in []byte type</p>\n<p>In the trie module, there is a <code>Database</code> object, which you can understand as a cache layer of the underlying database. In actual use, the Trie object uses the Database as a database. However, the important function of Database is not caching, but the reference counting of node data during caching, and provides Database.Reference and Database.Dereference to reference and dereference a trie node. If the reference count of a node becomes 0, the node will be deleted from memory, so it will not be written to the real database</p>\n<h1 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h1><ul>\n<li><a href=\"https://github.com/agiletechvn/go-ethereum-code-analysis/blob/master/trie-analysis.md\">github</a></li>\n<li><a href=\"http://yangzhe.me/2019/01/12/ethereum-trie-part-1/\">yangzhe’s blog</a></li>\n<li><a href=\"http://yangzhe.me/2019/01/18/ethereum-trie-part-2/\">yangzhe’s blod</a></li>\n</ul>\n"},{"title":"paillier encryption","date":"2023-02-23T13:25:41.000Z","_content":"\n<script\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n  type=\"text/javascript\">\n</script>\n\n## fundamentals\n1. fundamental theorem of arighmetic\nthe fundamental theorem of arithmetic, also called the unique factorization theorem and prime factorization theorem, states that every integer greater than 1 can be represented uniquely as a product of prime numbers, up to the order of the factors [wiki](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)\n2. Euler's totient function\nIn number theory, Euler's totient function counts the positive integers up to a given integer n that are relatively prime to n. It is written using the Greek letter phi as \\\\( \\phi (n) \\\\), and may also be called Euler's phi function. In other words, it is the number of integers k in the range 1 ≤ k ≤ n for which the greatest common divisor gcd(n, k) is equal to 1. The integers k of this form are sometimes referred to as totatives of n. the collection of k is denoted by \\\\( Z_{n}^{\\ast } \\\\), and \\\\[ \\phi(n) = |Z_n^{\\ast }| \\\\]\n3. if p is prime, then \\\\( Z_p^{\\ast } = Z_p \\\\), \\\\( \\phi(p) = p-1 \\\\)\n4. if p is prime, for any integer r, then \\\\( \\begin{align} \\tag{0.1} \\phi(p^{r}) =p^{r-1}\\phi(p)=p^{r-1}(p-1)\\end{align} \\\\)\n5. Euler's totient function is a multiplicative function, meaning that if two numbers m and n are relatively prime, then \\\\(\\phi(mn) = \\phi(m)\\phi(n)\\\\)\n6. Euler's product formula, it states\n\\\\[ \\phi(n) = n  \\prod_{p|n}^{}(1-\\frac{1}{p}) \\\\]\nwhere the product is over the distinct prime numbers dividing n.\n7. Euler's theorem\nif \\\\(a\\\\) and \\\\(n\\\\) are coprime positive integers, and \\\\( \\phi(n)\\\\) is Euler's totient function, then \\\\(a\\\\) raised to the power  \\\\(\\phi(n)\\\\) is congruent to 1 modulo n; that is\n\\\\[a^{\\phi(n)} \\equiv 1 \\bmod n\\\\]\n8. according to 7, we have \\\\( a \\cdot a^{\\phi(n)-1} \\equiv 1 \\bmod n \\\\). then\n\\\\[ a^{-1} = a^{\\phi(n)-1} \\\\]\n9. Fermat's little theorem\nFermat's little theorem states that if p is a prime number, then for any integer a, the number \n\\\\(a^{p}-a \\\\) is an integer multiple of p. In the notation of modular arithmetic, this is expressed as\n\\\\[ a^{p} \\equiv a \\bmod p\\\\]\n10. Binomial theorem\nit states\n\\\\[ y = (1+n)^{x} = \\sum_{k=0}^{x}\\tbinom{x}{k}n^{k} = 1 + nx + \\tbinom{x}{2}n^2 + ...\\\\]\nobserve that, the higher degree could be divided by \\\\(n^2\\\\). we have\n\\\\[ \\begin{align} \\tag{0.2} (1+n)^{x} \\equiv 1 + nx \\bmod n^2 \\end{align} \\\\]\ntherefore, \\\\( y - 1 \\equiv nx \\bmod n^2 \\\\). then we have\n\\\\[ x \\equiv \\frac{y-1}{n} \\bmod n \\\\].\nIn paillier, later we define \\\\( \\begin{align} \\tag{0.3} L(y) = \\frac{y-1}{n} \\end{align} \\\\)\ntherefore\n\\\\[ L(y \\bmod n^2) \\equiv x \\bmod n \\\\]\n\n\n## Paillier\n1. key generation\n`KeyGen() -> (pk, sk)`\nrandomly select two big prime numbers \\\\(p, q\\\\). it shoud satisfy \\\\(gcd(pq, (p-1)(q-1)) =1 \\\\), \\\\(p\\\\) and \\\\(q\\\\) should have similar bit length. let \\\\( n = pq \\\\), \\\\(\\lambda = lcm(p-1, q-1)\\\\). randomly sample \\\\( g \\in Z_{n^2}^{\\ast}\\\\). to simplify, let \\\\( g = n+1\\\\). we have\n\\\\[ pk=(n,g) \\\\]\n\\\\[ sk = (\\lambda)\\\\]\n\n2. encryption\n`Enc(pk, m) -> c`\nrandomly sample \\\\( r \\in Z_{n}^{\\ast}\\\\), then also have \\\\( r \\in Z_{n^2}^{\\ast}\\\\), cypher is calculated\n\\\\[ \\begin{align} \\tag{1.1} c = g^mr^n  \\bmod n^2 \\end{align} \\\\]\n\n3. Decryption\n`Dec(sk, c) -> m`\nLet \\\\(L(x) = \\frac{x-1}{n} \\\\), we have message\n\\\\[ \\begin{align} \\tag{1.2} m = \\frac{L(c^{\\lambda} \\bmod n^2)}{L(g^{\\lambda} \\bmod n^2)} \\bmod n \\end{align}\\\\]\n\n4. proof of correctness\nbased on Eq(1), we have \\\\[ \\begin{align} \\tag{1.3} c^{\\lambda} \\bmod n^2 = g^{m\\lambda}r^{n\\lambda} \\bmod n^2 \\end{align}\\\\]\nwhere \\\\( r^{n\\lambda} \\bmod n^2 \\equiv 1 \\bmod n^2\\\\), which is proved by Carmichael theorem later on. then Eq(3) becomes\n \\\\[ \\begin{align} \\tag{1.4} c^{\\lambda} \\bmod n^2 = g^{m\\lambda}\\bmod n^2 \\end{align}\\\\]\nsince \\\\( g = n+1\\\\), we have\n\\\\[ \\begin{align} \\tag{1.5} c^{\\lambda} \\bmod n^2 = (1+n)^{m\\lambda}\\bmod n^2 \\end{align}\\\\]\nAccording to Eq(0.2), we have\n\\\\[ \\begin{align} \\tag{1.6} c^{\\lambda} \\bmod n^2 = 1 + nm\\lambda \\bmod n^2 \\end{align}\\\\]\n\\\\[ \\begin{align} \\tag{1.7} g^{\\lambda} \\bmod n^2 \\equiv (1+n)^{\\lambda} \\bmod n^2 = 1 +\\lambda n \\bmod n^2 \\end{align}\\\\]\ntherefore, based on definition given by Eq(0.3) we have\n\\\\[ \\begin{align} \\tag{1.8} L(c^{\\lambda} \\bmod n^2) = \\frac{c^{\\lambda}-1}{n} \\bmod n^2 \\end{align} \\\\]\nSubstitute Eq(1.6) into Eq(1.8), we have\n\\\\[ \\begin{align} \\tag{1.9} L(c^{\\lambda} \\bmod n^2) = m\\lambda \\bmod n^2 \\end{align} \\\\]\nFurther, we have\n\\\\[ \\begin{align} \\tag{1.10} L(g^{\\lambda} \\bmod n^2) = \\frac{g^\\lambda -1}{n} \\end{align} \\\\]\nSub Eq(1.7) into Eq(1.10), we have\n\\\\[ \\begin{align} \\tag{1.11} L(g^{\\lambda} \\bmod n^2) = \\frac{\\lambda n}{n} \\equiv \\lambda \\bmod n^2\\end{align} \\\\]\nAt last, Eq(1.2) becomes （bu sub Eq1.9 and Eq1.11)\n\\\\[ \\begin{align}  m = \\frac{L(c^{\\lambda} \\bmod n^2)}{L(g^{\\lambda} \\bmod n^2)} \\bmod n = \\frac{m \\lambda}{\\lambda} \\equiv m \\bmod n \\end{align}\\\\]\n<b>proved!!!</b>\n\n5. Carmichael theorem\nIn number theory, a branch of mathematics, the Carmichael function \\\\(λ(n)\\\\) of a positive integer n is the smallest positive integer m such that \\\\(a^{m}\\equiv 1{\\pmod {n}}\\\\) (similar but different from Euler's totient function). Carmichael's λ function, the reduced totient function, and the least universal exponent function\n![carmichael theorem](/images/paillier/carmichael_thorem.png)\n![](/images/paillier/carmichael_thorem_2.png)\nlet \\\\( n = pq\\\\), where p and q are prime numbers; \\\\( \\phi(n)\\\\) is the Euler's totient function. Let \\\\(\\lambda(n)\\\\) denotes carmichael function. We have \\\\(\\phi(n)=(p-1)(q-1)\\\\) and \\\\( \\lambda(n)=\\phi(n) = (p-1)(q-1)\\\\).\n\nSince \\\\( |Z_{n^2}^{\\ast}| = \\phi(n^2) = n \\phi(n)\\\\) (according to Eq(0.1)). Thereby, for any \\\\( w \\in Z_{n^2}^{\\ast}\\\\)\n\\\\[ \\begin{align} \\tag{1.12} w^{n\\phi(n)} \\equiv w^{n\\\\lambda} \\equiv 1 \\bmod n^2 \\end{align}\\\\]\n\n\\\\[ \\begin{align} \\tag{1.13} w^{\\lambda} \\equiv 1 \\bmod n \\end{align}\\\\]\nEq(1.13) is just Carmichael's function\n\nBased on Carmichael's theorem\n\\\\[ \\lambda(n^2) = lcm(\\lambda(q^2),\\lambda(p^2)) = lcm(\\phi(q^2),\\phi(p^2)) = lcm(q(q-1), p(p-1)) = pq(lcm(p-1, q-1)) = n\\lambda(n) \\\\] \ntherefore, we have\n\n\\\\[w^{\\lambda(n^2)} = w ^{n\\lambda} \\equiv 1 \\bmod n^2\\\\]\n\n6. Addition homomorphic\n![homomorphic addition](/images/paillier/homomorphic_addition.png)\n\n7. Multiplication homomorphic \n![homomorphic multiplication](/images/paillier/homomorphic_mul.png)\n## references\n- [csdn post](https://blog.csdn.net/qq_42328228/article/details/109349590)","source":"_posts/paillier-encryption.md","raw":"---\ntitle: paillier encryption\ndate: 2023-02-23 21:25:41\ntags: [cryptography]\n---\n\n<script\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n  type=\"text/javascript\">\n</script>\n\n## fundamentals\n1. fundamental theorem of arighmetic\nthe fundamental theorem of arithmetic, also called the unique factorization theorem and prime factorization theorem, states that every integer greater than 1 can be represented uniquely as a product of prime numbers, up to the order of the factors [wiki](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)\n2. Euler's totient function\nIn number theory, Euler's totient function counts the positive integers up to a given integer n that are relatively prime to n. It is written using the Greek letter phi as \\\\( \\phi (n) \\\\), and may also be called Euler's phi function. In other words, it is the number of integers k in the range 1 ≤ k ≤ n for which the greatest common divisor gcd(n, k) is equal to 1. The integers k of this form are sometimes referred to as totatives of n. the collection of k is denoted by \\\\( Z_{n}^{\\ast } \\\\), and \\\\[ \\phi(n) = |Z_n^{\\ast }| \\\\]\n3. if p is prime, then \\\\( Z_p^{\\ast } = Z_p \\\\), \\\\( \\phi(p) = p-1 \\\\)\n4. if p is prime, for any integer r, then \\\\( \\begin{align} \\tag{0.1} \\phi(p^{r}) =p^{r-1}\\phi(p)=p^{r-1}(p-1)\\end{align} \\\\)\n5. Euler's totient function is a multiplicative function, meaning that if two numbers m and n are relatively prime, then \\\\(\\phi(mn) = \\phi(m)\\phi(n)\\\\)\n6. Euler's product formula, it states\n\\\\[ \\phi(n) = n  \\prod_{p|n}^{}(1-\\frac{1}{p}) \\\\]\nwhere the product is over the distinct prime numbers dividing n.\n7. Euler's theorem\nif \\\\(a\\\\) and \\\\(n\\\\) are coprime positive integers, and \\\\( \\phi(n)\\\\) is Euler's totient function, then \\\\(a\\\\) raised to the power  \\\\(\\phi(n)\\\\) is congruent to 1 modulo n; that is\n\\\\[a^{\\phi(n)} \\equiv 1 \\bmod n\\\\]\n8. according to 7, we have \\\\( a \\cdot a^{\\phi(n)-1} \\equiv 1 \\bmod n \\\\). then\n\\\\[ a^{-1} = a^{\\phi(n)-1} \\\\]\n9. Fermat's little theorem\nFermat's little theorem states that if p is a prime number, then for any integer a, the number \n\\\\(a^{p}-a \\\\) is an integer multiple of p. In the notation of modular arithmetic, this is expressed as\n\\\\[ a^{p} \\equiv a \\bmod p\\\\]\n10. Binomial theorem\nit states\n\\\\[ y = (1+n)^{x} = \\sum_{k=0}^{x}\\tbinom{x}{k}n^{k} = 1 + nx + \\tbinom{x}{2}n^2 + ...\\\\]\nobserve that, the higher degree could be divided by \\\\(n^2\\\\). we have\n\\\\[ \\begin{align} \\tag{0.2} (1+n)^{x} \\equiv 1 + nx \\bmod n^2 \\end{align} \\\\]\ntherefore, \\\\( y - 1 \\equiv nx \\bmod n^2 \\\\). then we have\n\\\\[ x \\equiv \\frac{y-1}{n} \\bmod n \\\\].\nIn paillier, later we define \\\\( \\begin{align} \\tag{0.3} L(y) = \\frac{y-1}{n} \\end{align} \\\\)\ntherefore\n\\\\[ L(y \\bmod n^2) \\equiv x \\bmod n \\\\]\n\n\n## Paillier\n1. key generation\n`KeyGen() -> (pk, sk)`\nrandomly select two big prime numbers \\\\(p, q\\\\). it shoud satisfy \\\\(gcd(pq, (p-1)(q-1)) =1 \\\\), \\\\(p\\\\) and \\\\(q\\\\) should have similar bit length. let \\\\( n = pq \\\\), \\\\(\\lambda = lcm(p-1, q-1)\\\\). randomly sample \\\\( g \\in Z_{n^2}^{\\ast}\\\\). to simplify, let \\\\( g = n+1\\\\). we have\n\\\\[ pk=(n,g) \\\\]\n\\\\[ sk = (\\lambda)\\\\]\n\n2. encryption\n`Enc(pk, m) -> c`\nrandomly sample \\\\( r \\in Z_{n}^{\\ast}\\\\), then also have \\\\( r \\in Z_{n^2}^{\\ast}\\\\), cypher is calculated\n\\\\[ \\begin{align} \\tag{1.1} c = g^mr^n  \\bmod n^2 \\end{align} \\\\]\n\n3. Decryption\n`Dec(sk, c) -> m`\nLet \\\\(L(x) = \\frac{x-1}{n} \\\\), we have message\n\\\\[ \\begin{align} \\tag{1.2} m = \\frac{L(c^{\\lambda} \\bmod n^2)}{L(g^{\\lambda} \\bmod n^2)} \\bmod n \\end{align}\\\\]\n\n4. proof of correctness\nbased on Eq(1), we have \\\\[ \\begin{align} \\tag{1.3} c^{\\lambda} \\bmod n^2 = g^{m\\lambda}r^{n\\lambda} \\bmod n^2 \\end{align}\\\\]\nwhere \\\\( r^{n\\lambda} \\bmod n^2 \\equiv 1 \\bmod n^2\\\\), which is proved by Carmichael theorem later on. then Eq(3) becomes\n \\\\[ \\begin{align} \\tag{1.4} c^{\\lambda} \\bmod n^2 = g^{m\\lambda}\\bmod n^2 \\end{align}\\\\]\nsince \\\\( g = n+1\\\\), we have\n\\\\[ \\begin{align} \\tag{1.5} c^{\\lambda} \\bmod n^2 = (1+n)^{m\\lambda}\\bmod n^2 \\end{align}\\\\]\nAccording to Eq(0.2), we have\n\\\\[ \\begin{align} \\tag{1.6} c^{\\lambda} \\bmod n^2 = 1 + nm\\lambda \\bmod n^2 \\end{align}\\\\]\n\\\\[ \\begin{align} \\tag{1.7} g^{\\lambda} \\bmod n^2 \\equiv (1+n)^{\\lambda} \\bmod n^2 = 1 +\\lambda n \\bmod n^2 \\end{align}\\\\]\ntherefore, based on definition given by Eq(0.3) we have\n\\\\[ \\begin{align} \\tag{1.8} L(c^{\\lambda} \\bmod n^2) = \\frac{c^{\\lambda}-1}{n} \\bmod n^2 \\end{align} \\\\]\nSubstitute Eq(1.6) into Eq(1.8), we have\n\\\\[ \\begin{align} \\tag{1.9} L(c^{\\lambda} \\bmod n^2) = m\\lambda \\bmod n^2 \\end{align} \\\\]\nFurther, we have\n\\\\[ \\begin{align} \\tag{1.10} L(g^{\\lambda} \\bmod n^2) = \\frac{g^\\lambda -1}{n} \\end{align} \\\\]\nSub Eq(1.7) into Eq(1.10), we have\n\\\\[ \\begin{align} \\tag{1.11} L(g^{\\lambda} \\bmod n^2) = \\frac{\\lambda n}{n} \\equiv \\lambda \\bmod n^2\\end{align} \\\\]\nAt last, Eq(1.2) becomes （bu sub Eq1.9 and Eq1.11)\n\\\\[ \\begin{align}  m = \\frac{L(c^{\\lambda} \\bmod n^2)}{L(g^{\\lambda} \\bmod n^2)} \\bmod n = \\frac{m \\lambda}{\\lambda} \\equiv m \\bmod n \\end{align}\\\\]\n<b>proved!!!</b>\n\n5. Carmichael theorem\nIn number theory, a branch of mathematics, the Carmichael function \\\\(λ(n)\\\\) of a positive integer n is the smallest positive integer m such that \\\\(a^{m}\\equiv 1{\\pmod {n}}\\\\) (similar but different from Euler's totient function). Carmichael's λ function, the reduced totient function, and the least universal exponent function\n![carmichael theorem](/images/paillier/carmichael_thorem.png)\n![](/images/paillier/carmichael_thorem_2.png)\nlet \\\\( n = pq\\\\), where p and q are prime numbers; \\\\( \\phi(n)\\\\) is the Euler's totient function. Let \\\\(\\lambda(n)\\\\) denotes carmichael function. We have \\\\(\\phi(n)=(p-1)(q-1)\\\\) and \\\\( \\lambda(n)=\\phi(n) = (p-1)(q-1)\\\\).\n\nSince \\\\( |Z_{n^2}^{\\ast}| = \\phi(n^2) = n \\phi(n)\\\\) (according to Eq(0.1)). Thereby, for any \\\\( w \\in Z_{n^2}^{\\ast}\\\\)\n\\\\[ \\begin{align} \\tag{1.12} w^{n\\phi(n)} \\equiv w^{n\\\\lambda} \\equiv 1 \\bmod n^2 \\end{align}\\\\]\n\n\\\\[ \\begin{align} \\tag{1.13} w^{\\lambda} \\equiv 1 \\bmod n \\end{align}\\\\]\nEq(1.13) is just Carmichael's function\n\nBased on Carmichael's theorem\n\\\\[ \\lambda(n^2) = lcm(\\lambda(q^2),\\lambda(p^2)) = lcm(\\phi(q^2),\\phi(p^2)) = lcm(q(q-1), p(p-1)) = pq(lcm(p-1, q-1)) = n\\lambda(n) \\\\] \ntherefore, we have\n\n\\\\[w^{\\lambda(n^2)} = w ^{n\\lambda} \\equiv 1 \\bmod n^2\\\\]\n\n6. Addition homomorphic\n![homomorphic addition](/images/paillier/homomorphic_addition.png)\n\n7. Multiplication homomorphic \n![homomorphic multiplication](/images/paillier/homomorphic_mul.png)\n## references\n- [csdn post](https://blog.csdn.net/qq_42328228/article/details/109349590)","slug":"paillier-encryption","published":1,"updated":"2023-04-24T06:31:44.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tm000a6usjg8vd43xw","content":"<script\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n  type=\"text/javascript\">\n</script>\n\n<h2 id=\"fundamentals\"><a href=\"#fundamentals\" class=\"headerlink\" title=\"fundamentals\"></a>fundamentals</h2><ol>\n<li>fundamental theorem of arighmetic<br>the fundamental theorem of arithmetic, also called the unique factorization theorem and prime factorization theorem, states that every integer greater than 1 can be represented uniquely as a product of prime numbers, up to the order of the factors <a href=\"https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic\">wiki</a></li>\n<li>Euler’s totient function<br>In number theory, Euler’s totient function counts the positive integers up to a given integer n that are relatively prime to n. It is written using the Greek letter phi as \\( \\phi (n) \\), and may also be called Euler’s phi function. In other words, it is the number of integers k in the range 1 ≤ k ≤ n for which the greatest common divisor gcd(n, k) is equal to 1. The integers k of this form are sometimes referred to as totatives of n. the collection of k is denoted by \\( Z_{n}^{\\ast } \\), and \\[ \\phi(n) &#x3D; |Z_n^{\\ast }| \\]</li>\n<li>if p is prime, then \\( Z_p^{\\ast } &#x3D; Z_p \\), \\( \\phi(p) &#x3D; p-1 \\)</li>\n<li>if p is prime, for any integer r, then \\( \\begin{align} \\tag{0.1} \\phi(p^{r}) &#x3D;p^{r-1}\\phi(p)&#x3D;p^{r-1}(p-1)\\end{align} \\)</li>\n<li>Euler’s totient function is a multiplicative function, meaning that if two numbers m and n are relatively prime, then \\(\\phi(mn) &#x3D; \\phi(m)\\phi(n)\\)</li>\n<li>Euler’s product formula, it states<br>\\[ \\phi(n) &#x3D; n  \\prod_{p|n}^{}(1-\\frac{1}{p}) \\]<br>where the product is over the distinct prime numbers dividing n.</li>\n<li>Euler’s theorem<br>if \\(a\\) and \\(n\\) are coprime positive integers, and \\( \\phi(n)\\) is Euler’s totient function, then \\(a\\) raised to the power  \\(\\phi(n)\\) is congruent to 1 modulo n; that is<br>\\[a^{\\phi(n)} \\equiv 1 \\bmod n\\]</li>\n<li>according to 7, we have \\( a \\cdot a^{\\phi(n)-1} \\equiv 1 \\bmod n \\). then<br>\\[ a^{-1} &#x3D; a^{\\phi(n)-1} \\]</li>\n<li>Fermat’s little theorem<br>Fermat’s little theorem states that if p is a prime number, then for any integer a, the number<br>\\(a^{p}-a \\) is an integer multiple of p. In the notation of modular arithmetic, this is expressed as<br>\\[ a^{p} \\equiv a \\bmod p\\]</li>\n<li>Binomial theorem<br>it states<br>\\[ y &#x3D; (1+n)^{x} &#x3D; \\sum_{k&#x3D;0}^{x}\\tbinom{x}{k}n^{k} &#x3D; 1 + nx + \\tbinom{x}{2}n^2 + …\\]<br>observe that, the higher degree could be divided by \\(n^2\\). we have<br>\\[ \\begin{align} \\tag{0.2} (1+n)^{x} \\equiv 1 + nx \\bmod n^2 \\end{align} \\]<br>therefore, \\( y - 1 \\equiv nx \\bmod n^2 \\). then we have<br>\\[ x \\equiv \\frac{y-1}{n} \\bmod n \\].<br>In paillier, later we define \\( \\begin{align} \\tag{0.3} L(y) &#x3D; \\frac{y-1}{n} \\end{align} \\)<br>therefore<br>\\[ L(y \\bmod n^2) \\equiv x \\bmod n \\]</li>\n</ol>\n<h2 id=\"Paillier\"><a href=\"#Paillier\" class=\"headerlink\" title=\"Paillier\"></a>Paillier</h2><ol>\n<li><p>key generation<br><code>KeyGen() -&gt; (pk, sk)</code><br>randomly select two big prime numbers \\(p, q\\). it shoud satisfy \\(gcd(pq, (p-1)(q-1)) &#x3D;1 \\), \\(p\\) and \\(q\\) should have similar bit length. let \\( n &#x3D; pq \\), \\(\\lambda &#x3D; lcm(p-1, q-1)\\). randomly sample \\( g \\in Z_{n^2}^{\\ast}\\). to simplify, let \\( g &#x3D; n+1\\). we have<br>\\[ pk&#x3D;(n,g) \\]<br>\\[ sk &#x3D; (\\lambda)\\]</p>\n</li>\n<li><p>encryption<br><code>Enc(pk, m) -&gt; c</code><br>randomly sample \\( r \\in Z_{n}^{\\ast}\\), then also have \\( r \\in Z_{n^2}^{\\ast}\\), cypher is calculated<br>\\[ \\begin{align} \\tag{1.1} c &#x3D; g^mr^n  \\bmod n^2 \\end{align} \\]</p>\n</li>\n<li><p>Decryption<br><code>Dec(sk, c) -&gt; m</code><br>Let \\(L(x) &#x3D; \\frac{x-1}{n} \\), we have message<br>\\[ \\begin{align} \\tag{1.2} m &#x3D; \\frac{L(c^{\\lambda} \\bmod n^2)}{L(g^{\\lambda} \\bmod n^2)} \\bmod n \\end{align}\\]</p>\n</li>\n<li><p>proof of correctness<br>based on Eq(1), we have \\[ \\begin{align} \\tag{1.3} c^{\\lambda} \\bmod n^2 &#x3D; g^{m\\lambda}r^{n\\lambda} \\bmod n^2 \\end{align}\\]<br>where \\( r^{n\\lambda} \\bmod n^2 \\equiv 1 \\bmod n^2\\), which is proved by Carmichael theorem later on. then Eq(3) becomes<br> \\[ \\begin{align} \\tag{1.4} c^{\\lambda} \\bmod n^2 &#x3D; g^{m\\lambda}\\bmod n^2 \\end{align}\\]<br>since \\( g &#x3D; n+1\\), we have<br>\\[ \\begin{align} \\tag{1.5} c^{\\lambda} \\bmod n^2 &#x3D; (1+n)^{m\\lambda}\\bmod n^2 \\end{align}\\]<br>According to Eq(0.2), we have<br>\\[ \\begin{align} \\tag{1.6} c^{\\lambda} \\bmod n^2 &#x3D; 1 + nm\\lambda \\bmod n^2 \\end{align}\\]<br>\\[ \\begin{align} \\tag{1.7} g^{\\lambda} \\bmod n^2 \\equiv (1+n)^{\\lambda} \\bmod n^2 &#x3D; 1 +\\lambda n \\bmod n^2 \\end{align}\\]<br>therefore, based on definition given by Eq(0.3) we have<br>\\[ \\begin{align} \\tag{1.8} L(c^{\\lambda} \\bmod n^2) &#x3D; \\frac{c^{\\lambda}-1}{n} \\bmod n^2 \\end{align} \\]<br>Substitute Eq(1.6) into Eq(1.8), we have<br>\\[ \\begin{align} \\tag{1.9} L(c^{\\lambda} \\bmod n^2) &#x3D; m\\lambda \\bmod n^2 \\end{align} \\]<br>Further, we have<br>\\[ \\begin{align} \\tag{1.10} L(g^{\\lambda} \\bmod n^2) &#x3D; \\frac{g^\\lambda -1}{n} \\end{align} \\]<br>Sub Eq(1.7) into Eq(1.10), we have<br>\\[ \\begin{align} \\tag{1.11} L(g^{\\lambda} \\bmod n^2) &#x3D; \\frac{\\lambda n}{n} \\equiv \\lambda \\bmod n^2\\end{align} \\]<br>At last, Eq(1.2) becomes （bu sub Eq1.9 and Eq1.11)<br>\\[ \\begin{align}  m &#x3D; \\frac{L(c^{\\lambda} \\bmod n^2)}{L(g^{\\lambda} \\bmod n^2)} \\bmod n &#x3D; \\frac{m \\lambda}{\\lambda} \\equiv m \\bmod n \\end{align}\\]<br><b>proved!!!</b></p>\n</li>\n<li><p>Carmichael theorem<br>In number theory, a branch of mathematics, the Carmichael function \\(λ(n)\\) of a positive integer n is the smallest positive integer m such that \\(a^{m}\\equiv 1{\\pmod {n}}\\) (similar but different from Euler’s totient function). Carmichael’s λ function, the reduced totient function, and the least universal exponent function<br><img src=\"/images/paillier/carmichael_thorem.png\" alt=\"carmichael theorem\"><br><img src=\"/images/paillier/carmichael_thorem_2.png\"><br>let \\( n &#x3D; pq\\), where p and q are prime numbers; \\( \\phi(n)\\) is the Euler’s totient function. Let \\(\\lambda(n)\\) denotes carmichael function. We have \\(\\phi(n)&#x3D;(p-1)(q-1)\\) and \\( \\lambda(n)&#x3D;\\phi(n) &#x3D; (p-1)(q-1)\\).</p>\n</li>\n</ol>\n<p>Since \\( |Z_{n^2}^{\\ast}| &#x3D; \\phi(n^2) &#x3D; n \\phi(n)\\) (according to Eq(0.1)). Thereby, for any \\( w \\in Z_{n^2}^{\\ast}\\)<br>\\[ \\begin{align} \\tag{1.12} w^{n\\phi(n)} \\equiv w^{n\\lambda} \\equiv 1 \\bmod n^2 \\end{align}\\]</p>\n<p>\\[ \\begin{align} \\tag{1.13} w^{\\lambda} \\equiv 1 \\bmod n \\end{align}\\]<br>Eq(1.13) is just Carmichael’s function</p>\n<p>Based on Carmichael’s theorem<br>\\[ \\lambda(n^2) &#x3D; lcm(\\lambda(q^2),\\lambda(p^2)) &#x3D; lcm(\\phi(q^2),\\phi(p^2)) &#x3D; lcm(q(q-1), p(p-1)) &#x3D; pq(lcm(p-1, q-1)) &#x3D; n\\lambda(n) \\]<br>therefore, we have</p>\n<p>\\[w^{\\lambda(n^2)} &#x3D; w ^{n\\lambda} \\equiv 1 \\bmod n^2\\]</p>\n<ol start=\"6\">\n<li><p>Addition homomorphic<br><img src=\"/images/paillier/homomorphic_addition.png\" alt=\"homomorphic addition\"></p>\n</li>\n<li><p>Multiplication homomorphic<br><img src=\"/images/paillier/homomorphic_mul.png\" alt=\"homomorphic multiplication\"></p>\n</li>\n</ol>\n<h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_42328228/article/details/109349590\">csdn post</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<script\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n  type=\"text/javascript\">\n</script>\n\n<h2 id=\"fundamentals\"><a href=\"#fundamentals\" class=\"headerlink\" title=\"fundamentals\"></a>fundamentals</h2><ol>\n<li>fundamental theorem of arighmetic<br>the fundamental theorem of arithmetic, also called the unique factorization theorem and prime factorization theorem, states that every integer greater than 1 can be represented uniquely as a product of prime numbers, up to the order of the factors <a href=\"https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic\">wiki</a></li>\n<li>Euler’s totient function<br>In number theory, Euler’s totient function counts the positive integers up to a given integer n that are relatively prime to n. It is written using the Greek letter phi as \\( \\phi (n) \\), and may also be called Euler’s phi function. In other words, it is the number of integers k in the range 1 ≤ k ≤ n for which the greatest common divisor gcd(n, k) is equal to 1. The integers k of this form are sometimes referred to as totatives of n. the collection of k is denoted by \\( Z_{n}^{\\ast } \\), and \\[ \\phi(n) &#x3D; |Z_n^{\\ast }| \\]</li>\n<li>if p is prime, then \\( Z_p^{\\ast } &#x3D; Z_p \\), \\( \\phi(p) &#x3D; p-1 \\)</li>\n<li>if p is prime, for any integer r, then \\( \\begin{align} \\tag{0.1} \\phi(p^{r}) &#x3D;p^{r-1}\\phi(p)&#x3D;p^{r-1}(p-1)\\end{align} \\)</li>\n<li>Euler’s totient function is a multiplicative function, meaning that if two numbers m and n are relatively prime, then \\(\\phi(mn) &#x3D; \\phi(m)\\phi(n)\\)</li>\n<li>Euler’s product formula, it states<br>\\[ \\phi(n) &#x3D; n  \\prod_{p|n}^{}(1-\\frac{1}{p}) \\]<br>where the product is over the distinct prime numbers dividing n.</li>\n<li>Euler’s theorem<br>if \\(a\\) and \\(n\\) are coprime positive integers, and \\( \\phi(n)\\) is Euler’s totient function, then \\(a\\) raised to the power  \\(\\phi(n)\\) is congruent to 1 modulo n; that is<br>\\[a^{\\phi(n)} \\equiv 1 \\bmod n\\]</li>\n<li>according to 7, we have \\( a \\cdot a^{\\phi(n)-1} \\equiv 1 \\bmod n \\). then<br>\\[ a^{-1} &#x3D; a^{\\phi(n)-1} \\]</li>\n<li>Fermat’s little theorem<br>Fermat’s little theorem states that if p is a prime number, then for any integer a, the number<br>\\(a^{p}-a \\) is an integer multiple of p. In the notation of modular arithmetic, this is expressed as<br>\\[ a^{p} \\equiv a \\bmod p\\]</li>\n<li>Binomial theorem<br>it states<br>\\[ y &#x3D; (1+n)^{x} &#x3D; \\sum_{k&#x3D;0}^{x}\\tbinom{x}{k}n^{k} &#x3D; 1 + nx + \\tbinom{x}{2}n^2 + …\\]<br>observe that, the higher degree could be divided by \\(n^2\\). we have<br>\\[ \\begin{align} \\tag{0.2} (1+n)^{x} \\equiv 1 + nx \\bmod n^2 \\end{align} \\]<br>therefore, \\( y - 1 \\equiv nx \\bmod n^2 \\). then we have<br>\\[ x \\equiv \\frac{y-1}{n} \\bmod n \\].<br>In paillier, later we define \\( \\begin{align} \\tag{0.3} L(y) &#x3D; \\frac{y-1}{n} \\end{align} \\)<br>therefore<br>\\[ L(y \\bmod n^2) \\equiv x \\bmod n \\]</li>\n</ol>\n<h2 id=\"Paillier\"><a href=\"#Paillier\" class=\"headerlink\" title=\"Paillier\"></a>Paillier</h2><ol>\n<li><p>key generation<br><code>KeyGen() -&gt; (pk, sk)</code><br>randomly select two big prime numbers \\(p, q\\). it shoud satisfy \\(gcd(pq, (p-1)(q-1)) &#x3D;1 \\), \\(p\\) and \\(q\\) should have similar bit length. let \\( n &#x3D; pq \\), \\(\\lambda &#x3D; lcm(p-1, q-1)\\). randomly sample \\( g \\in Z_{n^2}^{\\ast}\\). to simplify, let \\( g &#x3D; n+1\\). we have<br>\\[ pk&#x3D;(n,g) \\]<br>\\[ sk &#x3D; (\\lambda)\\]</p>\n</li>\n<li><p>encryption<br><code>Enc(pk, m) -&gt; c</code><br>randomly sample \\( r \\in Z_{n}^{\\ast}\\), then also have \\( r \\in Z_{n^2}^{\\ast}\\), cypher is calculated<br>\\[ \\begin{align} \\tag{1.1} c &#x3D; g^mr^n  \\bmod n^2 \\end{align} \\]</p>\n</li>\n<li><p>Decryption<br><code>Dec(sk, c) -&gt; m</code><br>Let \\(L(x) &#x3D; \\frac{x-1}{n} \\), we have message<br>\\[ \\begin{align} \\tag{1.2} m &#x3D; \\frac{L(c^{\\lambda} \\bmod n^2)}{L(g^{\\lambda} \\bmod n^2)} \\bmod n \\end{align}\\]</p>\n</li>\n<li><p>proof of correctness<br>based on Eq(1), we have \\[ \\begin{align} \\tag{1.3} c^{\\lambda} \\bmod n^2 &#x3D; g^{m\\lambda}r^{n\\lambda} \\bmod n^2 \\end{align}\\]<br>where \\( r^{n\\lambda} \\bmod n^2 \\equiv 1 \\bmod n^2\\), which is proved by Carmichael theorem later on. then Eq(3) becomes<br> \\[ \\begin{align} \\tag{1.4} c^{\\lambda} \\bmod n^2 &#x3D; g^{m\\lambda}\\bmod n^2 \\end{align}\\]<br>since \\( g &#x3D; n+1\\), we have<br>\\[ \\begin{align} \\tag{1.5} c^{\\lambda} \\bmod n^2 &#x3D; (1+n)^{m\\lambda}\\bmod n^2 \\end{align}\\]<br>According to Eq(0.2), we have<br>\\[ \\begin{align} \\tag{1.6} c^{\\lambda} \\bmod n^2 &#x3D; 1 + nm\\lambda \\bmod n^2 \\end{align}\\]<br>\\[ \\begin{align} \\tag{1.7} g^{\\lambda} \\bmod n^2 \\equiv (1+n)^{\\lambda} \\bmod n^2 &#x3D; 1 +\\lambda n \\bmod n^2 \\end{align}\\]<br>therefore, based on definition given by Eq(0.3) we have<br>\\[ \\begin{align} \\tag{1.8} L(c^{\\lambda} \\bmod n^2) &#x3D; \\frac{c^{\\lambda}-1}{n} \\bmod n^2 \\end{align} \\]<br>Substitute Eq(1.6) into Eq(1.8), we have<br>\\[ \\begin{align} \\tag{1.9} L(c^{\\lambda} \\bmod n^2) &#x3D; m\\lambda \\bmod n^2 \\end{align} \\]<br>Further, we have<br>\\[ \\begin{align} \\tag{1.10} L(g^{\\lambda} \\bmod n^2) &#x3D; \\frac{g^\\lambda -1}{n} \\end{align} \\]<br>Sub Eq(1.7) into Eq(1.10), we have<br>\\[ \\begin{align} \\tag{1.11} L(g^{\\lambda} \\bmod n^2) &#x3D; \\frac{\\lambda n}{n} \\equiv \\lambda \\bmod n^2\\end{align} \\]<br>At last, Eq(1.2) becomes （bu sub Eq1.9 and Eq1.11)<br>\\[ \\begin{align}  m &#x3D; \\frac{L(c^{\\lambda} \\bmod n^2)}{L(g^{\\lambda} \\bmod n^2)} \\bmod n &#x3D; \\frac{m \\lambda}{\\lambda} \\equiv m \\bmod n \\end{align}\\]<br><b>proved!!!</b></p>\n</li>\n<li><p>Carmichael theorem<br>In number theory, a branch of mathematics, the Carmichael function \\(λ(n)\\) of a positive integer n is the smallest positive integer m such that \\(a^{m}\\equiv 1{\\pmod {n}}\\) (similar but different from Euler’s totient function). Carmichael’s λ function, the reduced totient function, and the least universal exponent function<br><img src=\"/images/paillier/carmichael_thorem.png\" alt=\"carmichael theorem\"><br><img src=\"/images/paillier/carmichael_thorem_2.png\"><br>let \\( n &#x3D; pq\\), where p and q are prime numbers; \\( \\phi(n)\\) is the Euler’s totient function. Let \\(\\lambda(n)\\) denotes carmichael function. We have \\(\\phi(n)&#x3D;(p-1)(q-1)\\) and \\( \\lambda(n)&#x3D;\\phi(n) &#x3D; (p-1)(q-1)\\).</p>\n</li>\n</ol>\n<p>Since \\( |Z_{n^2}^{\\ast}| &#x3D; \\phi(n^2) &#x3D; n \\phi(n)\\) (according to Eq(0.1)). Thereby, for any \\( w \\in Z_{n^2}^{\\ast}\\)<br>\\[ \\begin{align} \\tag{1.12} w^{n\\phi(n)} \\equiv w^{n\\lambda} \\equiv 1 \\bmod n^2 \\end{align}\\]</p>\n<p>\\[ \\begin{align} \\tag{1.13} w^{\\lambda} \\equiv 1 \\bmod n \\end{align}\\]<br>Eq(1.13) is just Carmichael’s function</p>\n<p>Based on Carmichael’s theorem<br>\\[ \\lambda(n^2) &#x3D; lcm(\\lambda(q^2),\\lambda(p^2)) &#x3D; lcm(\\phi(q^2),\\phi(p^2)) &#x3D; lcm(q(q-1), p(p-1)) &#x3D; pq(lcm(p-1, q-1)) &#x3D; n\\lambda(n) \\]<br>therefore, we have</p>\n<p>\\[w^{\\lambda(n^2)} &#x3D; w ^{n\\lambda} \\equiv 1 \\bmod n^2\\]</p>\n<ol start=\"6\">\n<li><p>Addition homomorphic<br><img src=\"/images/paillier/homomorphic_addition.png\" alt=\"homomorphic addition\"></p>\n</li>\n<li><p>Multiplication homomorphic<br><img src=\"/images/paillier/homomorphic_mul.png\" alt=\"homomorphic multiplication\"></p>\n</li>\n</ol>\n<h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_42328228/article/details/109349590\">csdn post</a></li>\n</ul>\n"},{"title":"how to use hexo","date":"2022-11-27T03:47:56.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: how to use hexo\ndate: 2022-11-27 11:47:56\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2023-04-06T16:43:39.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tn000c6usj7sbxgptg","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"rust resource","date":"2022-09-27T14:04:38.000Z","_content":"\n## learning resources\n- [the book](https://doc.rust-lang.org/book/)\n- [cargo book](https://doc.rust-lang.org/cargo/index.html)\n- [the rust performance book](https://nnethercote.github.io/perf-book/title-page.html)\n- [rust design patterns](https://rust-unofficial.github.io/patterns/intro.html)\n- [the rust RFC book](https://rust-lang.github.io/rfcs/)\n- [the rustdoc book](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html)\n- [rustnomicon](https://doc.rust-lang.org/nomicon/intro.html)\n- [the rust reference](https://doc.rust-lang.org/reference/introduction.html)\n- [rust by example](https://doc.rust-lang.org/rust-by-example/index.html)\n- [async programming in rust](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html)\n- [rust compiler development guide](https://rustc-dev-guide.rust-lang.org/about-this-guide.html)\n- [the little book of rust macros](https://veykril.github.io/tlborm/)","source":"_posts/rust-01-resource.md","raw":"---\ntitle: rust resource\ndate: 2022-09-27 22:04:38\ntags: [rust]\n---\n\n## learning resources\n- [the book](https://doc.rust-lang.org/book/)\n- [cargo book](https://doc.rust-lang.org/cargo/index.html)\n- [the rust performance book](https://nnethercote.github.io/perf-book/title-page.html)\n- [rust design patterns](https://rust-unofficial.github.io/patterns/intro.html)\n- [the rust RFC book](https://rust-lang.github.io/rfcs/)\n- [the rustdoc book](https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html)\n- [rustnomicon](https://doc.rust-lang.org/nomicon/intro.html)\n- [the rust reference](https://doc.rust-lang.org/reference/introduction.html)\n- [rust by example](https://doc.rust-lang.org/rust-by-example/index.html)\n- [async programming in rust](https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html)\n- [rust compiler development guide](https://rustc-dev-guide.rust-lang.org/about-this-guide.html)\n- [the little book of rust macros](https://veykril.github.io/tlborm/)","slug":"rust-01-resource","published":1,"updated":"2023-05-01T14:18:41.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tn000d6usjb24y5x0k","content":"<h2 id=\"learning-resources\"><a href=\"#learning-resources\" class=\"headerlink\" title=\"learning resources\"></a>learning resources</h2><ul>\n<li><a href=\"https://doc.rust-lang.org/book/\">the book</a></li>\n<li><a href=\"https://doc.rust-lang.org/cargo/index.html\">cargo book</a></li>\n<li><a href=\"https://nnethercote.github.io/perf-book/title-page.html\">the rust performance book</a></li>\n<li><a href=\"https://rust-unofficial.github.io/patterns/intro.html\">rust design patterns</a></li>\n<li><a href=\"https://rust-lang.github.io/rfcs/\">the rust RFC book</a></li>\n<li><a href=\"https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html\">the rustdoc book</a></li>\n<li><a href=\"https://doc.rust-lang.org/nomicon/intro.html\">rustnomicon</a></li>\n<li><a href=\"https://doc.rust-lang.org/reference/introduction.html\">the rust reference</a></li>\n<li><a href=\"https://doc.rust-lang.org/rust-by-example/index.html\">rust by example</a></li>\n<li><a href=\"https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html\">async programming in rust</a></li>\n<li><a href=\"https://rustc-dev-guide.rust-lang.org/about-this-guide.html\">rust compiler development guide</a></li>\n<li><a href=\"https://veykril.github.io/tlborm/\">the little book of rust macros</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"learning-resources\"><a href=\"#learning-resources\" class=\"headerlink\" title=\"learning resources\"></a>learning resources</h2><ul>\n<li><a href=\"https://doc.rust-lang.org/book/\">the book</a></li>\n<li><a href=\"https://doc.rust-lang.org/cargo/index.html\">cargo book</a></li>\n<li><a href=\"https://nnethercote.github.io/perf-book/title-page.html\">the rust performance book</a></li>\n<li><a href=\"https://rust-unofficial.github.io/patterns/intro.html\">rust design patterns</a></li>\n<li><a href=\"https://rust-lang.github.io/rfcs/\">the rust RFC book</a></li>\n<li><a href=\"https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html\">the rustdoc book</a></li>\n<li><a href=\"https://doc.rust-lang.org/nomicon/intro.html\">rustnomicon</a></li>\n<li><a href=\"https://doc.rust-lang.org/reference/introduction.html\">the rust reference</a></li>\n<li><a href=\"https://doc.rust-lang.org/rust-by-example/index.html\">rust by example</a></li>\n<li><a href=\"https://rust-lang.github.io/async-book/01_getting_started/01_chapter.html\">async programming in rust</a></li>\n<li><a href=\"https://rustc-dev-guide.rust-lang.org/about-this-guide.html\">rust compiler development guide</a></li>\n<li><a href=\"https://veykril.github.io/tlborm/\">the little book of rust macros</a></li>\n</ul>\n"},{"title":"rust memory layout","date":"2022-10-25T02:54:13.000Z","_content":"\n\n## trait object\na reference to a trait type (or Box<Mytrait>) is called trait object\n\n### two ways convert concrete type to trait object\n1. assigning to variable\n```rust\nuse std::io::Write;\n\nlet mut buffer: Vec<u8> = vec![];\nlet w: &mut dyn Write = &mut buffer;\n```\n2. pass a concrete type as a argument to a function\n```rust\nfn main() {\n   let mut buffer: Vec<u8> = vec![];\n   writer(&mut buffer);\n}\n\nfn writer(w: &mut dyn Write) {\n    // ...\n}\n```\nin both ways, buffer is converted to a trait object implements Write\n\nin memory, a trait object (in the example, w) is a fat point consists two pointers\n![trait_object_memory](/images/rust/memory/trait_object_memory.png)\nthe vtable is generated once at compile time and shared by all objects of the same type. the vtable contains pointers to the machine code of the functions that must be present for a type to be a \"Writer\"\n\n\n## references\n- https://www.youtube.com/watch?v=rDoqT-a6UFg","source":"_posts/rust-05-memory-layout.md","raw":"---\ntitle: rust memory layout\ndate: 2022-10-25 10:54:13\ntags: [rust]\n---\n\n\n## trait object\na reference to a trait type (or Box<Mytrait>) is called trait object\n\n### two ways convert concrete type to trait object\n1. assigning to variable\n```rust\nuse std::io::Write;\n\nlet mut buffer: Vec<u8> = vec![];\nlet w: &mut dyn Write = &mut buffer;\n```\n2. pass a concrete type as a argument to a function\n```rust\nfn main() {\n   let mut buffer: Vec<u8> = vec![];\n   writer(&mut buffer);\n}\n\nfn writer(w: &mut dyn Write) {\n    // ...\n}\n```\nin both ways, buffer is converted to a trait object implements Write\n\nin memory, a trait object (in the example, w) is a fat point consists two pointers\n![trait_object_memory](/images/rust/memory/trait_object_memory.png)\nthe vtable is generated once at compile time and shared by all objects of the same type. the vtable contains pointers to the machine code of the functions that must be present for a type to be a \"Writer\"\n\n\n## references\n- https://www.youtube.com/watch?v=rDoqT-a6UFg","slug":"rust-05-memory-layout","published":1,"updated":"2023-05-03T02:57:52.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tn000f6usj3zg9fmwl","content":"<h2 id=\"trait-object\"><a href=\"#trait-object\" class=\"headerlink\" title=\"trait object\"></a>trait object</h2><p>a reference to a trait type (or Box<Mytrait>) is called trait object</p>\n<h3 id=\"two-ways-convert-concrete-type-to-trait-object\"><a href=\"#two-ways-convert-concrete-type-to-trait-object\" class=\"headerlink\" title=\"two ways convert concrete type to trait object\"></a>two ways convert concrete type to trait object</h3><ol>\n<li>assigning to variable<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::io::Write;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">buffer</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">u8</span>&gt; = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">w</span>: &amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">dyn</span> Write = &amp;<span class=\"keyword\">mut</span> buffer;</span><br></pre></td></tr></table></figure></li>\n<li>pass a concrete type as a argument to a function<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">buffer</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">u8</span>&gt; = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">   <span class=\"title function_ invoke__\">writer</span>(&amp;<span class=\"keyword\">mut</span> buffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">writer</span>(w: &amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">dyn</span> Write) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nin both ways, buffer is converted to a trait object implements Write</li>\n</ol>\n<p>in memory, a trait object (in the example, w) is a fat point consists two pointers<br><img src=\"/images/rust/memory/trait_object_memory.png\" alt=\"trait_object_memory\"><br>the vtable is generated once at compile time and shared by all objects of the same type. the vtable contains pointers to the machine code of the functions that must be present for a type to be a “Writer”</p>\n<h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=rDoqT-a6UFg\">https://www.youtube.com/watch?v=rDoqT-a6UFg</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"trait-object\"><a href=\"#trait-object\" class=\"headerlink\" title=\"trait object\"></a>trait object</h2><p>a reference to a trait type (or Box<Mytrait>) is called trait object</p>\n<h3 id=\"two-ways-convert-concrete-type-to-trait-object\"><a href=\"#two-ways-convert-concrete-type-to-trait-object\" class=\"headerlink\" title=\"two ways convert concrete type to trait object\"></a>two ways convert concrete type to trait object</h3><ol>\n<li>assigning to variable<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::io::Write;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">buffer</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">u8</span>&gt; = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">w</span>: &amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">dyn</span> Write = &amp;<span class=\"keyword\">mut</span> buffer;</span><br></pre></td></tr></table></figure></li>\n<li>pass a concrete type as a argument to a function<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">buffer</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">u8</span>&gt; = <span class=\"built_in\">vec!</span>[];</span><br><span class=\"line\">   <span class=\"title function_ invoke__\">writer</span>(&amp;<span class=\"keyword\">mut</span> buffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">writer</span>(w: &amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">dyn</span> Write) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nin both ways, buffer is converted to a trait object implements Write</li>\n</ol>\n<p>in memory, a trait object (in the example, w) is a fat point consists two pointers<br><img src=\"/images/rust/memory/trait_object_memory.png\" alt=\"trait_object_memory\"><br>the vtable is generated once at compile time and shared by all objects of the same type. the vtable contains pointers to the machine code of the functions that must be present for a type to be a “Writer”</p>\n<h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ul>\n<li><a href=\"https://www.youtube.com/watch?v=rDoqT-a6UFg\">https://www.youtube.com/watch?v=rDoqT-a6UFg</a></li>\n</ul>\n"},{"title":"rust basics","date":"2022-10-04T07:55:04.000Z","_content":"\n## frequently used cmd\n```\nrustc [filename].rs\ncargo new [project_name]\ncargo build [--release]\ncargo run [--release]\ncargo check # check whether compile success, no executible output\n```\n\n## data type\n\n### integer\n- i8,i16,i32,i64,i128,isize,u8,u16,u32,u64,u128,usize，etc\n- isize, usize indicates that the type is determined by the architecture of the computer. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.\n- 0x: hex，0o Octal，0b binary，starting with b: byte （u8 only）\n\n| Number Literals      | Example |\n| ----------- | ----------- |\n| Decimal      | 98_222       |\n| Hex   | 0xff        |\n| Octal   | 0o77        |\n| Binary   | 0b1111_0000        |\n| Byte(u8 only)   | b'A'        |\n\n### Tuple\n- The length of Tuple is fixed, and the length cannot be changed once declared\n```rust\nfn main() {\n    // tuple could be declared as mut\n    let mut tuple_1 = (\"Hello\", 39, \"Years\");\n    let tuple_2:(i32, &str ) = (1983, \"since.\");\n    tuple_1.0 = \"Hi\";\n    println!(\"{} {} {}\", tuple_1.0, tuple_1.1, tuple_1.2);\n    // destructure\n    let (a,b) = tuple_2;\n    println!(\"{} {}\", a, b);\n}\n```\n\n### array\n- arrays in Rust have a fixed length.\n- Vector is similar to an array, it is provided by the standard library, and its length can be changed\n\n```rust\nfn main() {\n\n    let arr_test:[u8; 3] = [1,2,3];\n    println!(\"Number is {},{},{}\", arr_test[0],arr_test[1],arr_test[2]);\n\n    let arr_test = [\"I\",\"love\",\"you\"];\n    println!(\"You said : {} {} {}\", arr_test[0],arr_test[1],arr_test[2]);\n\n    let arr_test = [1;3]; \n    println!(\"Call Num : {}&{}&{}\", arr_test[0],arr_test[1],arr_test[2]);\n}\n```\n\n\n\n### String\n- Basic data types are stored on the stack, but the String type is stored on the heap\n```rust\nlet s = String::from(\"hello\");\n```\n- push_str(): append a str slice a string\n- push(): appends a single character to a String\n```rust\nfn main() { \n    let mut data = String::from(\"andy\");\n    data.push_str(\" is stronger\");\n    data.push('!');\n}\n```\n- <code>+</code> operator, chaining strings. the left side of the + operator is the ownership of the string, and the right side is the string slice\n- String is actually a wrapper for Vec<u8>, so the length can be measured by the len() method, but note that Len() is not length of character, but byte len\n- String iteration\n```rust\nfn main() { \n    let mut data = String::from(\"andy\");\n    data.push_str(\" is stronger\");\n    data.push('!');\n\n    for i in data.bytes() {\n        ///\n    }\n\n    for i in data.chars() {\n        ///\n    }\n}\n```\n\n### Vector\n- Vector is like any other struct. When Vector leaves the scope, the variable value is cleaned up, and all its elements are also cleaned up.\n```rust\nfn main() {\n    let vec: Vec<u16> = Vec::new();\n    let vec2: Vec<i32> = vec![3,4，5] // create vector by macro\n    for i in vec2 {\n        println!(\"Vector value is : {}\", i);\n    }\n}\n```\n\n### HashMap\n- HashMap is not preloaded, so it needs to be included  `use std::collections::HashMap`\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let keys = vec![\"andy\".to_string(), \"cliff\".to_string()] ;\n    let ages = vec![38, 26];\n    let map :HashMap<_,_> = keys.iter().zip(ages.iter()).collect();\n    println!(\"{:?}\", map); /// print {\"andy\": 38, \"cliff\": 26}\n}\n```\n#### HashMap ownership\n- For types that implement the Copy trait (such as i32), the value will be copied into the HashMap\n- For values with ownership, such as (String), the value will be moved and ownership will be given to HashMap\n- If a reference to a value is inserted into the HashMap, the value itself does not move\n\n#### HashMap iteration\n```rust\nuse std::collections::HashMap;\n\nfn main() { \n    let name = \"andy\".to_string();\n    let age = 36;\n    let mut map = HashMap::new();\n    map.insert(name, age);\n    map.insert(String::from(\"cliff\"), 26);\n    println!(\"{:?}\", &map);\n    for (k, v) in map {\n        println!(\"{} age {}\", k, v);\n    } /// cliff age 26\n      /// andy age 36\n}\n```\n#### update\n```rust\nuse std::collections::HashMap;\n\nfn main() { \n    let name = \"andy\".to_string();\n    let age = 36;\n    let mut map = HashMap::new();\n    map.insert(name, age);\n    map.insert(String::from(\"cliff\"), 26);\n\n    let result = map.entry(\"bob\".to_string());\n    println!(\"{:?}\", result); /// Entry(VacantEntry(\"bob\"))\n\n    let result = map.entry(\"andy\".to_string());\n    println!(\"{:?}\", result); /// Entry(OccupiedEntry { key: \"andy\", value: 36, .. })\n\n    map.entry(\"bob\".to_string()).or_insert(28);\n    map.entry(\"cliff\".to_string()).or_insert(0);\n}\n```\n\n## control flow\n- if\n```rust\nfn main() {\n    let condition = 1;\n    let x = if condition == 1 { \"A\" } else { \"B\" };\n    println!(\"Result x = {}\" , x) ;\n}\n```\n- loop\n```rust\nfn main() {\n    let mut condition = 0;\n\n    let result = 'outer: loop {  // 'outer is label\n        'inner: loop {\n            condition += 1;\n            if 3 == condition {\n                break 'outer 3 * condition; // break outer loop\n            }\n        }\n    };\n    println!(\"Loop result is : {}\", result); /// Loop result is : 9\n}\n\n```\n- rot\n```rust\nfn main() {\n    let arr = [3,2,3];\n    for num in arr.iter() {\n        println!(\"For value is {}\", num);\n    }\n}\n```\n\n## Range iterator\n- Range\n```rust\nfn main() {\n     for number in (1..=3) {\n        println!(\"Number A is {}\", number ); /// 1,2,3\n    }\n \n    for number in (1..=3).rev() { /// rev means reverse,\n        println!(\"Number B is {}\", number ); /// 3,2,1\n    }\n}\n\n```\n\n## struct\n- If struct is declared mutable then all fields in the instance are mutable\n### tuple struct\n```rust\nstruct Color(i32,i32,i32);\nlet black = Color(0,0,0);\n```\n### Unit-Like struct\n```rust\nstruct Man {};\n```\n### struct method\n```rust\n\nfn main() {\n    let rec = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    let result = rec.area(); \n    println!(\"rectangle：{:?}，area is：{}\", rec, result);\n}\n\n\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32{\n        self.width * self.height\n    }\n}\n\n```\n### associative func（similar to static method）\n- You can define a function that does not take `self` as the first parameter in the impl block. This form is called an associated function, and the calling method is similar to `String::from()`\n```rust\nimpl Rectangle {\n    fn create_square(width: u32) -> Rectangle {\n        Rectangle {\n            width,\n            height: width,\n        }\n    }\n}\n```\n  \n## enum\n```rust\nenum Ip {\n    V4,\n    V6,\n}\n\nenum IpAddr {\n    V4(String),\n    V6(String),\n}\n``` \n\n## match\n- match must exhaust all possibilities\n- If there are too many matchings, you can also use \"_\" for wildcarding, but note that \"_\" must be placed at the end\n```rust\nenum Color {\n    Red,\n    Yellow,\n    Blue,\n}\nenum ColorWithVal {\n    Red(u8,u8,u8),\n    Yellow(u8,u8,u8),\n    Blue(u8,u8,u8),\n}\nfn main(){\n    let colour = Color::Blue;\n    match colour {\n        Color::Red => {\n            println!(\"Red colour.\");\n        },\n        _ => {\n            println!(\"Other colour.\");\n        }\n    }\n\n    let colour = ColorWithVal::Red(222,111,22);\n    match colour {\n        ColorWithVal::Red(r,g,b) => {\n            println!(\"Red colour. {},{},{}\", r,g,b);\n        },\n        _ => {\n            println!(\"Other colour.\");\n        }\n    }\n}\n```\n\n## if let\n```rust\nfn main(){\n    let colour = Color::Red(Some(222),Some(222),Some(222));\n\n    if let Color::Red(r,g,b) = colour {\n        println!(\"Red colour. {:?},{:?},{:?}\", r,g,b);\n    } else {\n        println!(\"Other colour.\");\n    }\n}\n```\n\n## Result<T,E>\n- Recoverable err via Result<T,E>, non-recoverable via panic!\n- upon panic!, the program will expand an error message, unwind, clean up the call stack (Stack) and finally exit the program\n- You can set panic = 'abort' in Cargo.toml to terminate the cleaning of the call stack\n```rust\n[profile.release]\npanic='abort'\n```\n- RUST_BACKTRACE = 1 prints detailed error messages in the stack\n```rust\nuse std::fs::File;\nfn main() { \n    let fp = File::open(\"hello.txt\");\n    let file = match fp {\n        Ok(file)=> {\n            file\n        },\n        Err(error) => panic!(\"file not found {:?} \", error),\n    };\n}\n```\n\n```rust\nuse std::{fs::File, io::ErrorKind};\nfn main() { \n    let fp = File::open(\"hello.txt\");\n    let file = match fp {\n        Ok(file)=> {\n            file\n        },\n        Err(error) => {\n            match error.kind() {\n                ErrorKind::NotFound => {\n                    match File::create(\"hello.txt\") {\n                        Ok(file) => {\n                            file\n                        },\n                        Err(err) => {\n                            panic!(\"file create error:{:?}\", &err);\n                        },\n                    }\n                },\n                oe => panic!(\"other error {:?}\", oe),\n            }\n        } ,\n    };\n}\n```\n```rust\nuse std::{fs::File, io::ErrorKind};\nfn main() { \n    let file = File::open(\"hello.txt\").unwrap_or_else(|err| {\n        if err.kind() == ErrorKind::NotFound {\n            File::create(\"hello.txt\").unwrap_or_else(|err|{\n                panic!(\"error：{:?}\", err);\n            })\n        }else{\n            panic!(\"other error：{:?}\", err);\n        }\n    });\n}\n```\n### unwrap && expect\n- If do not want to deal with Err, can use unwarp() method. If result is Ok(val), return val. If Err, then call the panic! macro.\n- expect can specify what the error message is, which is easier to debug\n\n### The question mark operator, ?\nWhen writing code that calls many functions that return the Result type, the error handling can be tedious. The question mark operator, ?, hides some of the boilerplate of propagating errors up the call stack.\n```rust\nlet mut file = File::create(\"my_best_friends.txt\")?;\n```\n\n## generic\n```rust\n#[derive(Debug)]\nstruct Point<T, U>  {\n   x : T,\n   y : U,\n}\nimpl <T, U> Point<T, U> {\n    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {\n        Point{x: self.x , y: other.y, }\n    }\n}\n```\n\n## trait\n### definition\n```rust\npub trait Summary {\n    fn summarize(&self) -> String {\n         \"... more\".to_string() /// default \n    }\n}\npub struct Tweet {\n    user_name :String,\n    replay_count :u32,\n    like_count :u32,\n}\nimpl Tweet {\n    fn like(&mut self) {\n        self.like_count += 1;\n    }\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{} like count :{} , replay count :{}\", &self.user_name, &self.replay_count, &self.like_count)\n    }\n}\n```\n\n### trait as arguments\n```rust\nfn notify_msg <T:Summary> (info: T) {\n    println!(\"summary : {}\", info.summarize() );\n}\nfn notify_msg (info: impl Summary + Display) {\n    println!(\"summary : {}\", info.summarize() );\n}\nfn notify_msg <T> (info: T) \nwhere \n    T: Summary + Display,\n{\n    println!(\"summary : {}\", info.summarize() );\n    println!(\"display implement info : {}\", info);\n}\n```\n### trait as return\n- impl Trait can only return the same type, if it returns a different type, even if the Trait is implemented, an error will be reported\n\n## references\n- [the rust programming language](https://doc.rust-lang.org/book/)\n- [mooc course](https://time.geekbang.org/course/intro/100060601?tab=catalog)\n- [bilibili tutorial](https://www.bilibili.com/video/BV1hp4y1k7SV?p=50&spm_id_from=pageDriver)\n- [jianshu notes](https://www.jianshu.com/p/30d917790298)","source":"_posts/rust-02-basics.md","raw":"---\ntitle: rust basics\ndate: 2022-10-04 15:55:04\ntags: [rust]\n---\n\n## frequently used cmd\n```\nrustc [filename].rs\ncargo new [project_name]\ncargo build [--release]\ncargo run [--release]\ncargo check # check whether compile success, no executible output\n```\n\n## data type\n\n### integer\n- i8,i16,i32,i64,i128,isize,u8,u16,u32,u64,u128,usize，etc\n- isize, usize indicates that the type is determined by the architecture of the computer. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.\n- 0x: hex，0o Octal，0b binary，starting with b: byte （u8 only）\n\n| Number Literals      | Example |\n| ----------- | ----------- |\n| Decimal      | 98_222       |\n| Hex   | 0xff        |\n| Octal   | 0o77        |\n| Binary   | 0b1111_0000        |\n| Byte(u8 only)   | b'A'        |\n\n### Tuple\n- The length of Tuple is fixed, and the length cannot be changed once declared\n```rust\nfn main() {\n    // tuple could be declared as mut\n    let mut tuple_1 = (\"Hello\", 39, \"Years\");\n    let tuple_2:(i32, &str ) = (1983, \"since.\");\n    tuple_1.0 = \"Hi\";\n    println!(\"{} {} {}\", tuple_1.0, tuple_1.1, tuple_1.2);\n    // destructure\n    let (a,b) = tuple_2;\n    println!(\"{} {}\", a, b);\n}\n```\n\n### array\n- arrays in Rust have a fixed length.\n- Vector is similar to an array, it is provided by the standard library, and its length can be changed\n\n```rust\nfn main() {\n\n    let arr_test:[u8; 3] = [1,2,3];\n    println!(\"Number is {},{},{}\", arr_test[0],arr_test[1],arr_test[2]);\n\n    let arr_test = [\"I\",\"love\",\"you\"];\n    println!(\"You said : {} {} {}\", arr_test[0],arr_test[1],arr_test[2]);\n\n    let arr_test = [1;3]; \n    println!(\"Call Num : {}&{}&{}\", arr_test[0],arr_test[1],arr_test[2]);\n}\n```\n\n\n\n### String\n- Basic data types are stored on the stack, but the String type is stored on the heap\n```rust\nlet s = String::from(\"hello\");\n```\n- push_str(): append a str slice a string\n- push(): appends a single character to a String\n```rust\nfn main() { \n    let mut data = String::from(\"andy\");\n    data.push_str(\" is stronger\");\n    data.push('!');\n}\n```\n- <code>+</code> operator, chaining strings. the left side of the + operator is the ownership of the string, and the right side is the string slice\n- String is actually a wrapper for Vec<u8>, so the length can be measured by the len() method, but note that Len() is not length of character, but byte len\n- String iteration\n```rust\nfn main() { \n    let mut data = String::from(\"andy\");\n    data.push_str(\" is stronger\");\n    data.push('!');\n\n    for i in data.bytes() {\n        ///\n    }\n\n    for i in data.chars() {\n        ///\n    }\n}\n```\n\n### Vector\n- Vector is like any other struct. When Vector leaves the scope, the variable value is cleaned up, and all its elements are also cleaned up.\n```rust\nfn main() {\n    let vec: Vec<u16> = Vec::new();\n    let vec2: Vec<i32> = vec![3,4，5] // create vector by macro\n    for i in vec2 {\n        println!(\"Vector value is : {}\", i);\n    }\n}\n```\n\n### HashMap\n- HashMap is not preloaded, so it needs to be included  `use std::collections::HashMap`\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let keys = vec![\"andy\".to_string(), \"cliff\".to_string()] ;\n    let ages = vec![38, 26];\n    let map :HashMap<_,_> = keys.iter().zip(ages.iter()).collect();\n    println!(\"{:?}\", map); /// print {\"andy\": 38, \"cliff\": 26}\n}\n```\n#### HashMap ownership\n- For types that implement the Copy trait (such as i32), the value will be copied into the HashMap\n- For values with ownership, such as (String), the value will be moved and ownership will be given to HashMap\n- If a reference to a value is inserted into the HashMap, the value itself does not move\n\n#### HashMap iteration\n```rust\nuse std::collections::HashMap;\n\nfn main() { \n    let name = \"andy\".to_string();\n    let age = 36;\n    let mut map = HashMap::new();\n    map.insert(name, age);\n    map.insert(String::from(\"cliff\"), 26);\n    println!(\"{:?}\", &map);\n    for (k, v) in map {\n        println!(\"{} age {}\", k, v);\n    } /// cliff age 26\n      /// andy age 36\n}\n```\n#### update\n```rust\nuse std::collections::HashMap;\n\nfn main() { \n    let name = \"andy\".to_string();\n    let age = 36;\n    let mut map = HashMap::new();\n    map.insert(name, age);\n    map.insert(String::from(\"cliff\"), 26);\n\n    let result = map.entry(\"bob\".to_string());\n    println!(\"{:?}\", result); /// Entry(VacantEntry(\"bob\"))\n\n    let result = map.entry(\"andy\".to_string());\n    println!(\"{:?}\", result); /// Entry(OccupiedEntry { key: \"andy\", value: 36, .. })\n\n    map.entry(\"bob\".to_string()).or_insert(28);\n    map.entry(\"cliff\".to_string()).or_insert(0);\n}\n```\n\n## control flow\n- if\n```rust\nfn main() {\n    let condition = 1;\n    let x = if condition == 1 { \"A\" } else { \"B\" };\n    println!(\"Result x = {}\" , x) ;\n}\n```\n- loop\n```rust\nfn main() {\n    let mut condition = 0;\n\n    let result = 'outer: loop {  // 'outer is label\n        'inner: loop {\n            condition += 1;\n            if 3 == condition {\n                break 'outer 3 * condition; // break outer loop\n            }\n        }\n    };\n    println!(\"Loop result is : {}\", result); /// Loop result is : 9\n}\n\n```\n- rot\n```rust\nfn main() {\n    let arr = [3,2,3];\n    for num in arr.iter() {\n        println!(\"For value is {}\", num);\n    }\n}\n```\n\n## Range iterator\n- Range\n```rust\nfn main() {\n     for number in (1..=3) {\n        println!(\"Number A is {}\", number ); /// 1,2,3\n    }\n \n    for number in (1..=3).rev() { /// rev means reverse,\n        println!(\"Number B is {}\", number ); /// 3,2,1\n    }\n}\n\n```\n\n## struct\n- If struct is declared mutable then all fields in the instance are mutable\n### tuple struct\n```rust\nstruct Color(i32,i32,i32);\nlet black = Color(0,0,0);\n```\n### Unit-Like struct\n```rust\nstruct Man {};\n```\n### struct method\n```rust\n\nfn main() {\n    let rec = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    let result = rec.area(); \n    println!(\"rectangle：{:?}，area is：{}\", rec, result);\n}\n\n\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32{\n        self.width * self.height\n    }\n}\n\n```\n### associative func（similar to static method）\n- You can define a function that does not take `self` as the first parameter in the impl block. This form is called an associated function, and the calling method is similar to `String::from()`\n```rust\nimpl Rectangle {\n    fn create_square(width: u32) -> Rectangle {\n        Rectangle {\n            width,\n            height: width,\n        }\n    }\n}\n```\n  \n## enum\n```rust\nenum Ip {\n    V4,\n    V6,\n}\n\nenum IpAddr {\n    V4(String),\n    V6(String),\n}\n``` \n\n## match\n- match must exhaust all possibilities\n- If there are too many matchings, you can also use \"_\" for wildcarding, but note that \"_\" must be placed at the end\n```rust\nenum Color {\n    Red,\n    Yellow,\n    Blue,\n}\nenum ColorWithVal {\n    Red(u8,u8,u8),\n    Yellow(u8,u8,u8),\n    Blue(u8,u8,u8),\n}\nfn main(){\n    let colour = Color::Blue;\n    match colour {\n        Color::Red => {\n            println!(\"Red colour.\");\n        },\n        _ => {\n            println!(\"Other colour.\");\n        }\n    }\n\n    let colour = ColorWithVal::Red(222,111,22);\n    match colour {\n        ColorWithVal::Red(r,g,b) => {\n            println!(\"Red colour. {},{},{}\", r,g,b);\n        },\n        _ => {\n            println!(\"Other colour.\");\n        }\n    }\n}\n```\n\n## if let\n```rust\nfn main(){\n    let colour = Color::Red(Some(222),Some(222),Some(222));\n\n    if let Color::Red(r,g,b) = colour {\n        println!(\"Red colour. {:?},{:?},{:?}\", r,g,b);\n    } else {\n        println!(\"Other colour.\");\n    }\n}\n```\n\n## Result<T,E>\n- Recoverable err via Result<T,E>, non-recoverable via panic!\n- upon panic!, the program will expand an error message, unwind, clean up the call stack (Stack) and finally exit the program\n- You can set panic = 'abort' in Cargo.toml to terminate the cleaning of the call stack\n```rust\n[profile.release]\npanic='abort'\n```\n- RUST_BACKTRACE = 1 prints detailed error messages in the stack\n```rust\nuse std::fs::File;\nfn main() { \n    let fp = File::open(\"hello.txt\");\n    let file = match fp {\n        Ok(file)=> {\n            file\n        },\n        Err(error) => panic!(\"file not found {:?} \", error),\n    };\n}\n```\n\n```rust\nuse std::{fs::File, io::ErrorKind};\nfn main() { \n    let fp = File::open(\"hello.txt\");\n    let file = match fp {\n        Ok(file)=> {\n            file\n        },\n        Err(error) => {\n            match error.kind() {\n                ErrorKind::NotFound => {\n                    match File::create(\"hello.txt\") {\n                        Ok(file) => {\n                            file\n                        },\n                        Err(err) => {\n                            panic!(\"file create error:{:?}\", &err);\n                        },\n                    }\n                },\n                oe => panic!(\"other error {:?}\", oe),\n            }\n        } ,\n    };\n}\n```\n```rust\nuse std::{fs::File, io::ErrorKind};\nfn main() { \n    let file = File::open(\"hello.txt\").unwrap_or_else(|err| {\n        if err.kind() == ErrorKind::NotFound {\n            File::create(\"hello.txt\").unwrap_or_else(|err|{\n                panic!(\"error：{:?}\", err);\n            })\n        }else{\n            panic!(\"other error：{:?}\", err);\n        }\n    });\n}\n```\n### unwrap && expect\n- If do not want to deal with Err, can use unwarp() method. If result is Ok(val), return val. If Err, then call the panic! macro.\n- expect can specify what the error message is, which is easier to debug\n\n### The question mark operator, ?\nWhen writing code that calls many functions that return the Result type, the error handling can be tedious. The question mark operator, ?, hides some of the boilerplate of propagating errors up the call stack.\n```rust\nlet mut file = File::create(\"my_best_friends.txt\")?;\n```\n\n## generic\n```rust\n#[derive(Debug)]\nstruct Point<T, U>  {\n   x : T,\n   y : U,\n}\nimpl <T, U> Point<T, U> {\n    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {\n        Point{x: self.x , y: other.y, }\n    }\n}\n```\n\n## trait\n### definition\n```rust\npub trait Summary {\n    fn summarize(&self) -> String {\n         \"... more\".to_string() /// default \n    }\n}\npub struct Tweet {\n    user_name :String,\n    replay_count :u32,\n    like_count :u32,\n}\nimpl Tweet {\n    fn like(&mut self) {\n        self.like_count += 1;\n    }\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!(\"{} like count :{} , replay count :{}\", &self.user_name, &self.replay_count, &self.like_count)\n    }\n}\n```\n\n### trait as arguments\n```rust\nfn notify_msg <T:Summary> (info: T) {\n    println!(\"summary : {}\", info.summarize() );\n}\nfn notify_msg (info: impl Summary + Display) {\n    println!(\"summary : {}\", info.summarize() );\n}\nfn notify_msg <T> (info: T) \nwhere \n    T: Summary + Display,\n{\n    println!(\"summary : {}\", info.summarize() );\n    println!(\"display implement info : {}\", info);\n}\n```\n### trait as return\n- impl Trait can only return the same type, if it returns a different type, even if the Trait is implemented, an error will be reported\n\n## references\n- [the rust programming language](https://doc.rust-lang.org/book/)\n- [mooc course](https://time.geekbang.org/course/intro/100060601?tab=catalog)\n- [bilibili tutorial](https://www.bilibili.com/video/BV1hp4y1k7SV?p=50&spm_id_from=pageDriver)\n- [jianshu notes](https://www.jianshu.com/p/30d917790298)","slug":"rust-02-basics","published":1,"updated":"2023-05-01T09:07:13.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2to000h6usjhx9odovw","content":"<h2 id=\"frequently-used-cmd\"><a href=\"#frequently-used-cmd\" class=\"headerlink\" title=\"frequently used cmd\"></a>frequently used cmd</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rustc [filename].rs</span><br><span class=\"line\">cargo new [project_name]</span><br><span class=\"line\">cargo build [--release]</span><br><span class=\"line\">cargo run [--release]</span><br><span class=\"line\">cargo check # check whether compile success, no executible output</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"data-type\"><a href=\"#data-type\" class=\"headerlink\" title=\"data type\"></a>data type</h2><h3 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h3><ul>\n<li>i8,i16,i32,i64,i128,isize,u8,u16,u32,u64,u128,usize，etc</li>\n<li>isize, usize indicates that the type is determined by the architecture of the computer. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</li>\n<li>0x: hex，0o Octal，0b binary，starting with b: byte （u8 only）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Number Literals</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Decimal</td>\n<td>98_222</td>\n</tr>\n<tr>\n<td>Hex</td>\n<td>0xff</td>\n</tr>\n<tr>\n<td>Octal</td>\n<td>0o77</td>\n</tr>\n<tr>\n<td>Binary</td>\n<td>0b1111_0000</td>\n</tr>\n<tr>\n<td>Byte(u8 only)</td>\n<td>b’A’</td>\n</tr>\n</tbody></table>\n<h3 id=\"Tuple\"><a href=\"#Tuple\" class=\"headerlink\" title=\"Tuple\"></a>Tuple</h3><ul>\n<li>The length of Tuple is fixed, and the length cannot be changed once declared<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// tuple could be declared as mut</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">tuple_1</span> = (<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"number\">39</span>, <span class=\"string\">&quot;Years&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">tuple_2</span>:(<span class=\"type\">i32</span>, &amp;<span class=\"type\">str</span> ) = (<span class=\"number\">1983</span>, <span class=\"string\">&quot;since.&quot;</span>);</span><br><span class=\"line\">    tuple_1.<span class=\"number\">0</span> = <span class=\"string\">&quot;Hi&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, tuple_1.<span class=\"number\">0</span>, tuple_1.<span class=\"number\">1</span>, tuple_1.<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// destructure</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> (a,b) = tuple_2;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><ul>\n<li>arrays in Rust have a fixed length.</li>\n<li>Vector is similar to an array, it is provided by the standard library, and its length can be changed</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">arr_test</span>:[<span class=\"type\">u8</span>; <span class=\"number\">3</span>] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Number is &#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, arr_test[<span class=\"number\">0</span>],arr_test[<span class=\"number\">1</span>],arr_test[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">arr_test</span> = [<span class=\"string\">&quot;I&quot;</span>,<span class=\"string\">&quot;love&quot;</span>,<span class=\"string\">&quot;you&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;You said : &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, arr_test[<span class=\"number\">0</span>],arr_test[<span class=\"number\">1</span>],arr_test[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">arr_test</span> = [<span class=\"number\">1</span>;<span class=\"number\">3</span>]; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Call Num : &#123;&#125;&amp;&#123;&#125;&amp;&#123;&#125;&quot;</span>, arr_test[<span class=\"number\">0</span>],arr_test[<span class=\"number\">1</span>],arr_test[<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><ul>\n<li>Basic data types are stored on the stack, but the String type is stored on the heap<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>push_str(): append a str slice a string</li>\n<li>push(): appends a single character to a String<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;andy&quot;</span>);</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">push_str</span>(<span class=\"string\">&quot; is stronger&quot;</span>);</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">push</span>(<span class=\"string\">&#x27;!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>+</code> operator, chaining strings. the left side of the + operator is the ownership of the string, and the right side is the string slice</li>\n<li>String is actually a wrapper for Vec<u8>, so the length can be measured by the len() method, but note that Len() is not length of character, but byte len</li>\n<li>String iteration<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;andy&quot;</span>);</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">push_str</span>(<span class=\"string\">&quot; is stronger&quot;</span>);</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">push</span>(<span class=\"string\">&#x27;!&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> data.<span class=\"title function_ invoke__\">bytes</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">///</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> data.<span class=\"title function_ invoke__\">chars</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">///</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><ul>\n<li>Vector is like any other struct. When Vector leaves the scope, the variable value is cleaned up, and all its elements are also cleaned up.<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">vec</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">u16</span>&gt; = <span class=\"type\">Vec</span>::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">vec2</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">i32</span>&gt; = <span class=\"built_in\">vec!</span>[<span class=\"number\">3</span>,<span class=\"number\">4</span>，<span class=\"number\">5</span>] <span class=\"comment\">// create vector by macro</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> vec2 &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Vector value is : &#123;&#125;&quot;</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><ul>\n<li>HashMap is not preloaded, so it needs to be included  <code>use std::collections::HashMap</code><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">keys</span> = <span class=\"built_in\">vec!</span>[<span class=\"string\">&quot;andy&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>(), <span class=\"string\">&quot;cliff&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>()] ;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">ages</span> = <span class=\"built_in\">vec!</span>[<span class=\"number\">38</span>, <span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">map</span> :HashMap&lt;_,_&gt; = keys.<span class=\"title function_ invoke__\">iter</span>().<span class=\"title function_ invoke__\">zip</span>(ages.<span class=\"title function_ invoke__\">iter</span>()).<span class=\"title function_ invoke__\">collect</span>();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, map); <span class=\"comment\">/// print &#123;&quot;andy&quot;: 38, &quot;cliff&quot;: 26&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"HashMap-ownership\"><a href=\"#HashMap-ownership\" class=\"headerlink\" title=\"HashMap ownership\"></a>HashMap ownership</h4><ul>\n<li>For types that implement the Copy trait (such as i32), the value will be copied into the HashMap</li>\n<li>For values with ownership, such as (String), the value will be moved and ownership will be given to HashMap</li>\n<li>If a reference to a value is inserted into the HashMap, the value itself does not move</li>\n</ul>\n<h4 id=\"HashMap-iteration\"><a href=\"#HashMap-iteration\" class=\"headerlink\" title=\"HashMap iteration\"></a>HashMap iteration</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">name</span> = <span class=\"string\">&quot;andy&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">age</span> = <span class=\"number\">36</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">map</span> = HashMap::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">insert</span>(name, age);</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">insert</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;cliff&quot;</span>), <span class=\"number\">26</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, &amp;map);</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">for</span> (k, v) <span class=\"keyword\">in</span> map &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; age &#123;&#125;&quot;</span>, k, v);</span><br><span class=\"line\">    &#125; <span class=\"comment\">/// cliff age 26</span></span><br><span class=\"line\">      <span class=\"comment\">/// andy age 36</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update\"></a>update</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">name</span> = <span class=\"string\">&quot;andy&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">age</span> = <span class=\"number\">36</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">map</span> = HashMap::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">insert</span>(name, age);</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">insert</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;cliff&quot;</span>), <span class=\"number\">26</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = map.<span class=\"title function_ invoke__\">entry</span>(<span class=\"string\">&quot;bob&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>());</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, result); <span class=\"comment\">/// Entry(VacantEntry(&quot;bob&quot;))</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = map.<span class=\"title function_ invoke__\">entry</span>(<span class=\"string\">&quot;andy&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>());</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, result); <span class=\"comment\">/// Entry(OccupiedEntry &#123; key: &quot;andy&quot;, value: 36, .. &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">entry</span>(<span class=\"string\">&quot;bob&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>()).<span class=\"title function_ invoke__\">or_insert</span>(<span class=\"number\">28</span>);</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">entry</span>(<span class=\"string\">&quot;cliff&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>()).<span class=\"title function_ invoke__\">or_insert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"control-flow\"><a href=\"#control-flow\" class=\"headerlink\" title=\"control flow\"></a>control flow</h2><ul>\n<li>if<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">condition</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"keyword\">if</span> condition == <span class=\"number\">1</span> &#123; <span class=\"string\">&quot;A&quot;</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"string\">&quot;B&quot;</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Result x = &#123;&#125;&quot;</span> , x) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>loop<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">condition</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = <span class=\"symbol\">&#x27;outer</span>: <span class=\"keyword\">loop</span> &#123;  <span class=\"comment\">// &#x27;outer is label</span></span><br><span class=\"line\">        <span class=\"symbol\">&#x27;inner</span>: <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">            condition += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">3</span> == condition &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> <span class=\"symbol\">&#x27;outer</span> <span class=\"number\">3</span> * condition; <span class=\"comment\">// break outer loop</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Loop result is : &#123;&#125;&quot;</span>, result); <span class=\"comment\">/// Loop result is : 9</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>rot<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">arr</span> = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">num</span> <span class=\"keyword\">in</span> arr.<span class=\"title function_ invoke__\">iter</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;For value is &#123;&#125;&quot;</span>, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Range-iterator\"><a href=\"#Range-iterator\" class=\"headerlink\" title=\"Range iterator\"></a>Range iterator</h2><ul>\n<li>Range<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> <span class=\"variable\">number</span> <span class=\"keyword\">in</span> (<span class=\"number\">1</span>..=<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Number A is &#123;&#125;&quot;</span>, number ); <span class=\"comment\">/// 1,2,3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">number</span> <span class=\"keyword\">in</span> (<span class=\"number\">1</span>..=<span class=\"number\">3</span>).<span class=\"title function_ invoke__\">rev</span>() &#123; <span class=\"comment\">/// rev means reverse,</span></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Number B is &#123;&#125;&quot;</span>, number ); <span class=\"comment\">/// 3,2,1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a>struct</h2><ul>\n<li>If struct is declared mutable then all fields in the instance are mutable</li>\n</ul>\n<h3 id=\"tuple-struct\"><a href=\"#tuple-struct\" class=\"headerlink\" title=\"tuple struct\"></a>tuple struct</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Color</span>(<span class=\"type\">i32</span>,<span class=\"type\">i32</span>,<span class=\"type\">i32</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">black</span> = <span class=\"title function_ invoke__\">Color</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Unit-Like-struct\"><a href=\"#Unit-Like-struct\" class=\"headerlink\" title=\"Unit-Like struct\"></a>Unit-Like struct</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Man</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"struct-method\"><a href=\"#struct-method\" class=\"headerlink\" title=\"struct method\"></a>struct method</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">rec</span> = Rectangle &#123;</span><br><span class=\"line\">        width: <span class=\"number\">30</span>,</span><br><span class=\"line\">        height: <span class=\"number\">50</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = rec.<span class=\"title function_ invoke__\">area</span>(); </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;rectangle：&#123;:?&#125;，area is：&#123;&#125;&quot;</span>, rec, result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    width: <span class=\"type\">u32</span>,</span><br><span class=\"line\">    height: <span class=\"type\">u32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">area</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">u32</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.width * <span class=\"keyword\">self</span>.height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"associative-func（similar-to-static-method）\"><a href=\"#associative-func（similar-to-static-method）\" class=\"headerlink\" title=\"associative func（similar to static method）\"></a>associative func（similar to static method）</h3><ul>\n<li>You can define a function that does not take <code>self</code> as the first parameter in the impl block. This form is called an associated function, and the calling method is similar to <code>String::from()</code><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">create_square</span>(width: <span class=\"type\">u32</span>) <span class=\"punctuation\">-&gt;</span> Rectangle &#123;</span><br><span class=\"line\">        Rectangle &#123;</span><br><span class=\"line\">            width,</span><br><span class=\"line\">            height: width,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"enum\"><a href=\"#enum\" class=\"headerlink\" title=\"enum\"></a>enum</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Ip</span> &#123;</span><br><span class=\"line\">    V4,</span><br><span class=\"line\">    V6,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">IpAddr</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">V4</span>(<span class=\"type\">String</span>),</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">V6</span>(<span class=\"type\">String</span>),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h2><ul>\n<li>match must exhaust all possibilities</li>\n<li>If there are too many matchings, you can also use “<em>“ for wildcarding, but note that “</em>“ must be placed at the end<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">    Red,</span><br><span class=\"line\">    Yellow,</span><br><span class=\"line\">    Blue,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">ColorWithVal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Red</span>(<span class=\"type\">u8</span>,<span class=\"type\">u8</span>,<span class=\"type\">u8</span>),</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Yellow</span>(<span class=\"type\">u8</span>,<span class=\"type\">u8</span>,<span class=\"type\">u8</span>),</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Blue</span>(<span class=\"type\">u8</span>,<span class=\"type\">u8</span>,<span class=\"type\">u8</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">colour</span> = Color::Blue;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> colour &#123;</span><br><span class=\"line\">        Color::Red =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Red colour.&quot;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        _ =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Other colour.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">colour</span> = ColorWithVal::<span class=\"title function_ invoke__\">Red</span>(<span class=\"number\">222</span>,<span class=\"number\">111</span>,<span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"keyword\">match</span> colour &#123;</span><br><span class=\"line\">        ColorWithVal::<span class=\"title function_ invoke__\">Red</span>(r,g,b) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Red colour. &#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, r,g,b);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        _ =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Other colour.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"if-let\"><a href=\"#if-let\" class=\"headerlink\" title=\"if let\"></a>if let</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">colour</span> = Color::<span class=\"title function_ invoke__\">Red</span>(<span class=\"title function_ invoke__\">Some</span>(<span class=\"number\">222</span>),<span class=\"title function_ invoke__\">Some</span>(<span class=\"number\">222</span>),<span class=\"title function_ invoke__\">Some</span>(<span class=\"number\">222</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"variable\">Color</span>::<span class=\"title function_ invoke__\">Red</span>(r,g,b) = colour &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Red colour. &#123;:?&#125;,&#123;:?&#125;,&#123;:?&#125;&quot;</span>, r,g,b);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Other colour.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Result-lt-T-E-gt\"><a href=\"#Result-lt-T-E-gt\" class=\"headerlink\" title=\"Result&lt;T,E&gt;\"></a>Result&lt;T,E&gt;</h2><ul>\n<li>Recoverable err via Result&lt;T,E&gt;, non-recoverable via panic!</li>\n<li>upon panic!, the program will expand an error message, unwind, clean up the call stack (Stack) and finally exit the program</li>\n<li>You can set panic &#x3D; ‘abort’ in Cargo.toml to terminate the cleaning of the call stack<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[profile.release]</span><br><span class=\"line\">panic=<span class=\"symbol\">&#x27;abort</span>&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>RUST_BACKTRACE &#x3D; 1 prints detailed error messages in the stack<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::fs::File;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">fp</span> = File::<span class=\"title function_ invoke__\">open</span>(<span class=\"string\">&quot;hello.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">file</span> = <span class=\"keyword\">match</span> fp &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Ok</span>(file)=&gt; &#123;</span><br><span class=\"line\">            file</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Err</span>(error) =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;file not found &#123;:?&#125; &quot;</span>, error),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;fs::File, io::ErrorKind&#125;;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">fp</span> = File::<span class=\"title function_ invoke__\">open</span>(<span class=\"string\">&quot;hello.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">file</span> = <span class=\"keyword\">match</span> fp &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Ok</span>(file)=&gt; &#123;</span><br><span class=\"line\">            file</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Err</span>(error) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">match</span> error.<span class=\"title function_ invoke__\">kind</span>() &#123;</span><br><span class=\"line\">                ErrorKind::NotFound =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">match</span> File::<span class=\"title function_ invoke__\">create</span>(<span class=\"string\">&quot;hello.txt&quot;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"title function_ invoke__\">Ok</span>(file) =&gt; &#123;</span><br><span class=\"line\">                            file</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        <span class=\"title function_ invoke__\">Err</span>(err) =&gt; &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;file create error:&#123;:?&#125;&quot;</span>, &amp;err);</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                oe =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;other error &#123;:?&#125;&quot;</span>, oe),</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; ,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;fs::File, io::ErrorKind&#125;;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">file</span> = File::<span class=\"title function_ invoke__\">open</span>(<span class=\"string\">&quot;hello.txt&quot;</span>).<span class=\"title function_ invoke__\">unwrap_or_else</span>(|err| &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err.<span class=\"title function_ invoke__\">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class=\"line\">            File::<span class=\"title function_ invoke__\">create</span>(<span class=\"string\">&quot;hello.txt&quot;</span>).<span class=\"title function_ invoke__\">unwrap_or_else</span>(|err|&#123;</span><br><span class=\"line\">                <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;error：&#123;:?&#125;&quot;</span>, err);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;other error：&#123;:?&#125;&quot;</span>, err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"unwrap-amp-amp-expect\"><a href=\"#unwrap-amp-amp-expect\" class=\"headerlink\" title=\"unwrap &amp;&amp; expect\"></a>unwrap &amp;&amp; expect</h3><ul>\n<li>If do not want to deal with Err, can use unwarp() method. If result is Ok(val), return val. If Err, then call the panic! macro.</li>\n<li>expect can specify what the error message is, which is easier to debug</li>\n</ul>\n<h3 id=\"The-question-mark-operator\"><a href=\"#The-question-mark-operator\" class=\"headerlink\" title=\"The question mark operator, ?\"></a>The question mark operator, ?</h3><p>When writing code that calls many functions that return the Result type, the error handling can be tedious. The question mark operator, ?, hides some of the boilerplate of propagating errors up the call stack.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">file</span> = File::<span class=\"title function_ invoke__\">create</span>(<span class=\"string\">&quot;my_best_friends.txt&quot;</span>)?;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"generic\"><a href=\"#generic\" class=\"headerlink\" title=\"generic\"></a>generic</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span>&lt;T, U&gt;  &#123;</span><br><span class=\"line\">   x : T,</span><br><span class=\"line\">   y : U,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> &lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">mixup</span>&lt;V, W&gt;(<span class=\"keyword\">self</span>, other: Point&lt;V, W&gt;) <span class=\"punctuation\">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class=\"line\">        Point&#123;x: <span class=\"keyword\">self</span>.x , y: other.y, &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"trait\"><a href=\"#trait\" class=\"headerlink\" title=\"trait\"></a>trait</h2><h3 id=\"definition\"><a href=\"#definition\" class=\"headerlink\" title=\"definition\"></a>definition</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">Summary</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">summarize</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">         <span class=\"string\">&quot;... more&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>() <span class=\"comment\">/// default </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Tweet</span> &#123;</span><br><span class=\"line\">    user_name :<span class=\"type\">String</span>,</span><br><span class=\"line\">    replay_count :<span class=\"type\">u32</span>,</span><br><span class=\"line\">    like_count :<span class=\"type\">u32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Tweet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">like</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.like_count += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Summary</span> <span class=\"keyword\">for</span> <span class=\"title class_\">Tweet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">summarize</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">format!</span>(<span class=\"string\">&quot;&#123;&#125; like count :&#123;&#125; , replay count :&#123;&#125;&quot;</span>, &amp;<span class=\"keyword\">self</span>.user_name, &amp;<span class=\"keyword\">self</span>.replay_count, &amp;<span class=\"keyword\">self</span>.like_count)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"trait-as-arguments\"><a href=\"#trait-as-arguments\" class=\"headerlink\" title=\"trait as arguments\"></a>trait as arguments</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">notify_msg</span> &lt;T:Summary&gt; (info: T) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;summary : &#123;&#125;&quot;</span>, info.<span class=\"title function_ invoke__\">summarize</span>() );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">notify_msg</span> (info: <span class=\"keyword\">impl</span> <span class=\"title class_\">Summary</span> + Display) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;summary : &#123;&#125;&quot;</span>, info.<span class=\"title function_ invoke__\">summarize</span>() );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">notify_msg</span> &lt;T&gt; (info: T) </span><br><span class=\"line\"><span class=\"keyword\">where</span> </span><br><span class=\"line\">    T: Summary + Display,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;summary : &#123;&#125;&quot;</span>, info.<span class=\"title function_ invoke__\">summarize</span>() );</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;display implement info : &#123;&#125;&quot;</span>, info);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"trait-as-return\"><a href=\"#trait-as-return\" class=\"headerlink\" title=\"trait as return\"></a>trait as return</h3><ul>\n<li>impl Trait can only return the same type, if it returns a different type, even if the Trait is implemented, an error will be reported</li>\n</ul>\n<h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ul>\n<li><a href=\"https://doc.rust-lang.org/book/\">the rust programming language</a></li>\n<li><a href=\"https://time.geekbang.org/course/intro/100060601?tab=catalog\">mooc course</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1hp4y1k7SV?p=50&spm_id_from=pageDriver\">bilibili tutorial</a></li>\n<li><a href=\"https://www.jianshu.com/p/30d917790298\">jianshu notes</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"frequently-used-cmd\"><a href=\"#frequently-used-cmd\" class=\"headerlink\" title=\"frequently used cmd\"></a>frequently used cmd</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rustc [filename].rs</span><br><span class=\"line\">cargo new [project_name]</span><br><span class=\"line\">cargo build [--release]</span><br><span class=\"line\">cargo run [--release]</span><br><span class=\"line\">cargo check # check whether compile success, no executible output</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"data-type\"><a href=\"#data-type\" class=\"headerlink\" title=\"data type\"></a>data type</h2><h3 id=\"integer\"><a href=\"#integer\" class=\"headerlink\" title=\"integer\"></a>integer</h3><ul>\n<li>i8,i16,i32,i64,i128,isize,u8,u16,u32,u64,u128,usize，etc</li>\n<li>isize, usize indicates that the type is determined by the architecture of the computer. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</li>\n<li>0x: hex，0o Octal，0b binary，starting with b: byte （u8 only）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Number Literals</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Decimal</td>\n<td>98_222</td>\n</tr>\n<tr>\n<td>Hex</td>\n<td>0xff</td>\n</tr>\n<tr>\n<td>Octal</td>\n<td>0o77</td>\n</tr>\n<tr>\n<td>Binary</td>\n<td>0b1111_0000</td>\n</tr>\n<tr>\n<td>Byte(u8 only)</td>\n<td>b’A’</td>\n</tr>\n</tbody></table>\n<h3 id=\"Tuple\"><a href=\"#Tuple\" class=\"headerlink\" title=\"Tuple\"></a>Tuple</h3><ul>\n<li>The length of Tuple is fixed, and the length cannot be changed once declared<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// tuple could be declared as mut</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">tuple_1</span> = (<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"number\">39</span>, <span class=\"string\">&quot;Years&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">tuple_2</span>:(<span class=\"type\">i32</span>, &amp;<span class=\"type\">str</span> ) = (<span class=\"number\">1983</span>, <span class=\"string\">&quot;since.&quot;</span>);</span><br><span class=\"line\">    tuple_1.<span class=\"number\">0</span> = <span class=\"string\">&quot;Hi&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, tuple_1.<span class=\"number\">0</span>, tuple_1.<span class=\"number\">1</span>, tuple_1.<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// destructure</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> (a,b) = tuple_2;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h3><ul>\n<li>arrays in Rust have a fixed length.</li>\n<li>Vector is similar to an array, it is provided by the standard library, and its length can be changed</li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">arr_test</span>:[<span class=\"type\">u8</span>; <span class=\"number\">3</span>] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Number is &#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, arr_test[<span class=\"number\">0</span>],arr_test[<span class=\"number\">1</span>],arr_test[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">arr_test</span> = [<span class=\"string\">&quot;I&quot;</span>,<span class=\"string\">&quot;love&quot;</span>,<span class=\"string\">&quot;you&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;You said : &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>, arr_test[<span class=\"number\">0</span>],arr_test[<span class=\"number\">1</span>],arr_test[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">arr_test</span> = [<span class=\"number\">1</span>;<span class=\"number\">3</span>]; </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Call Num : &#123;&#125;&amp;&#123;&#125;&amp;&#123;&#125;&quot;</span>, arr_test[<span class=\"number\">0</span>],arr_test[<span class=\"number\">1</span>],arr_test[<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><ul>\n<li>Basic data types are stored on the stack, but the String type is stored on the heap<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>push_str(): append a str slice a string</li>\n<li>push(): appends a single character to a String<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;andy&quot;</span>);</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">push_str</span>(<span class=\"string\">&quot; is stronger&quot;</span>);</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">push</span>(<span class=\"string\">&#x27;!&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><code>+</code> operator, chaining strings. the left side of the + operator is the ownership of the string, and the right side is the string slice</li>\n<li>String is actually a wrapper for Vec<u8>, so the length can be measured by the len() method, but note that Len() is not length of character, but byte len</li>\n<li>String iteration<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">data</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;andy&quot;</span>);</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">push_str</span>(<span class=\"string\">&quot; is stronger&quot;</span>);</span><br><span class=\"line\">    data.<span class=\"title function_ invoke__\">push</span>(<span class=\"string\">&#x27;!&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> data.<span class=\"title function_ invoke__\">bytes</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">///</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> data.<span class=\"title function_ invoke__\">chars</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">///</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><ul>\n<li>Vector is like any other struct. When Vector leaves the scope, the variable value is cleaned up, and all its elements are also cleaned up.<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">vec</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">u16</span>&gt; = <span class=\"type\">Vec</span>::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">vec2</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">i32</span>&gt; = <span class=\"built_in\">vec!</span>[<span class=\"number\">3</span>,<span class=\"number\">4</span>，<span class=\"number\">5</span>] <span class=\"comment\">// create vector by macro</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">i</span> <span class=\"keyword\">in</span> vec2 &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Vector value is : &#123;&#125;&quot;</span>, i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><ul>\n<li>HashMap is not preloaded, so it needs to be included  <code>use std::collections::HashMap</code><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">keys</span> = <span class=\"built_in\">vec!</span>[<span class=\"string\">&quot;andy&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>(), <span class=\"string\">&quot;cliff&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>()] ;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">ages</span> = <span class=\"built_in\">vec!</span>[<span class=\"number\">38</span>, <span class=\"number\">26</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">map</span> :HashMap&lt;_,_&gt; = keys.<span class=\"title function_ invoke__\">iter</span>().<span class=\"title function_ invoke__\">zip</span>(ages.<span class=\"title function_ invoke__\">iter</span>()).<span class=\"title function_ invoke__\">collect</span>();</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, map); <span class=\"comment\">/// print &#123;&quot;andy&quot;: 38, &quot;cliff&quot;: 26&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"HashMap-ownership\"><a href=\"#HashMap-ownership\" class=\"headerlink\" title=\"HashMap ownership\"></a>HashMap ownership</h4><ul>\n<li>For types that implement the Copy trait (such as i32), the value will be copied into the HashMap</li>\n<li>For values with ownership, such as (String), the value will be moved and ownership will be given to HashMap</li>\n<li>If a reference to a value is inserted into the HashMap, the value itself does not move</li>\n</ul>\n<h4 id=\"HashMap-iteration\"><a href=\"#HashMap-iteration\" class=\"headerlink\" title=\"HashMap iteration\"></a>HashMap iteration</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">name</span> = <span class=\"string\">&quot;andy&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">age</span> = <span class=\"number\">36</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">map</span> = HashMap::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">insert</span>(name, age);</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">insert</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;cliff&quot;</span>), <span class=\"number\">26</span>);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, &amp;map);</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">for</span> (k, v) <span class=\"keyword\">in</span> map &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; age &#123;&#125;&quot;</span>, k, v);</span><br><span class=\"line\">    &#125; <span class=\"comment\">/// cliff age 26</span></span><br><span class=\"line\">      <span class=\"comment\">/// andy age 36</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update\"></a>update</h4><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::collections::HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">name</span> = <span class=\"string\">&quot;andy&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">age</span> = <span class=\"number\">36</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">map</span> = HashMap::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">insert</span>(name, age);</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">insert</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;cliff&quot;</span>), <span class=\"number\">26</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = map.<span class=\"title function_ invoke__\">entry</span>(<span class=\"string\">&quot;bob&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>());</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, result); <span class=\"comment\">/// Entry(VacantEntry(&quot;bob&quot;))</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = map.<span class=\"title function_ invoke__\">entry</span>(<span class=\"string\">&quot;andy&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>());</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, result); <span class=\"comment\">/// Entry(OccupiedEntry &#123; key: &quot;andy&quot;, value: 36, .. &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">entry</span>(<span class=\"string\">&quot;bob&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>()).<span class=\"title function_ invoke__\">or_insert</span>(<span class=\"number\">28</span>);</span><br><span class=\"line\">    map.<span class=\"title function_ invoke__\">entry</span>(<span class=\"string\">&quot;cliff&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>()).<span class=\"title function_ invoke__\">or_insert</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"control-flow\"><a href=\"#control-flow\" class=\"headerlink\" title=\"control flow\"></a>control flow</h2><ul>\n<li>if<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">condition</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"keyword\">if</span> condition == <span class=\"number\">1</span> &#123; <span class=\"string\">&quot;A&quot;</span> &#125; <span class=\"keyword\">else</span> &#123; <span class=\"string\">&quot;B&quot;</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Result x = &#123;&#125;&quot;</span> , x) ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>loop<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">condition</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = <span class=\"symbol\">&#x27;outer</span>: <span class=\"keyword\">loop</span> &#123;  <span class=\"comment\">// &#x27;outer is label</span></span><br><span class=\"line\">        <span class=\"symbol\">&#x27;inner</span>: <span class=\"keyword\">loop</span> &#123;</span><br><span class=\"line\">            condition += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"number\">3</span> == condition &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span> <span class=\"symbol\">&#x27;outer</span> <span class=\"number\">3</span> * condition; <span class=\"comment\">// break outer loop</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Loop result is : &#123;&#125;&quot;</span>, result); <span class=\"comment\">/// Loop result is : 9</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li>rot<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">arr</span> = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">num</span> <span class=\"keyword\">in</span> arr.<span class=\"title function_ invoke__\">iter</span>() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;For value is &#123;&#125;&quot;</span>, num);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Range-iterator\"><a href=\"#Range-iterator\" class=\"headerlink\" title=\"Range iterator\"></a>Range iterator</h2><ul>\n<li>Range<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> <span class=\"variable\">number</span> <span class=\"keyword\">in</span> (<span class=\"number\">1</span>..=<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Number A is &#123;&#125;&quot;</span>, number ); <span class=\"comment\">/// 1,2,3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"variable\">number</span> <span class=\"keyword\">in</span> (<span class=\"number\">1</span>..=<span class=\"number\">3</span>).<span class=\"title function_ invoke__\">rev</span>() &#123; <span class=\"comment\">/// rev means reverse,</span></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Number B is &#123;&#125;&quot;</span>, number ); <span class=\"comment\">/// 3,2,1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a>struct</h2><ul>\n<li>If struct is declared mutable then all fields in the instance are mutable</li>\n</ul>\n<h3 id=\"tuple-struct\"><a href=\"#tuple-struct\" class=\"headerlink\" title=\"tuple struct\"></a>tuple struct</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Color</span>(<span class=\"type\">i32</span>,<span class=\"type\">i32</span>,<span class=\"type\">i32</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">black</span> = <span class=\"title function_ invoke__\">Color</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Unit-Like-struct\"><a href=\"#Unit-Like-struct\" class=\"headerlink\" title=\"Unit-Like struct\"></a>Unit-Like struct</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Man</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"struct-method\"><a href=\"#struct-method\" class=\"headerlink\" title=\"struct method\"></a>struct method</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">rec</span> = Rectangle &#123;</span><br><span class=\"line\">        width: <span class=\"number\">30</span>,</span><br><span class=\"line\">        height: <span class=\"number\">50</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">result</span> = rec.<span class=\"title function_ invoke__\">area</span>(); </span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;rectangle：&#123;:?&#125;，area is：&#123;&#125;&quot;</span>, rec, result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    width: <span class=\"type\">u32</span>,</span><br><span class=\"line\">    height: <span class=\"type\">u32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">area</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">u32</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.width * <span class=\"keyword\">self</span>.height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"associative-func（similar-to-static-method）\"><a href=\"#associative-func（similar-to-static-method）\" class=\"headerlink\" title=\"associative func（similar to static method）\"></a>associative func（similar to static method）</h3><ul>\n<li>You can define a function that does not take <code>self</code> as the first parameter in the impl block. This form is called an associated function, and the calling method is similar to <code>String::from()</code><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">create_square</span>(width: <span class=\"type\">u32</span>) <span class=\"punctuation\">-&gt;</span> Rectangle &#123;</span><br><span class=\"line\">        Rectangle &#123;</span><br><span class=\"line\">            width,</span><br><span class=\"line\">            height: width,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"enum\"><a href=\"#enum\" class=\"headerlink\" title=\"enum\"></a>enum</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Ip</span> &#123;</span><br><span class=\"line\">    V4,</span><br><span class=\"line\">    V6,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">IpAddr</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">V4</span>(<span class=\"type\">String</span>),</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">V6</span>(<span class=\"type\">String</span>),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h2><ul>\n<li>match must exhaust all possibilities</li>\n<li>If there are too many matchings, you can also use “<em>“ for wildcarding, but note that “</em>“ must be placed at the end<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Color</span> &#123;</span><br><span class=\"line\">    Red,</span><br><span class=\"line\">    Yellow,</span><br><span class=\"line\">    Blue,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">ColorWithVal</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Red</span>(<span class=\"type\">u8</span>,<span class=\"type\">u8</span>,<span class=\"type\">u8</span>),</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Yellow</span>(<span class=\"type\">u8</span>,<span class=\"type\">u8</span>,<span class=\"type\">u8</span>),</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Blue</span>(<span class=\"type\">u8</span>,<span class=\"type\">u8</span>,<span class=\"type\">u8</span>),</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">colour</span> = Color::Blue;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> colour &#123;</span><br><span class=\"line\">        Color::Red =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Red colour.&quot;</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        _ =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Other colour.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">colour</span> = ColorWithVal::<span class=\"title function_ invoke__\">Red</span>(<span class=\"number\">222</span>,<span class=\"number\">111</span>,<span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"keyword\">match</span> colour &#123;</span><br><span class=\"line\">        ColorWithVal::<span class=\"title function_ invoke__\">Red</span>(r,g,b) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Red colour. &#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, r,g,b);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        _ =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Other colour.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"if-let\"><a href=\"#if-let\" class=\"headerlink\" title=\"if let\"></a>if let</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">colour</span> = Color::<span class=\"title function_ invoke__\">Red</span>(<span class=\"title function_ invoke__\">Some</span>(<span class=\"number\">222</span>),<span class=\"title function_ invoke__\">Some</span>(<span class=\"number\">222</span>),<span class=\"title function_ invoke__\">Some</span>(<span class=\"number\">222</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"variable\">Color</span>::<span class=\"title function_ invoke__\">Red</span>(r,g,b) = colour &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Red colour. &#123;:?&#125;,&#123;:?&#125;,&#123;:?&#125;&quot;</span>, r,g,b);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Other colour.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Result-lt-T-E-gt\"><a href=\"#Result-lt-T-E-gt\" class=\"headerlink\" title=\"Result&lt;T,E&gt;\"></a>Result&lt;T,E&gt;</h2><ul>\n<li>Recoverable err via Result&lt;T,E&gt;, non-recoverable via panic!</li>\n<li>upon panic!, the program will expand an error message, unwind, clean up the call stack (Stack) and finally exit the program</li>\n<li>You can set panic &#x3D; ‘abort’ in Cargo.toml to terminate the cleaning of the call stack<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[profile.release]</span><br><span class=\"line\">panic=<span class=\"symbol\">&#x27;abort</span>&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>RUST_BACKTRACE &#x3D; 1 prints detailed error messages in the stack<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::fs::File;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">fp</span> = File::<span class=\"title function_ invoke__\">open</span>(<span class=\"string\">&quot;hello.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">file</span> = <span class=\"keyword\">match</span> fp &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Ok</span>(file)=&gt; &#123;</span><br><span class=\"line\">            file</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Err</span>(error) =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;file not found &#123;:?&#125; &quot;</span>, error),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;fs::File, io::ErrorKind&#125;;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">fp</span> = File::<span class=\"title function_ invoke__\">open</span>(<span class=\"string\">&quot;hello.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">file</span> = <span class=\"keyword\">match</span> fp &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Ok</span>(file)=&gt; &#123;</span><br><span class=\"line\">            file</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Err</span>(error) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">match</span> error.<span class=\"title function_ invoke__\">kind</span>() &#123;</span><br><span class=\"line\">                ErrorKind::NotFound =&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">match</span> File::<span class=\"title function_ invoke__\">create</span>(<span class=\"string\">&quot;hello.txt&quot;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"title function_ invoke__\">Ok</span>(file) =&gt; &#123;</span><br><span class=\"line\">                            file</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        <span class=\"title function_ invoke__\">Err</span>(err) =&gt; &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;file create error:&#123;:?&#125;&quot;</span>, &amp;err);</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                oe =&gt; <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;other error &#123;:?&#125;&quot;</span>, oe),</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; ,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;fs::File, io::ErrorKind&#125;;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">file</span> = File::<span class=\"title function_ invoke__\">open</span>(<span class=\"string\">&quot;hello.txt&quot;</span>).<span class=\"title function_ invoke__\">unwrap_or_else</span>(|err| &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err.<span class=\"title function_ invoke__\">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class=\"line\">            File::<span class=\"title function_ invoke__\">create</span>(<span class=\"string\">&quot;hello.txt&quot;</span>).<span class=\"title function_ invoke__\">unwrap_or_else</span>(|err|&#123;</span><br><span class=\"line\">                <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;error：&#123;:?&#125;&quot;</span>, err);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">panic!</span>(<span class=\"string\">&quot;other error：&#123;:?&#125;&quot;</span>, err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"unwrap-amp-amp-expect\"><a href=\"#unwrap-amp-amp-expect\" class=\"headerlink\" title=\"unwrap &amp;&amp; expect\"></a>unwrap &amp;&amp; expect</h3><ul>\n<li>If do not want to deal with Err, can use unwarp() method. If result is Ok(val), return val. If Err, then call the panic! macro.</li>\n<li>expect can specify what the error message is, which is easier to debug</li>\n</ul>\n<h3 id=\"The-question-mark-operator\"><a href=\"#The-question-mark-operator\" class=\"headerlink\" title=\"The question mark operator, ?\"></a>The question mark operator, ?</h3><p>When writing code that calls many functions that return the Result type, the error handling can be tedious. The question mark operator, ?, hides some of the boilerplate of propagating errors up the call stack.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">file</span> = File::<span class=\"title function_ invoke__\">create</span>(<span class=\"string\">&quot;my_best_friends.txt&quot;</span>)?;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"generic\"><a href=\"#generic\" class=\"headerlink\" title=\"generic\"></a>generic</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span>&lt;T, U&gt;  &#123;</span><br><span class=\"line\">   x : T,</span><br><span class=\"line\">   y : U,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> &lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">mixup</span>&lt;V, W&gt;(<span class=\"keyword\">self</span>, other: Point&lt;V, W&gt;) <span class=\"punctuation\">-&gt;</span> Point&lt;T, W&gt; &#123;</span><br><span class=\"line\">        Point&#123;x: <span class=\"keyword\">self</span>.x , y: other.y, &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"trait\"><a href=\"#trait\" class=\"headerlink\" title=\"trait\"></a>trait</h2><h3 id=\"definition\"><a href=\"#definition\" class=\"headerlink\" title=\"definition\"></a>definition</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">Summary</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">summarize</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">         <span class=\"string\">&quot;... more&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>() <span class=\"comment\">/// default </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Tweet</span> &#123;</span><br><span class=\"line\">    user_name :<span class=\"type\">String</span>,</span><br><span class=\"line\">    replay_count :<span class=\"type\">u32</span>,</span><br><span class=\"line\">    like_count :<span class=\"type\">u32</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Tweet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">like</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.like_count += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Summary</span> <span class=\"keyword\">for</span> <span class=\"title class_\">Tweet</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">summarize</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">format!</span>(<span class=\"string\">&quot;&#123;&#125; like count :&#123;&#125; , replay count :&#123;&#125;&quot;</span>, &amp;<span class=\"keyword\">self</span>.user_name, &amp;<span class=\"keyword\">self</span>.replay_count, &amp;<span class=\"keyword\">self</span>.like_count)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"trait-as-arguments\"><a href=\"#trait-as-arguments\" class=\"headerlink\" title=\"trait as arguments\"></a>trait as arguments</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">notify_msg</span> &lt;T:Summary&gt; (info: T) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;summary : &#123;&#125;&quot;</span>, info.<span class=\"title function_ invoke__\">summarize</span>() );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">notify_msg</span> (info: <span class=\"keyword\">impl</span> <span class=\"title class_\">Summary</span> + Display) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;summary : &#123;&#125;&quot;</span>, info.<span class=\"title function_ invoke__\">summarize</span>() );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">notify_msg</span> &lt;T&gt; (info: T) </span><br><span class=\"line\"><span class=\"keyword\">where</span> </span><br><span class=\"line\">    T: Summary + Display,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;summary : &#123;&#125;&quot;</span>, info.<span class=\"title function_ invoke__\">summarize</span>() );</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;display implement info : &#123;&#125;&quot;</span>, info);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"trait-as-return\"><a href=\"#trait-as-return\" class=\"headerlink\" title=\"trait as return\"></a>trait as return</h3><ul>\n<li>impl Trait can only return the same type, if it returns a different type, even if the Trait is implemented, an error will be reported</li>\n</ul>\n<h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ul>\n<li><a href=\"https://doc.rust-lang.org/book/\">the rust programming language</a></li>\n<li><a href=\"https://time.geekbang.org/course/intro/100060601?tab=catalog\">mooc course</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1hp4y1k7SV?p=50&spm_id_from=pageDriver\">bilibili tutorial</a></li>\n<li><a href=\"https://www.jianshu.com/p/30d917790298\">jianshu notes</a></li>\n</ul>\n"},{"title":"rust ownership","date":"2022-10-11T09:09:28.000Z","_content":"\n## ownership rule\n- Each value in Rust has an owner.\n- There can only be one owner at a time.\n- When the owner goes out of scope, the value will be dropped.\n\n## variable scope\n```rust\nfn main() {\n    {                      // s is not valid here, it’s not yet declared\n        let s = \"hello\";   // s is valid from this point forward\n        // do stuff with s\n    }                      // this scope is now over, and s is no longer valid\n}\n```\n\n## Move\n### stack-only data: Copy trait\nsuch as primitive type\n```rust\nfn main() {\n    let x = 5;\n    let y = x;\n}\n```\nbind the value 5 to x; then make a copy of the value in x and bind it to y.\n\n### for heap variable\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n}\n```\n![move-string](/images/rust/ownership/move-string.png)\nptr, len, capacity is stored in stack, while string value is stored in heap \\\nWhen we assign s1 to s2, the String data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap\n![move-string-2](/images/rust/ownership/move-string-2.png)\nsimilar to shallow copy\n\n## Clone\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}\n```\nIf we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.\n\n### ownership and function\n- Passing a value to a function will result in a move or copy of ownership\n- difference between \"stack\" and \"heap\" variables: stack variables will be copied, and heap variables will be moved. When a variable containing heap data leaves the scope, its value will be cleared by the drop function, unless the ownership of the data is moved to another variable\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // s comes into scope\n    takes_ownership(s);             // s's value moves into the function...\n                                    // ... and so is no longer valid here\n\n    let x = 5;                      // x comes into scope\n\n    makes_copy(x);                  // x would move into the function,\n                                    // but i32 is Copy, so it's okay to still\n                                    // use x afterward\n\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(\"{}\", some_string);\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n\n```\n\n### return values and scope\n```rust\nfn main() {\n    let s1 = gives_ownership();         // gives_ownership moves its return\n                                        // value into s1\n\n    let s2 = String::from(\"hello\");     // s2 comes into scope\n\n    let s3 = takes_and_gives_back(s2);  // s2 is moved into\n                                        // takes_and_gives_back, which also\n                                        // moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\nfn gives_ownership() -> String {             // gives_ownership will move its\n                                             // return value into the function\n                                             // that calls it\n\n    let some_string = String::from(\"yours\"); // some_string comes into scope\n\n    some_string                              // some_string is returned and\n                                             // moves out to the calling\n                                             // function\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -> String { // a_string comes into\n                                                      // scope\n\n    a_string  // a_string is returned and moves out to the calling function\n}\n```\n> What if we want to let a function use a value but not take ownership?  \n> that's reference\n \n\n## reference & borrow\n- & means reference (borrow but not own)， default immutable\n- &mut a mutable reference， only one mutable reference allowed in same scope (avoid data racing)\n- Multiple mutable references can be created non-simultaneously by creating a new scope\n- **Cannot have mutable and immutable references at the same time**\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n    {\n        let s1 = &mut s;\n    } // r1 goes out of scope here, so we can make a new reference with no problems.\n    let s2 = &mut s;\n}\n\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // no problem\n    let r2 = &s; // no problem\n    println!(\"{} and {}\", r1, r2);\n    // variables r1 and r2 will not be used after this point\n\n    let r3 = &mut s; // no problem\n    println!(\"{}\", r3);\n\n    println!{\"{}\",r1} // got problem with above mutable borrow\n}\n```\n\n### reference as function arguments\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize { // s is a reference to a String\n    s.len() \n}  // Here, s goes out of scope. But because it does not have ownership of what\n   // it refers to, nothing happens.\n```\nwe pass &s1 into calculate_length and, in its definition, we take &String rather than String. These ampersands represent references, and they allow you to refer to some value without taking ownership of it. Because it does not own it, the value it points to will not be dropped when the reference stops being used. \\\n When functions have references as parameters instead of the actual values, we won't need to return the values in order to give back ownership, because we never had ownership. \\\n We call the action of creating a reference borrowing. \n\n### mutable references\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n### dangling references\n- A pointer refers to an address in memory, but the memory may have been freed and allocated for use by someone else\n- rust，The compiler can guarantee that there will never be dangling references\n```rust\nfn main() {\n    let r = dangle();\n}\nfn dangle() -> &string {  // dangle returns a reference to a String\n    let s = String::from(\"hello\");  // s is a new String\n    &s // we return a reference to the String, s\n} // Here, s goes out of scope, and is dropped. Its memory goes away.\n// Danger\n```\nThe solution here is to return the String directly:\n```rust\nfn main() {\n    let string = no_dangle();\n}\n\nfn no_dangle() -> String {\n    let s = String::from(\"hello\");\n    s\n}\n```\nThis works without any problems. Ownership is moved out, and nothing is deallocated.\n\n\n## slice\n- Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership.\n\n### string slice\n```rust\nfn main() {\n    let mut s = String::from(\"Hello world\");\n\n    let hello = &s[0..5]; \n    let world = &s[6..11];\n}\n```\nRather than a reference to the entire String, hello is a reference to a portion of the String, \\\nWith Rust's `..` range syntax, if you want to start at index zero, you can drop the value before the two periods \\\nBy the same token, if your slice includes the last byte of the String, you can drop the trailing number. \n> Note: String slice range indices must occur at **valid UTF-8 character boundaries**. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.\n\n```rust\nfn first_word(s :&String) -> &str {\n    let bytes = s.as_bytes();\n    for(i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[..i];\n        }\n    }\n    &s[..]\n}\n```\n\n### String Literals Are Slices\n```rust\nfn main() {\nlet s = \"Hello, world!\";\n}\n```\nThe type of s here is &str: it's a slice pointing to that specific point of the binary. \n\n### String Slices as Parameters\n- Pass &str as a parameter, you can receive parameters of type &String and &str at the same time\n```rust\nfn first_word(s: &String) -> &str\n```\nequivalent to\n```rust\nfn first_word(s: &str) -> &str\n```\n\n### other slices\narray slice\n```rust\nfn main() {\n  let a = [1, 2, 3, 4, 5];\n  let slice = &a[1..3];\n  assert_eq!(slice, &[2, 3]);\n}\n```","source":"_posts/rust-03-ownership.md","raw":"---\ntitle: rust ownership\ndate: 2022-10-11 17:09:28\ntags: [rust]\n---\n\n## ownership rule\n- Each value in Rust has an owner.\n- There can only be one owner at a time.\n- When the owner goes out of scope, the value will be dropped.\n\n## variable scope\n```rust\nfn main() {\n    {                      // s is not valid here, it’s not yet declared\n        let s = \"hello\";   // s is valid from this point forward\n        // do stuff with s\n    }                      // this scope is now over, and s is no longer valid\n}\n```\n\n## Move\n### stack-only data: Copy trait\nsuch as primitive type\n```rust\nfn main() {\n    let x = 5;\n    let y = x;\n}\n```\nbind the value 5 to x; then make a copy of the value in x and bind it to y.\n\n### for heap variable\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n}\n```\n![move-string](/images/rust/ownership/move-string.png)\nptr, len, capacity is stored in stack, while string value is stored in heap \\\nWhen we assign s1 to s2, the String data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap\n![move-string-2](/images/rust/ownership/move-string-2.png)\nsimilar to shallow copy\n\n## Clone\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}\n```\nIf we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.\n\n### ownership and function\n- Passing a value to a function will result in a move or copy of ownership\n- difference between \"stack\" and \"heap\" variables: stack variables will be copied, and heap variables will be moved. When a variable containing heap data leaves the scope, its value will be cleared by the drop function, unless the ownership of the data is moved to another variable\n```rust\nfn main() {\n    let s = String::from(\"hello\");  // s comes into scope\n    takes_ownership(s);             // s's value moves into the function...\n                                    // ... and so is no longer valid here\n\n    let x = 5;                      // x comes into scope\n\n    makes_copy(x);                  // x would move into the function,\n                                    // but i32 is Copy, so it's okay to still\n                                    // use x afterward\n\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(\"{}\", some_string);\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n\n```\n\n### return values and scope\n```rust\nfn main() {\n    let s1 = gives_ownership();         // gives_ownership moves its return\n                                        // value into s1\n\n    let s2 = String::from(\"hello\");     // s2 comes into scope\n\n    let s3 = takes_and_gives_back(s2);  // s2 is moved into\n                                        // takes_and_gives_back, which also\n                                        // moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\nfn gives_ownership() -> String {             // gives_ownership will move its\n                                             // return value into the function\n                                             // that calls it\n\n    let some_string = String::from(\"yours\"); // some_string comes into scope\n\n    some_string                              // some_string is returned and\n                                             // moves out to the calling\n                                             // function\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -> String { // a_string comes into\n                                                      // scope\n\n    a_string  // a_string is returned and moves out to the calling function\n}\n```\n> What if we want to let a function use a value but not take ownership?  \n> that's reference\n \n\n## reference & borrow\n- & means reference (borrow but not own)， default immutable\n- &mut a mutable reference， only one mutable reference allowed in same scope (avoid data racing)\n- Multiple mutable references can be created non-simultaneously by creating a new scope\n- **Cannot have mutable and immutable references at the same time**\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n    {\n        let s1 = &mut s;\n    } // r1 goes out of scope here, so we can make a new reference with no problems.\n    let s2 = &mut s;\n}\n\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // no problem\n    let r2 = &s; // no problem\n    println!(\"{} and {}\", r1, r2);\n    // variables r1 and r2 will not be used after this point\n\n    let r3 = &mut s; // no problem\n    println!(\"{}\", r3);\n\n    println!{\"{}\",r1} // got problem with above mutable borrow\n}\n```\n\n### reference as function arguments\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize { // s is a reference to a String\n    s.len() \n}  // Here, s goes out of scope. But because it does not have ownership of what\n   // it refers to, nothing happens.\n```\nwe pass &s1 into calculate_length and, in its definition, we take &String rather than String. These ampersands represent references, and they allow you to refer to some value without taking ownership of it. Because it does not own it, the value it points to will not be dropped when the reference stops being used. \\\n When functions have references as parameters instead of the actual values, we won't need to return the values in order to give back ownership, because we never had ownership. \\\n We call the action of creating a reference borrowing. \n\n### mutable references\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n### dangling references\n- A pointer refers to an address in memory, but the memory may have been freed and allocated for use by someone else\n- rust，The compiler can guarantee that there will never be dangling references\n```rust\nfn main() {\n    let r = dangle();\n}\nfn dangle() -> &string {  // dangle returns a reference to a String\n    let s = String::from(\"hello\");  // s is a new String\n    &s // we return a reference to the String, s\n} // Here, s goes out of scope, and is dropped. Its memory goes away.\n// Danger\n```\nThe solution here is to return the String directly:\n```rust\nfn main() {\n    let string = no_dangle();\n}\n\nfn no_dangle() -> String {\n    let s = String::from(\"hello\");\n    s\n}\n```\nThis works without any problems. Ownership is moved out, and nothing is deallocated.\n\n\n## slice\n- Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership.\n\n### string slice\n```rust\nfn main() {\n    let mut s = String::from(\"Hello world\");\n\n    let hello = &s[0..5]; \n    let world = &s[6..11];\n}\n```\nRather than a reference to the entire String, hello is a reference to a portion of the String, \\\nWith Rust's `..` range syntax, if you want to start at index zero, you can drop the value before the two periods \\\nBy the same token, if your slice includes the last byte of the String, you can drop the trailing number. \n> Note: String slice range indices must occur at **valid UTF-8 character boundaries**. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.\n\n```rust\nfn first_word(s :&String) -> &str {\n    let bytes = s.as_bytes();\n    for(i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[..i];\n        }\n    }\n    &s[..]\n}\n```\n\n### String Literals Are Slices\n```rust\nfn main() {\nlet s = \"Hello, world!\";\n}\n```\nThe type of s here is &str: it's a slice pointing to that specific point of the binary. \n\n### String Slices as Parameters\n- Pass &str as a parameter, you can receive parameters of type &String and &str at the same time\n```rust\nfn first_word(s: &String) -> &str\n```\nequivalent to\n```rust\nfn first_word(s: &str) -> &str\n```\n\n### other slices\narray slice\n```rust\nfn main() {\n  let a = [1, 2, 3, 4, 5];\n  let slice = &a[1..3];\n  assert_eq!(slice, &[2, 3]);\n}\n```","slug":"rust-03-ownership","published":1,"updated":"2023-05-01T13:17:32.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2to000k6usj7ksx9owl","content":"<h2 id=\"ownership-rule\"><a href=\"#ownership-rule\" class=\"headerlink\" title=\"ownership rule\"></a>ownership rule</h2><ul>\n<li>Each value in Rust has an owner.</li>\n<li>There can only be one owner at a time.</li>\n<li>When the owner goes out of scope, the value will be dropped.</li>\n</ul>\n<h2 id=\"variable-scope\"><a href=\"#variable-scope\" class=\"headerlink\" title=\"variable scope\"></a>variable scope</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    &#123;                      <span class=\"comment\">// s is not valid here, it’s not yet declared</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"string\">&quot;hello&quot;</span>;   <span class=\"comment\">// s is valid from this point forward</span></span><br><span class=\"line\">        <span class=\"comment\">// do stuff with s</span></span><br><span class=\"line\">    &#125;                      <span class=\"comment\">// this scope is now over, and s is no longer valid</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Move\"><a href=\"#Move\" class=\"headerlink\" title=\"Move\"></a>Move</h2><h3 id=\"stack-only-data-Copy-trait\"><a href=\"#stack-only-data-Copy-trait\" class=\"headerlink\" title=\"stack-only data: Copy trait\"></a>stack-only data: Copy trait</h3><p>such as primitive type</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bind the value 5 to x; then make a copy of the value in x and bind it to y.</p>\n<h3 id=\"for-heap-variable\"><a href=\"#for-heap-variable\" class=\"headerlink\" title=\"for heap variable\"></a>for heap variable</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s2</span> = s1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/rust/ownership/move-string.png\" alt=\"move-string\"><br>ptr, len, capacity is stored in stack, while string value is stored in heap <br>When we assign s1 to s2, the String data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap<br><img src=\"/images/rust/ownership/move-string-2.png\" alt=\"move-string-2\"><br>similar to shallow copy</p>\n<h2 id=\"Clone\"><a href=\"#Clone\" class=\"headerlink\" title=\"Clone\"></a>Clone</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s2</span> = s1.<span class=\"title function_ invoke__\">clone</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>If we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.</p>\n<h3 id=\"ownership-and-function\"><a href=\"#ownership-and-function\" class=\"headerlink\" title=\"ownership and function\"></a>ownership and function</h3><ul>\n<li>Passing a value to a function will result in a move or copy of ownership</li>\n<li>difference between “stack” and “heap” variables: stack variables will be copied, and heap variables will be moved. When a variable containing heap data leaves the scope, its value will be cleared by the drop function, unless the ownership of the data is moved to another variable<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);  <span class=\"comment\">// s comes into scope</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">takes_ownership</span>(s);             <span class=\"comment\">// s&#x27;s value moves into the function...</span></span><br><span class=\"line\">                                    <span class=\"comment\">// ... and so is no longer valid here</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">5</span>;                      <span class=\"comment\">// x comes into scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">makes_copy</span>(x);                  <span class=\"comment\">// x would move into the function,</span></span><br><span class=\"line\">                                    <span class=\"comment\">// but i32 is Copy, so it&#x27;s okay to still</span></span><br><span class=\"line\">                                    <span class=\"comment\">// use x afterward</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// special happens.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">takes_ownership</span>(some_string: <span class=\"type\">String</span>) &#123; <span class=\"comment\">// some_string comes into scope</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, some_string goes out of scope and `drop` is called. The backing</span></span><br><span class=\"line\">  <span class=\"comment\">// memory is freed.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">makes_copy</span>(some_integer: <span class=\"type\">i32</span>) &#123; <span class=\"comment\">// some_integer comes into scope</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, some_integer goes out of scope. Nothing special happens.</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"return-values-and-scope\"><a href=\"#return-values-and-scope\" class=\"headerlink\" title=\"return values and scope\"></a>return values and scope</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = <span class=\"title function_ invoke__\">gives_ownership</span>();         <span class=\"comment\">// gives_ownership moves its return</span></span><br><span class=\"line\">                                        <span class=\"comment\">// value into s1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s2</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);     <span class=\"comment\">// s2 comes into scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s3</span> = <span class=\"title function_ invoke__\">takes_and_gives_back</span>(s2);  <span class=\"comment\">// s2 is moved into</span></span><br><span class=\"line\">                                        <span class=\"comment\">// takes_and_gives_back, which also</span></span><br><span class=\"line\">                                        <span class=\"comment\">// moves its return value into s3</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// happens. s1 goes out of scope and is dropped.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">gives_ownership</span>() <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;             <span class=\"comment\">// gives_ownership will move its</span></span><br><span class=\"line\">                                             <span class=\"comment\">// return value into the function</span></span><br><span class=\"line\">                                             <span class=\"comment\">// that calls it</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">some_string</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;yours&quot;</span>); <span class=\"comment\">// some_string comes into scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">    some_string                              <span class=\"comment\">// some_string is returned and</span></span><br><span class=\"line\">                                             <span class=\"comment\">// moves out to the calling</span></span><br><span class=\"line\">                                             <span class=\"comment\">// function</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This function takes a String and returns one</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">takes_and_gives_back</span>(a_string: <span class=\"type\">String</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123; <span class=\"comment\">// a_string comes into</span></span><br><span class=\"line\">                                                      <span class=\"comment\">// scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a_string  <span class=\"comment\">// a_string is returned and moves out to the calling function</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>What if we want to let a function use a value but not take ownership?<br>that’s reference</p>\n</blockquote>\n<h2 id=\"reference-amp-borrow\"><a href=\"#reference-amp-borrow\" class=\"headerlink\" title=\"reference &amp; borrow\"></a>reference &amp; borrow</h2><ul>\n<li>&amp; means reference (borrow but not own)， default immutable</li>\n<li>&amp;mut a mutable reference， only one mutable reference allowed in same scope (avoid data racing)</li>\n<li>Multiple mutable references can be created non-simultaneously by creating a new scope</li>\n<li><strong>Cannot have mutable and immutable references at the same time</strong><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = &amp;<span class=\"keyword\">mut</span> s;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// r1 goes out of scope here, so we can make a new reference with no problems.</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s2</span> = &amp;<span class=\"keyword\">mut</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">r1</span> = &amp;s; <span class=\"comment\">// no problem</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">r2</span> = &amp;s; <span class=\"comment\">// no problem</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class=\"line\">    <span class=\"comment\">// variables r1 and r2 will not be used after this point</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">r3</span> = &amp;<span class=\"keyword\">mut</span> s; <span class=\"comment\">// no problem</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, r3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>&#123;<span class=\"string\">&quot;&#123;&#125;&quot;</span>,r1&#125; <span class=\"comment\">// got problem with above mutable borrow</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"reference-as-function-arguments\"><a href=\"#reference-as-function-arguments\" class=\"headerlink\" title=\"reference as function arguments\"></a>reference as function arguments</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">len</span> = <span class=\"title function_ invoke__\">calculate_length</span>(&amp;s1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">calculate_length</span>(s: &amp;<span class=\"type\">String</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">usize</span> &#123; <span class=\"comment\">// s is a reference to a String</span></span><br><span class=\"line\">    s.<span class=\"title function_ invoke__\">len</span>() </span><br><span class=\"line\">&#125;  <span class=\"comment\">// Here, s goes out of scope. But because it does not have ownership of what</span></span><br><span class=\"line\">   <span class=\"comment\">// it refers to, nothing happens.</span></span><br></pre></td></tr></table></figure>\n<p>we pass &amp;s1 into calculate_length and, in its definition, we take &amp;String rather than String. These ampersands represent references, and they allow you to refer to some value without taking ownership of it. Because it does not own it, the value it points to will not be dropped when the reference stops being used. <br> When functions have references as parameters instead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership. <br> We call the action of creating a reference borrowing. </p>\n<h3 id=\"mutable-references\"><a href=\"#mutable-references\" class=\"headerlink\" title=\"mutable references\"></a>mutable references</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">change</span>(&amp;<span class=\"keyword\">mut</span> s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">change</span>(some_string: &amp;<span class=\"keyword\">mut</span> <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    some_string.<span class=\"title function_ invoke__\">push_str</span>(<span class=\"string\">&quot;, world&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dangling-references\"><a href=\"#dangling-references\" class=\"headerlink\" title=\"dangling references\"></a>dangling references</h3><ul>\n<li>A pointer refers to an address in memory, but the memory may have been freed and allocated for use by someone else</li>\n<li>rust，The compiler can guarantee that there will never be dangling references<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">r</span> = <span class=\"title function_ invoke__\">dangle</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">dangle</span>() <span class=\"punctuation\">-&gt;</span> &amp;string &#123;  <span class=\"comment\">// dangle returns a reference to a String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);  <span class=\"comment\">// s is a new String</span></span><br><span class=\"line\">    &amp;s <span class=\"comment\">// we return a reference to the String, s</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, s goes out of scope, and is dropped. Its memory goes away.</span></span><br><span class=\"line\"><span class=\"comment\">// Danger</span></span><br></pre></td></tr></table></figure>\nThe solution here is to return the String directly:<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">string</span> = <span class=\"title function_ invoke__\">no_dangle</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">no_dangle</span>() <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nThis works without any problems. Ownership is moved out, and nothing is deallocated.</li>\n</ul>\n<h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2><ul>\n<li>Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership.</li>\n</ul>\n<h3 id=\"string-slice\"><a href=\"#string-slice\" class=\"headerlink\" title=\"string slice\"></a>string slice</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Hello world&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">hello</span> = &amp;s[<span class=\"number\">0</span>..<span class=\"number\">5</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">world</span> = &amp;s[<span class=\"number\">6</span>..<span class=\"number\">11</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Rather than a reference to the entire String, hello is a reference to a portion of the String, <br>With Rust’s <code>..</code> range syntax, if you want to start at index zero, you can drop the value before the two periods <br>By the same token, if your slice includes the last byte of the String, you can drop the trailing number. </p>\n<blockquote>\n<p>Note: String slice range indices must occur at <strong>valid UTF-8 character boundaries</strong>. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">first_word</span>(s :&amp;<span class=\"type\">String</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">bytes</span> = s.<span class=\"title function_ invoke__\">as_bytes</span>();</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">for</span>(i, &amp;item) <span class=\"keyword\">in</span> bytes.<span class=\"title function_ invoke__\">iter</span>().<span class=\"title function_ invoke__\">enumerate</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> item == <span class=\"string\">b&#x27; &#x27;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &amp;s[..i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;s[..]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"String-Literals-Are-Slices\"><a href=\"#String-Literals-Are-Slices\" class=\"headerlink\" title=\"String Literals Are Slices\"></a>String Literals Are Slices</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The type of s here is &amp;str: it’s a slice pointing to that specific point of the binary. </p>\n<h3 id=\"String-Slices-as-Parameters\"><a href=\"#String-Slices-as-Parameters\" class=\"headerlink\" title=\"String Slices as Parameters\"></a>String Slices as Parameters</h3><ul>\n<li>Pass &amp;str as a parameter, you can receive parameters of type &amp;String and &amp;str at the same time<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">first_word</span>(s: &amp;<span class=\"type\">String</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span></span><br></pre></td></tr></table></figure>\nequivalent to<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">first_word</span>(s: &amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"other-slices\"><a href=\"#other-slices\" class=\"headerlink\" title=\"other slices\"></a>other slices</h3><p>array slice</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">slice</span> = &amp;a[<span class=\"number\">1</span>..<span class=\"number\">3</span>];</span><br><span class=\"line\">  <span class=\"built_in\">assert_eq!</span>(slice, &amp;[<span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ownership-rule\"><a href=\"#ownership-rule\" class=\"headerlink\" title=\"ownership rule\"></a>ownership rule</h2><ul>\n<li>Each value in Rust has an owner.</li>\n<li>There can only be one owner at a time.</li>\n<li>When the owner goes out of scope, the value will be dropped.</li>\n</ul>\n<h2 id=\"variable-scope\"><a href=\"#variable-scope\" class=\"headerlink\" title=\"variable scope\"></a>variable scope</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    &#123;                      <span class=\"comment\">// s is not valid here, it’s not yet declared</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"string\">&quot;hello&quot;</span>;   <span class=\"comment\">// s is valid from this point forward</span></span><br><span class=\"line\">        <span class=\"comment\">// do stuff with s</span></span><br><span class=\"line\">    &#125;                      <span class=\"comment\">// this scope is now over, and s is no longer valid</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Move\"><a href=\"#Move\" class=\"headerlink\" title=\"Move\"></a>Move</h2><h3 id=\"stack-only-data-Copy-trait\"><a href=\"#stack-only-data-Copy-trait\" class=\"headerlink\" title=\"stack-only data: Copy trait\"></a>stack-only data: Copy trait</h3><p>such as primitive type</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bind the value 5 to x; then make a copy of the value in x and bind it to y.</p>\n<h3 id=\"for-heap-variable\"><a href=\"#for-heap-variable\" class=\"headerlink\" title=\"for heap variable\"></a>for heap variable</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s2</span> = s1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/rust/ownership/move-string.png\" alt=\"move-string\"><br>ptr, len, capacity is stored in stack, while string value is stored in heap <br>When we assign s1 to s2, the String data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap<br><img src=\"/images/rust/ownership/move-string-2.png\" alt=\"move-string-2\"><br>similar to shallow copy</p>\n<h2 id=\"Clone\"><a href=\"#Clone\" class=\"headerlink\" title=\"Clone\"></a>Clone</h2><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s2</span> = s1.<span class=\"title function_ invoke__\">clone</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>If we do want to deeply copy the heap data of the String, not just the stack data, we can use a common method called clone.</p>\n<h3 id=\"ownership-and-function\"><a href=\"#ownership-and-function\" class=\"headerlink\" title=\"ownership and function\"></a>ownership and function</h3><ul>\n<li>Passing a value to a function will result in a move or copy of ownership</li>\n<li>difference between “stack” and “heap” variables: stack variables will be copied, and heap variables will be moved. When a variable containing heap data leaves the scope, its value will be cleared by the drop function, unless the ownership of the data is moved to another variable<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);  <span class=\"comment\">// s comes into scope</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">takes_ownership</span>(s);             <span class=\"comment\">// s&#x27;s value moves into the function...</span></span><br><span class=\"line\">                                    <span class=\"comment\">// ... and so is no longer valid here</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">5</span>;                      <span class=\"comment\">// x comes into scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">makes_copy</span>(x);                  <span class=\"comment\">// x would move into the function,</span></span><br><span class=\"line\">                                    <span class=\"comment\">// but i32 is Copy, so it&#x27;s okay to still</span></span><br><span class=\"line\">                                    <span class=\"comment\">// use x afterward</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, x goes out of scope, then s. But because s&#x27;s value was moved, nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// special happens.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">takes_ownership</span>(some_string: <span class=\"type\">String</span>) &#123; <span class=\"comment\">// some_string comes into scope</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, some_string goes out of scope and `drop` is called. The backing</span></span><br><span class=\"line\">  <span class=\"comment\">// memory is freed.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">makes_copy</span>(some_integer: <span class=\"type\">i32</span>) &#123; <span class=\"comment\">// some_integer comes into scope</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, some_integer goes out of scope. Nothing special happens.</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"return-values-and-scope\"><a href=\"#return-values-and-scope\" class=\"headerlink\" title=\"return values and scope\"></a>return values and scope</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = <span class=\"title function_ invoke__\">gives_ownership</span>();         <span class=\"comment\">// gives_ownership moves its return</span></span><br><span class=\"line\">                                        <span class=\"comment\">// value into s1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s2</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);     <span class=\"comment\">// s2 comes into scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s3</span> = <span class=\"title function_ invoke__\">takes_and_gives_back</span>(s2);  <span class=\"comment\">// s2 is moved into</span></span><br><span class=\"line\">                                        <span class=\"comment\">// takes_and_gives_back, which also</span></span><br><span class=\"line\">                                        <span class=\"comment\">// moves its return value into s3</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span></span><br><span class=\"line\">  <span class=\"comment\">// happens. s1 goes out of scope and is dropped.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">gives_ownership</span>() <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;             <span class=\"comment\">// gives_ownership will move its</span></span><br><span class=\"line\">                                             <span class=\"comment\">// return value into the function</span></span><br><span class=\"line\">                                             <span class=\"comment\">// that calls it</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">some_string</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;yours&quot;</span>); <span class=\"comment\">// some_string comes into scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">    some_string                              <span class=\"comment\">// some_string is returned and</span></span><br><span class=\"line\">                                             <span class=\"comment\">// moves out to the calling</span></span><br><span class=\"line\">                                             <span class=\"comment\">// function</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This function takes a String and returns one</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">takes_and_gives_back</span>(a_string: <span class=\"type\">String</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123; <span class=\"comment\">// a_string comes into</span></span><br><span class=\"line\">                                                      <span class=\"comment\">// scope</span></span><br><span class=\"line\"></span><br><span class=\"line\">    a_string  <span class=\"comment\">// a_string is returned and moves out to the calling function</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>What if we want to let a function use a value but not take ownership?<br>that’s reference</p>\n</blockquote>\n<h2 id=\"reference-amp-borrow\"><a href=\"#reference-amp-borrow\" class=\"headerlink\" title=\"reference &amp; borrow\"></a>reference &amp; borrow</h2><ul>\n<li>&amp; means reference (borrow but not own)， default immutable</li>\n<li>&amp;mut a mutable reference， only one mutable reference allowed in same scope (avoid data racing)</li>\n<li>Multiple mutable references can be created non-simultaneously by creating a new scope</li>\n<li><strong>Cannot have mutable and immutable references at the same time</strong><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = &amp;<span class=\"keyword\">mut</span> s;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// r1 goes out of scope here, so we can make a new reference with no problems.</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s2</span> = &amp;<span class=\"keyword\">mut</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">r1</span> = &amp;s; <span class=\"comment\">// no problem</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">r2</span> = &amp;s; <span class=\"comment\">// no problem</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class=\"line\">    <span class=\"comment\">// variables r1 and r2 will not be used after this point</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">r3</span> = &amp;<span class=\"keyword\">mut</span> s; <span class=\"comment\">// no problem</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, r3);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>&#123;<span class=\"string\">&quot;&#123;&#125;&quot;</span>,r1&#125; <span class=\"comment\">// got problem with above mutable borrow</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"reference-as-function-arguments\"><a href=\"#reference-as-function-arguments\" class=\"headerlink\" title=\"reference as function arguments\"></a>reference as function arguments</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s1</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">len</span> = <span class=\"title function_ invoke__\">calculate_length</span>(&amp;s1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">calculate_length</span>(s: &amp;<span class=\"type\">String</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">usize</span> &#123; <span class=\"comment\">// s is a reference to a String</span></span><br><span class=\"line\">    s.<span class=\"title function_ invoke__\">len</span>() </span><br><span class=\"line\">&#125;  <span class=\"comment\">// Here, s goes out of scope. But because it does not have ownership of what</span></span><br><span class=\"line\">   <span class=\"comment\">// it refers to, nothing happens.</span></span><br></pre></td></tr></table></figure>\n<p>we pass &amp;s1 into calculate_length and, in its definition, we take &amp;String rather than String. These ampersands represent references, and they allow you to refer to some value without taking ownership of it. Because it does not own it, the value it points to will not be dropped when the reference stops being used. <br> When functions have references as parameters instead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership. <br> We call the action of creating a reference borrowing. </p>\n<h3 id=\"mutable-references\"><a href=\"#mutable-references\" class=\"headerlink\" title=\"mutable references\"></a>mutable references</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">change</span>(&amp;<span class=\"keyword\">mut</span> s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">change</span>(some_string: &amp;<span class=\"keyword\">mut</span> <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    some_string.<span class=\"title function_ invoke__\">push_str</span>(<span class=\"string\">&quot;, world&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dangling-references\"><a href=\"#dangling-references\" class=\"headerlink\" title=\"dangling references\"></a>dangling references</h3><ul>\n<li>A pointer refers to an address in memory, but the memory may have been freed and allocated for use by someone else</li>\n<li>rust，The compiler can guarantee that there will never be dangling references<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">r</span> = <span class=\"title function_ invoke__\">dangle</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">dangle</span>() <span class=\"punctuation\">-&gt;</span> &amp;string &#123;  <span class=\"comment\">// dangle returns a reference to a String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);  <span class=\"comment\">// s is a new String</span></span><br><span class=\"line\">    &amp;s <span class=\"comment\">// we return a reference to the String, s</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// Here, s goes out of scope, and is dropped. Its memory goes away.</span></span><br><span class=\"line\"><span class=\"comment\">// Danger</span></span><br></pre></td></tr></table></figure>\nThe solution here is to return the String directly:<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">string</span> = <span class=\"title function_ invoke__\">no_dangle</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">no_dangle</span>() <span class=\"punctuation\">-&gt;</span> <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    s</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nThis works without any problems. Ownership is moved out, and nothing is deallocated.</li>\n</ul>\n<h2 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h2><ul>\n<li>Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership.</li>\n</ul>\n<h3 id=\"string-slice\"><a href=\"#string-slice\" class=\"headerlink\" title=\"string slice\"></a>string slice</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">s</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Hello world&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">hello</span> = &amp;s[<span class=\"number\">0</span>..<span class=\"number\">5</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">world</span> = &amp;s[<span class=\"number\">6</span>..<span class=\"number\">11</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Rather than a reference to the entire String, hello is a reference to a portion of the String, <br>With Rust’s <code>..</code> range syntax, if you want to start at index zero, you can drop the value before the two periods <br>By the same token, if your slice includes the last byte of the String, you can drop the trailing number. </p>\n<blockquote>\n<p>Note: String slice range indices must occur at <strong>valid UTF-8 character boundaries</strong>. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.</p>\n</blockquote>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">first_word</span>(s :&amp;<span class=\"type\">String</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">bytes</span> = s.<span class=\"title function_ invoke__\">as_bytes</span>();</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">for</span>(i, &amp;item) <span class=\"keyword\">in</span> bytes.<span class=\"title function_ invoke__\">iter</span>().<span class=\"title function_ invoke__\">enumerate</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> item == <span class=\"string\">b&#x27; &#x27;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &amp;s[..i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;s[..]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"String-Literals-Are-Slices\"><a href=\"#String-Literals-Are-Slices\" class=\"headerlink\" title=\"String Literals Are Slices\"></a>String Literals Are Slices</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"variable\">s</span> = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The type of s here is &amp;str: it’s a slice pointing to that specific point of the binary. </p>\n<h3 id=\"String-Slices-as-Parameters\"><a href=\"#String-Slices-as-Parameters\" class=\"headerlink\" title=\"String Slices as Parameters\"></a>String Slices as Parameters</h3><ul>\n<li>Pass &amp;str as a parameter, you can receive parameters of type &amp;String and &amp;str at the same time<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">first_word</span>(s: &amp;<span class=\"type\">String</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span></span><br></pre></td></tr></table></figure>\nequivalent to<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">first_word</span>(s: &amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"other-slices\"><a href=\"#other-slices\" class=\"headerlink\" title=\"other slices\"></a>other slices</h3><p>array slice</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"variable\">slice</span> = &amp;a[<span class=\"number\">1</span>..<span class=\"number\">3</span>];</span><br><span class=\"line\">  <span class=\"built_in\">assert_eq!</span>(slice, &amp;[<span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"rust lifetime","date":"2022-10-18T13:33:26.000Z","_content":"\n## lifetime\n- Every reference in Rust has its own lifecycle\n- most of the time, Rust's lifetime is implicit and can be inferred\n- There are two types of life cycle: input life cycle and output life cycle\n- 'static is a special life cycle annotation\n### Example of lifetime out of scope\n```rust\nfn main() {\n    let mut x;\n    {\n        let y = String::from(\"hello\");\n        // x = y; // this is allowed\n        x = &y; // not allowed. borrowed value (y) does not live long enough\n    }\n    println!(\"Str:{}\", x);\n}\n```\n\n### lifetime checker\nRust compiler's borrow checker to determine whether a borrow is legal\n```rust\n// If it returns a reference value, no matter how simple your function is written, it will always report an error `missing lifetime specifier.`\nfn longest(x:&str, y:&str) -> &str { /// this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\n    if x.len() > y.len() {\n        x\n    }else{\n        y\n    }\n}\n```\nlet's find out why it is such case\n```rust\nfn main() {\n    // variable to hold the result value\n    let long_str; \n\n    let x = \"abc\".to_string();\n    {\n        let y = \"bbccd\".to_string();\n        long_str = longest(x.as_str(), y.as_str());\n    }\n    // if x.len() > y.len() then it is OK，the long_str variable will hole x; if not, long_str supposed tohold y, however, y has a smaller scope than x, long_str will hold to a dropped value\n    println!(\"Longest str: {}\", long_str);\n}\n\n```\nHence, we need lifetime annotation `'`\n```rust\nfn longest<'a>(x:&'a str, y:&'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    }else{\n        y\n    }\n}\n```\n\n### deeper understanding\n- When returning a reference value from a function, the lifetime of the return type needs to match the lifetime of one of the parameters\n\n### Struct lifetime annotation\n```rust\nfn main() {\n    let info = String::from(\"File not found.\");\n    // 存放结果值的变量\n    let exc = ImportantExcepiton {\n        part: info.as_str()\n    };\n\n    println!(\"{:?}\", exc);\n}\n#[derive(Debug)]\nstruct ImportantExcepiton<'a> {\n    part: &'a str,\n}\n```\n- lifetime of the field `part` must be longer than struct\n\n### Lifetime Elision\nIn order to make common patterns more ergonomic, Rust allows lifetimes to be elided in function signatures.\nElision rules are as follows:\n- Each elided lifetime in input position becomes a distinct lifetime parameter.\n- If there is exactly one input lifetime position (elided or not), that lifetime is assigned to all elided output lifetimes.\n- If there are multiple input lifetime positions, but one of them is &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n- Otherwise, it is an error to elide an output lifetime.\n\n### struct lifetime annotation\n```rust\n\nfn main() {\n    let info = String::from(\"File not found.\");\n    let exc = ImportantExcepiton {\n        part: info.as_str()\n    };\n\n    println!(\"{:?}\", exc);\n}\n#[derive(Debug)]\nstruct ImportantExcepiton <'a>{\n    part: &'a str,\n}\n\n// the first 'a is decraration, the second is usage\nimpl<'a> ImportantExcepiton <'a> {\n    // in return value, 'a is omitted according to Lifetime Elision rule\n    fn callname(&self ) -> &str{\n        self.part\n    }\n}\n```\n\n### 'static\n'static is a special lifetime that takes up the duration of the entire program, for example all string literals have a 'static lifetime","source":"_posts/rust-04-lifetime.md","raw":"---\ntitle: rust lifetime\ndate: 2022-10-18 21:33:26\ntags: [rust]\n---\n\n## lifetime\n- Every reference in Rust has its own lifecycle\n- most of the time, Rust's lifetime is implicit and can be inferred\n- There are two types of life cycle: input life cycle and output life cycle\n- 'static is a special life cycle annotation\n### Example of lifetime out of scope\n```rust\nfn main() {\n    let mut x;\n    {\n        let y = String::from(\"hello\");\n        // x = y; // this is allowed\n        x = &y; // not allowed. borrowed value (y) does not live long enough\n    }\n    println!(\"Str:{}\", x);\n}\n```\n\n### lifetime checker\nRust compiler's borrow checker to determine whether a borrow is legal\n```rust\n// If it returns a reference value, no matter how simple your function is written, it will always report an error `missing lifetime specifier.`\nfn longest(x:&str, y:&str) -> &str { /// this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\n    if x.len() > y.len() {\n        x\n    }else{\n        y\n    }\n}\n```\nlet's find out why it is such case\n```rust\nfn main() {\n    // variable to hold the result value\n    let long_str; \n\n    let x = \"abc\".to_string();\n    {\n        let y = \"bbccd\".to_string();\n        long_str = longest(x.as_str(), y.as_str());\n    }\n    // if x.len() > y.len() then it is OK，the long_str variable will hole x; if not, long_str supposed tohold y, however, y has a smaller scope than x, long_str will hold to a dropped value\n    println!(\"Longest str: {}\", long_str);\n}\n\n```\nHence, we need lifetime annotation `'`\n```rust\nfn longest<'a>(x:&'a str, y:&'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    }else{\n        y\n    }\n}\n```\n\n### deeper understanding\n- When returning a reference value from a function, the lifetime of the return type needs to match the lifetime of one of the parameters\n\n### Struct lifetime annotation\n```rust\nfn main() {\n    let info = String::from(\"File not found.\");\n    // 存放结果值的变量\n    let exc = ImportantExcepiton {\n        part: info.as_str()\n    };\n\n    println!(\"{:?}\", exc);\n}\n#[derive(Debug)]\nstruct ImportantExcepiton<'a> {\n    part: &'a str,\n}\n```\n- lifetime of the field `part` must be longer than struct\n\n### Lifetime Elision\nIn order to make common patterns more ergonomic, Rust allows lifetimes to be elided in function signatures.\nElision rules are as follows:\n- Each elided lifetime in input position becomes a distinct lifetime parameter.\n- If there is exactly one input lifetime position (elided or not), that lifetime is assigned to all elided output lifetimes.\n- If there are multiple input lifetime positions, but one of them is &self or &mut self, the lifetime of self is assigned to all elided output lifetimes.\n- Otherwise, it is an error to elide an output lifetime.\n\n### struct lifetime annotation\n```rust\n\nfn main() {\n    let info = String::from(\"File not found.\");\n    let exc = ImportantExcepiton {\n        part: info.as_str()\n    };\n\n    println!(\"{:?}\", exc);\n}\n#[derive(Debug)]\nstruct ImportantExcepiton <'a>{\n    part: &'a str,\n}\n\n// the first 'a is decraration, the second is usage\nimpl<'a> ImportantExcepiton <'a> {\n    // in return value, 'a is omitted according to Lifetime Elision rule\n    fn callname(&self ) -> &str{\n        self.part\n    }\n}\n```\n\n### 'static\n'static is a special lifetime that takes up the duration of the entire program, for example all string literals have a 'static lifetime","slug":"rust-04-lifetime","published":1,"updated":"2023-05-01T14:08:49.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tp000l6usjfku62qis","content":"<h2 id=\"lifetime\"><a href=\"#lifetime\" class=\"headerlink\" title=\"lifetime\"></a>lifetime</h2><ul>\n<li>Every reference in Rust has its own lifecycle</li>\n<li>most of the time, Rust’s lifetime is implicit and can be inferred</li>\n<li>There are two types of life cycle: input life cycle and output life cycle</li>\n<li>‘static is a special life cycle annotation</li>\n</ul>\n<h3 id=\"Example-of-lifetime-out-of-scope\"><a href=\"#Example-of-lifetime-out-of-scope\" class=\"headerlink\" title=\"Example of lifetime out of scope\"></a>Example of lifetime out of scope</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">x</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// x = y; // this is allowed</span></span><br><span class=\"line\">        x = &amp;y; <span class=\"comment\">// not allowed. borrowed value (y) does not live long enough</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Str:&#123;&#125;&quot;</span>, x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lifetime-checker\"><a href=\"#lifetime-checker\" class=\"headerlink\" title=\"lifetime checker\"></a>lifetime checker</h3><p>Rust compiler’s borrow checker to determine whether a borrow is legal</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// If it returns a reference value, no matter how simple your function is written, it will always report an error `missing lifetime specifier.`</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">longest</span>(x:&amp;<span class=\"type\">str</span>, y:&amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span> &#123; <span class=\"comment\">/// this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x.<span class=\"title function_ invoke__\">len</span>() &gt; y.<span class=\"title function_ invoke__\">len</span>() &#123;</span><br><span class=\"line\">        x</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>let’s find out why it is such case</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// variable to hold the result value</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">long_str</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"string\">&quot;abc&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = <span class=\"string\">&quot;bbccd&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">        long_str = <span class=\"title function_ invoke__\">longest</span>(x.<span class=\"title function_ invoke__\">as_str</span>(), y.<span class=\"title function_ invoke__\">as_str</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// if x.len() &gt; y.len() then it is OK，the long_str variable will hole x; if not, long_str supposed tohold y, however, y has a smaller scope than x, long_str will hold to a dropped value</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Longest str: &#123;&#125;&quot;</span>, long_str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Hence, we need lifetime annotation <code>&#39;</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">longest</span>&lt;<span class=\"symbol\">&#x27;a</span>&gt;(x:&amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span>, y:&amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x.<span class=\"title function_ invoke__\">len</span>() &gt; y.<span class=\"title function_ invoke__\">len</span>() &#123;</span><br><span class=\"line\">        x</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"deeper-understanding\"><a href=\"#deeper-understanding\" class=\"headerlink\" title=\"deeper understanding\"></a>deeper understanding</h3><ul>\n<li>When returning a reference value from a function, the lifetime of the return type needs to match the lifetime of one of the parameters</li>\n</ul>\n<h3 id=\"Struct-lifetime-annotation\"><a href=\"#Struct-lifetime-annotation\" class=\"headerlink\" title=\"Struct lifetime annotation\"></a>Struct lifetime annotation</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">info</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;File not found.&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 存放结果值的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">exc</span> = ImportantExcepiton &#123;</span><br><span class=\"line\">        part: info.<span class=\"title function_ invoke__\">as_str</span>()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, exc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ImportantExcepiton</span>&lt;<span class=\"symbol\">&#x27;a</span>&gt; &#123;</span><br><span class=\"line\">    part: &amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>lifetime of the field <code>part</code> must be longer than struct</li>\n</ul>\n<h3 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h3><p>In order to make common patterns more ergonomic, Rust allows lifetimes to be elided in function signatures.<br>Elision rules are as follows:</p>\n<ul>\n<li>Each elided lifetime in input position becomes a distinct lifetime parameter.</li>\n<li>If there is exactly one input lifetime position (elided or not), that lifetime is assigned to all elided output lifetimes.</li>\n<li>If there are multiple input lifetime positions, but one of them is &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.</li>\n<li>Otherwise, it is an error to elide an output lifetime.</li>\n</ul>\n<h3 id=\"struct-lifetime-annotation\"><a href=\"#struct-lifetime-annotation\" class=\"headerlink\" title=\"struct lifetime annotation\"></a>struct lifetime annotation</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">info</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;File not found.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">exc</span> = ImportantExcepiton &#123;</span><br><span class=\"line\">        part: info.<span class=\"title function_ invoke__\">as_str</span>()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, exc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ImportantExcepiton</span> &lt;<span class=\"symbol\">&#x27;a</span>&gt;&#123;</span><br><span class=\"line\">    part: &amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the first &#x27;a is decraration, the second is usage</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;<span class=\"symbol\">&#x27;a</span>&gt; ImportantExcepiton &lt;<span class=\"symbol\">&#x27;a</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// in return value, &#x27;a is omitted according to Lifetime Elision rule</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">callname</span>(&amp;<span class=\"keyword\">self</span> ) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.part</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"‘static\"><a href=\"#‘static\" class=\"headerlink\" title=\"‘static\"></a>‘static</h3><p>‘static is a special lifetime that takes up the duration of the entire program, for example all string literals have a ‘static lifetime</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"lifetime\"><a href=\"#lifetime\" class=\"headerlink\" title=\"lifetime\"></a>lifetime</h2><ul>\n<li>Every reference in Rust has its own lifecycle</li>\n<li>most of the time, Rust’s lifetime is implicit and can be inferred</li>\n<li>There are two types of life cycle: input life cycle and output life cycle</li>\n<li>‘static is a special life cycle annotation</li>\n</ul>\n<h3 id=\"Example-of-lifetime-out-of-scope\"><a href=\"#Example-of-lifetime-out-of-scope\" class=\"headerlink\" title=\"Example of lifetime out of scope\"></a>Example of lifetime out of scope</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">x</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// x = y; // this is allowed</span></span><br><span class=\"line\">        x = &amp;y; <span class=\"comment\">// not allowed. borrowed value (y) does not live long enough</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Str:&#123;&#125;&quot;</span>, x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lifetime-checker\"><a href=\"#lifetime-checker\" class=\"headerlink\" title=\"lifetime checker\"></a>lifetime checker</h3><p>Rust compiler’s borrow checker to determine whether a borrow is legal</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// If it returns a reference value, no matter how simple your function is written, it will always report an error `missing lifetime specifier.`</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">longest</span>(x:&amp;<span class=\"type\">str</span>, y:&amp;<span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span> &#123; <span class=\"comment\">/// this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x.<span class=\"title function_ invoke__\">len</span>() &gt; y.<span class=\"title function_ invoke__\">len</span>() &#123;</span><br><span class=\"line\">        x</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>let’s find out why it is such case</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// variable to hold the result value</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">long_str</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"string\">&quot;abc&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = <span class=\"string\">&quot;bbccd&quot;</span>.<span class=\"title function_ invoke__\">to_string</span>();</span><br><span class=\"line\">        long_str = <span class=\"title function_ invoke__\">longest</span>(x.<span class=\"title function_ invoke__\">as_str</span>(), y.<span class=\"title function_ invoke__\">as_str</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// if x.len() &gt; y.len() then it is OK，the long_str variable will hole x; if not, long_str supposed tohold y, however, y has a smaller scope than x, long_str will hold to a dropped value</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Longest str: &#123;&#125;&quot;</span>, long_str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Hence, we need lifetime annotation <code>&#39;</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">longest</span>&lt;<span class=\"symbol\">&#x27;a</span>&gt;(x:&amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span>, y:&amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x.<span class=\"title function_ invoke__\">len</span>() &gt; y.<span class=\"title function_ invoke__\">len</span>() &#123;</span><br><span class=\"line\">        x</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        y</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"deeper-understanding\"><a href=\"#deeper-understanding\" class=\"headerlink\" title=\"deeper understanding\"></a>deeper understanding</h3><ul>\n<li>When returning a reference value from a function, the lifetime of the return type needs to match the lifetime of one of the parameters</li>\n</ul>\n<h3 id=\"Struct-lifetime-annotation\"><a href=\"#Struct-lifetime-annotation\" class=\"headerlink\" title=\"Struct lifetime annotation\"></a>Struct lifetime annotation</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">info</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;File not found.&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 存放结果值的变量</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">exc</span> = ImportantExcepiton &#123;</span><br><span class=\"line\">        part: info.<span class=\"title function_ invoke__\">as_str</span>()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, exc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ImportantExcepiton</span>&lt;<span class=\"symbol\">&#x27;a</span>&gt; &#123;</span><br><span class=\"line\">    part: &amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>lifetime of the field <code>part</code> must be longer than struct</li>\n</ul>\n<h3 id=\"Lifetime-Elision\"><a href=\"#Lifetime-Elision\" class=\"headerlink\" title=\"Lifetime Elision\"></a>Lifetime Elision</h3><p>In order to make common patterns more ergonomic, Rust allows lifetimes to be elided in function signatures.<br>Elision rules are as follows:</p>\n<ul>\n<li>Each elided lifetime in input position becomes a distinct lifetime parameter.</li>\n<li>If there is exactly one input lifetime position (elided or not), that lifetime is assigned to all elided output lifetimes.</li>\n<li>If there are multiple input lifetime positions, but one of them is &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.</li>\n<li>Otherwise, it is an error to elide an output lifetime.</li>\n</ul>\n<h3 id=\"struct-lifetime-annotation\"><a href=\"#struct-lifetime-annotation\" class=\"headerlink\" title=\"struct lifetime annotation\"></a>struct lifetime annotation</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">info</span> = <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;File not found.&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">exc</span> = ImportantExcepiton &#123;</span><br><span class=\"line\">        part: info.<span class=\"title function_ invoke__\">as_str</span>()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;:?&#125;&quot;</span>, exc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ImportantExcepiton</span> &lt;<span class=\"symbol\">&#x27;a</span>&gt;&#123;</span><br><span class=\"line\">    part: &amp;<span class=\"symbol\">&#x27;a</span> <span class=\"type\">str</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the first &#x27;a is decraration, the second is usage</span></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;<span class=\"symbol\">&#x27;a</span>&gt; ImportantExcepiton &lt;<span class=\"symbol\">&#x27;a</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// in return value, &#x27;a is omitted according to Lifetime Elision rule</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">callname</span>(&amp;<span class=\"keyword\">self</span> ) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"type\">str</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.part</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"‘static\"><a href=\"#‘static\" class=\"headerlink\" title=\"‘static\"></a>‘static</h3><p>‘static is a special lifetime that takes up the duration of the entire program, for example all string literals have a ‘static lifetime</p>\n"},{"title":"rust smart pointer","date":"2022-10-30T03:00:38.000Z","_content":"\n## Overview\nThe most common kind of pointer in Rust is a reference (borrow but not own)\nSmart pointers, on the other hand, are data structures that not only act like a pointer but also have additional metadata and capabilities.\nreferences are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.\n\n### smart pointers example\n- String\n- Vec<T>\nBoth these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with String ensuring its data will always be valid UTF-8).\n\n### Deref & Drop\nSmart pointers are usually implemented using structs. The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the `Deref` and `Drop` traits.\n- The Deref trait allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers. \n- The Drop trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.\n\n### the most common smart pointers in the standard library:\n- `Box<T>` for allocating values on the heap\n- `Rc<T>`, a reference counting type that enables multiple ownership\n- `Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that enforces the borrowing rules at runtime instead of compile time\n\n## Box<T>\n### when to use\n- When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size. (such as cons)\n- When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so\n- When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type\n\n\n### enabling recursive types with Box\nAt compile time, Rust needs to know how much space a type takes up\nOne type whose size can’t be known at compile time is a recursive type (cons list), use Box, which only contains a memory address\n\n```rust\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil))); // not allowed, infinite size\n}\n```\n\nuse Box\n```rust\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n```\n\n## Treating Smart Pointers Like Regular References with the Deref Trait\nImplementing the Deref trait allows you to customize the behavior of the dereference operator, `*`\nBy implementing Deref in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.\n\n### Defining Our Own Smart Pointer\n```rust\nuse std::ops::Deref;\n\nstruct MyBox<T>(T);  // The MyBox type is a tuple struct with one element of type T\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n- We fill in the body of the deref method with &self.0 so deref returns a reference to the value we want to access with the * operator. \n- behind the scenes Rust actually ran this code: <code>*(y.deref())</code>. Rust substitutes the * operator with a call to the deref method\n- The reason the deref method returns a reference to a value, and that the plain dereference outside the parentheses in *(y.deref()) is still necessary, is the ownership system. If the deref method returned the value directly instead of a reference to the value, the value would be moved out of self. We don’t want to take ownership of the inner value inside MyBox<T> in this case or in most cases where we use the dereference operator.\n\n### Implicit Deref Coercions with Functions and Methods\nDeref coercion is a convenience that Rust performs on arguments to functions and methods. \nDeref coercion works only on types that implement the Deref trait. Deref coercion converts a reference to such a type into a reference to another type. For example, deref coercion can convert &String to &str because String implements the Deref trait such that it returns &str\nA sequence of calls to the deref method converts the type we provided into the type the parameter needs.\n\n```rust\nfn hello(name: &str) {\n    println!(\"Hello, {}!\", name);\n}\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(\"rust\");  // ok\n    hello(&m);      // also ok\n    hello(&(*m)[..]); // without deref coercion. The (*m) dereferences the MyBox<String> into a String. Then the & and [..] take a string slice of the String that is equal to the whole string to match the signature of hello\n}\n```\nHere we’re calling the hello function with the argument &m, which is a reference to a MyBox<String> value. Because we implemented the Deref trait on MyBox<T>, Rust can turn &MyBox<String> into &String by calling deref. The standard library provides an implementation of Deref on String that returns a string slice. Rust calls deref again to turn the &String into &str, which matches the hello function’s definition.\n\n### How Deref Coercion Interacts with Mutability\nSimilar to how you use the Deref trait to override the * operator on immutable references, you can use the DerefMut trait to override the * operator on mutable references.\n\nRust does deref coercion when it finds types and trait implementations in three cases:\n- From &T to &U when T: Deref<Target=U>\n- From &mut T to &mut U when T: DerefMut<Target=U>\n- From &mut T to &U when T: Deref<Target=U>\n\n## Running Code on Cleanup with the Drop Trait\nDrop, which lets you customize what happens when a value is about to go out of scope. \n\n```rust\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"my stuff\"),\n    };\n    c.drop(); // not allowed\n    let d = CustomSmartPointer {\n        data: String::from(\"other stuff\"),\n    };\n    println!(\"CustomSmartPointers created.\");\n}\n\n```\n### Dropping a Value Early with std::mem::drop\nstd::mem::drop is in prelude, can use directly\n```rust\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"some data\"),\n    };\n    println!(\"CustomSmartPointer created.\");\n    drop(c); // ok\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n} // c goes out of scope, will occur double drop\n\n```\n\n\n## Rc: the Reference Counted Smart Pointer\nIn the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. \ntype keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.\n\nWe use the `Rc<T>` type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last.\n\nRc<T> is only for use in single-threaded scenarios\n\n### using Rc<T> to share data\n\n![rc](/images/rust/pointers/rc.png)\nimplement use box will not work, as below\n```rust\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a)); // value moved here\n    let c = Cons(4, Box::new(a)); // value used here after move\n}\n```\nuse Rc\n```rust\nenum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&a)); // shalow copy only reference, not data\n    let c = Cons(4, Rc::clone(&a));\n}\n```\n\n\nWe could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case. The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do. The call to Rc::clone only increments the reference count, which doesn’t take much time.\n\n### Cloning an Rc<T> Increases the Reference Count\n```rust\nenum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a));  // 1\n    let b = Cons(3, Rc::clone(&a));\n    println!(\"count after creating b = {}\", Rc::strong_count(&a));  // 2\n    {\n        let c = Cons(4, Rc::clone(&a));\n        println!(\"count after creating c = {}\", Rc::strong_count(&a)); // 3\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(&a));  // 2\n}\n```\nWhat we can’t see in this example is that when b and then a go out of scope at the end of main, the count is then 0, and the Rc<List> is cleaned up completely at that point.\n\n## RefCell<T> and interior mutability pattern\nInterior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules.\nTo mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing.\nWe can use types that use the interior mutability pattern when we can ensure that the borrowing rules will be followed at <strong>runtime</strong>, even though the compiler can’t guarantee that. \nThe unsafe code involved is then wrapped in a safe API, and the outer type is still immutable.\n\n### Enforcing Borrowing Rules at Runtime with RefCell<T>\nUnlike Rc<T>, the RefCell<T> type represents single ownership over the data it holds.\n\nrecall borrowing rules\n- At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.\n- References must always be valid.\nWith references and Box<T>, the borrowing rules’ invariants are enforced at compile time. With RefCell<T>, these invariants are enforced at runtime. \nBecause RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.\n\n### Interior Mutability: A Mutable Borrow to an Immutable Value\n```rust\nfn main() {\n    let x = 5;\n    let y = &mut x; // not allowed. cannot borrow `x` as mutable, as it is not declared as mutable\n}\n```\n\n### A Use Case for Interior Mutability: Mock Objects\n```rust\npub trait Messenger {\n    fn send(&self, msg: &str);\n}\n\npub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n\n```\na problematic usage\n```rust\npub trait Messenger {\n    fn send(&self, msg: &str);\n}\n\npub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n        sent_messages: Vec<String>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: vec![],\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.push(String::from(message)); // not allowed. cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n\n```\nWe can’t modify the MockMessenger to keep track of the messages, because the send method takes an immutable reference to self. We also can’t take the suggestion from the error text to use &mut self instead, because then the signature of send wouldn’t match the signature in the Messenger trait definition\n\nThis is a situation in which interior mutability can help! \n```rust\npub trait Messenger {\n    fn send(&self, msg: &str);\n}\n\npub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell<Vec<String>>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.borrow_mut().push(String::from(message)); // call borrow_mut on the RefCell<Vec<String>> in self.sent_messages to get a mutable reference to the value inside the RefCell<Vec<String>>\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1); //  call borrow on the RefCell<Vec<String>> to get an immutable reference to the vector.\n    }\n}\n```\n\n### Keeping Track of Borrows at Runtime with RefCell<T>\nWhen creating immutable and mutable references, we use the & and &mut syntax, respectively. With RefCell<T>, we use the borrow and borrow_mut methods, which are part of the safe API that belongs to RefCell<T>. **The borrow method returns the smart pointer type Ref<T>, and borrow_mut returns the smart pointer type RefMut<T>**.  Both types implement Deref, so we can treat them like regular references.\n\nThe RefCell<T> keeps track of how many Ref<T> and RefMut<T> smart pointers are currently active.RefCell<T> lets us have many immutable borrows or one mutable borrow at any point in time. If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of RefCell<T> will panic at runtime. \n```rust\nimpl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            let mut one_borrow = self.sent_messages.borrow_mut();\n            let mut two_borrow = self.sent_messages.borrow_mut();\n\n            one_borrow.push(String::from(message));\n            two_borrow.push(String::from(message));\n        }\n    }\n```\nWhen we run the tests for our library, the code in will compile without any errors, but the test will fail\nthread 'main' panicked at 'already borrowed\n\n### Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T>\nA common way to use RefCell<T> is in combination with Rc<T>.  If you have an Rc<T> that holds a RefCell<T>, you can get a value that can have multiple owners and that you can mutate!\n```rust\n#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5)); // We create a value that is an instance of Rc<RefCell<i32>> and store it in a variable named value so we can access it directly later.\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil))); //  Then we create a List in a with a Cons variant that holds value. We need to clone value so both a and value have ownership of the inner 5 value rather than transferring ownership from value to a or having a borrow from value. We wrap the list a in an Rc<T> so when we create lists b and c, they can both refer to a\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10; // After we’ve created the lists in a, b, and c, we add 10 to the value in value. We do this by calling borrow_mut on value, which uses the automatic dereferencing feature to dereference the Rc<T> to the inner RefCell<T> value. The borrow_mut method returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}\n```\n\n**The standard library has other types that provide interior mutability, such as Cell<T>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the Cell<T>. There’s also Mutex<T>, which offers interior mutability that’s safe to use across threads;** \n\n## Reference Cycles Can Leak Memory\nRust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a memory leak).\n\n### Creating a Reference Cycle\n```rust\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>), // The second element in the Cons variant is now RefCell<Rc<List>>, meaning that we want to modify which List value a Cons variant is pointing to. \n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> { // We’re also adding a tail method to make it convenient for us to access the second item if we have a Cons variant.\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {\n    use crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a)))); // his code creates a list in a and a list in b that points to the list in a\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&b); // modifies the list in a to point to b, creating a reference cycle\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!(\"a next item = {:?}\", a.tail());\n} // At the end of main, Rust drops the variable b, which decreases the reference count of the Rc<List> instance from 2 to 1. The memory that Rc<List> has on the heap won’t be dropped at this point, because its reference count is 1, not 0. Then Rust drops a, which decreases the reference count of the a Rc<List> instance from 2 to 1 as well. This instance’s memory can’t be dropped either, because the other Rc<List> instance still refers to it. The memory allocated to the list will remain uncollected forever.\n```\n![cycle-ref](/images/rust/pointers/cycle.ref.png)\n\n### Preventing Reference Cycles: Turning an Rc<T> into a Weak<T>\nSo far, we’ve demonstrated that calling Rc::clone increases the strong_count of an Rc<T> instance, and an Rc<T> instance is only cleaned up if its strong_count is 0. You can also create a weak reference to the value within an Rc<T> instance by calling Rc::downgrade and passing a reference to the Rc<T>. When you call Rc::downgrade, you get a smart pointer of type Weak<T>. Instead of increasing the strong_count in the Rc<T> instance by 1, calling Rc::downgrade increases the weak_count by 1. The Rc<T> type uses weak_count to keep track of how many Weak<T> references exist, similar to strong_count. The difference is the weak_count doesn’t need to be 0 for the Rc<T> instance to be cleaned up.\n\nStrong references are how you can share ownership of an Rc<T> instance. Weak references don’t express an ownership relationship. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.\n\nBecause the value that Weak<T> references might have been dropped, to do anything with the value that a Weak<T> is pointing to, you must make sure the value still exists. Do this by calling the upgrade method on a Weak<T> instance, which will return an Option<Rc<T>>. You’ll get a result of Some if the Rc<T> value has not been dropped yet and a result of None if the Rc<T> value has been dropped. \n\n\n### Creating a Tree Data Structure: a Node with Child Nodes\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>, // To make the child node aware of its parent, we need to add a parent field to our Node struct definition. The trouble is in deciding what the type of parent should be. We know it can’t contain an Rc<T>, because that would create a reference cycle with leaf.parent pointing to branch and branch.children pointing to leaf, which would cause their strong_count values to never be 0.\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade()); // try to get a reference to the parent of leaf by using the upgrade method, we get a None value. \n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]), // We clone the Rc<Node> in leaf and store that in branch, meaning the Node in leaf now has two owners: leaf and branch. \n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch); // use the Rc::downgrade function to create a Weak<Node> reference to branch from the Rc<Node> in branch.\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n   \n}\n```\n\n### Visualizing Changes to strong_count and weak_count\n```rust\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            \"branch strong = {}, weak = {}\",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            \"leaf strong = {}, weak = {}\",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n```","source":"_posts/rust-06-smart-pointer.md","raw":"---\ntitle: rust smart pointer\ndate: 2022-10-30 11:00:38\ntags: [rust]\n---\n\n## Overview\nThe most common kind of pointer in Rust is a reference (borrow but not own)\nSmart pointers, on the other hand, are data structures that not only act like a pointer but also have additional metadata and capabilities.\nreferences are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.\n\n### smart pointers example\n- String\n- Vec<T>\nBoth these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with String ensuring its data will always be valid UTF-8).\n\n### Deref & Drop\nSmart pointers are usually implemented using structs. The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the `Deref` and `Drop` traits.\n- The Deref trait allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers. \n- The Drop trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.\n\n### the most common smart pointers in the standard library:\n- `Box<T>` for allocating values on the heap\n- `Rc<T>`, a reference counting type that enables multiple ownership\n- `Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that enforces the borrowing rules at runtime instead of compile time\n\n## Box<T>\n### when to use\n- When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size. (such as cons)\n- When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so\n- When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type\n\n\n### enabling recursive types with Box\nAt compile time, Rust needs to know how much space a type takes up\nOne type whose size can’t be known at compile time is a recursive type (cons list), use Box, which only contains a memory address\n\n```rust\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil))); // not allowed, infinite size\n}\n```\n\nuse Box\n```rust\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n```\n\n## Treating Smart Pointers Like Regular References with the Deref Trait\nImplementing the Deref trait allows you to customize the behavior of the dereference operator, `*`\nBy implementing Deref in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.\n\n### Defining Our Own Smart Pointer\n```rust\nuse std::ops::Deref;\n\nstruct MyBox<T>(T);  // The MyBox type is a tuple struct with one element of type T\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n```\n- We fill in the body of the deref method with &self.0 so deref returns a reference to the value we want to access with the * operator. \n- behind the scenes Rust actually ran this code: <code>*(y.deref())</code>. Rust substitutes the * operator with a call to the deref method\n- The reason the deref method returns a reference to a value, and that the plain dereference outside the parentheses in *(y.deref()) is still necessary, is the ownership system. If the deref method returned the value directly instead of a reference to the value, the value would be moved out of self. We don’t want to take ownership of the inner value inside MyBox<T> in this case or in most cases where we use the dereference operator.\n\n### Implicit Deref Coercions with Functions and Methods\nDeref coercion is a convenience that Rust performs on arguments to functions and methods. \nDeref coercion works only on types that implement the Deref trait. Deref coercion converts a reference to such a type into a reference to another type. For example, deref coercion can convert &String to &str because String implements the Deref trait such that it returns &str\nA sequence of calls to the deref method converts the type we provided into the type the parameter needs.\n\n```rust\nfn hello(name: &str) {\n    println!(\"Hello, {}!\", name);\n}\n\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(\"rust\");  // ok\n    hello(&m);      // also ok\n    hello(&(*m)[..]); // without deref coercion. The (*m) dereferences the MyBox<String> into a String. Then the & and [..] take a string slice of the String that is equal to the whole string to match the signature of hello\n}\n```\nHere we’re calling the hello function with the argument &m, which is a reference to a MyBox<String> value. Because we implemented the Deref trait on MyBox<T>, Rust can turn &MyBox<String> into &String by calling deref. The standard library provides an implementation of Deref on String that returns a string slice. Rust calls deref again to turn the &String into &str, which matches the hello function’s definition.\n\n### How Deref Coercion Interacts with Mutability\nSimilar to how you use the Deref trait to override the * operator on immutable references, you can use the DerefMut trait to override the * operator on mutable references.\n\nRust does deref coercion when it finds types and trait implementations in three cases:\n- From &T to &U when T: Deref<Target=U>\n- From &mut T to &mut U when T: DerefMut<Target=U>\n- From &mut T to &U when T: Deref<Target=U>\n\n## Running Code on Cleanup with the Drop Trait\nDrop, which lets you customize what happens when a value is about to go out of scope. \n\n```rust\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"my stuff\"),\n    };\n    c.drop(); // not allowed\n    let d = CustomSmartPointer {\n        data: String::from(\"other stuff\"),\n    };\n    println!(\"CustomSmartPointers created.\");\n}\n\n```\n### Dropping a Value Early with std::mem::drop\nstd::mem::drop is in prelude, can use directly\n```rust\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"some data\"),\n    };\n    println!(\"CustomSmartPointer created.\");\n    drop(c); // ok\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n} // c goes out of scope, will occur double drop\n\n```\n\n\n## Rc: the Reference Counted Smart Pointer\nIn the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. \ntype keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.\n\nWe use the `Rc<T>` type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last.\n\nRc<T> is only for use in single-threaded scenarios\n\n### using Rc<T> to share data\n\n![rc](/images/rust/pointers/rc.png)\nimplement use box will not work, as below\n```rust\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a)); // value moved here\n    let c = Cons(4, Box::new(a)); // value used here after move\n}\n```\nuse Rc\n```rust\nenum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&a)); // shalow copy only reference, not data\n    let c = Cons(4, Rc::clone(&a));\n}\n```\n\n\nWe could have called a.clone() rather than Rc::clone(&a), but Rust’s convention is to use Rc::clone in this case. The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do. The call to Rc::clone only increments the reference count, which doesn’t take much time.\n\n### Cloning an Rc<T> Increases the Reference Count\n```rust\nenum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&a));  // 1\n    let b = Cons(3, Rc::clone(&a));\n    println!(\"count after creating b = {}\", Rc::strong_count(&a));  // 2\n    {\n        let c = Cons(4, Rc::clone(&a));\n        println!(\"count after creating c = {}\", Rc::strong_count(&a)); // 3\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(&a));  // 2\n}\n```\nWhat we can’t see in this example is that when b and then a go out of scope at the end of main, the count is then 0, and the Rc<List> is cleaned up completely at that point.\n\n## RefCell<T> and interior mutability pattern\nInterior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules.\nTo mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing.\nWe can use types that use the interior mutability pattern when we can ensure that the borrowing rules will be followed at <strong>runtime</strong>, even though the compiler can’t guarantee that. \nThe unsafe code involved is then wrapped in a safe API, and the outer type is still immutable.\n\n### Enforcing Borrowing Rules at Runtime with RefCell<T>\nUnlike Rc<T>, the RefCell<T> type represents single ownership over the data it holds.\n\nrecall borrowing rules\n- At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.\n- References must always be valid.\nWith references and Box<T>, the borrowing rules’ invariants are enforced at compile time. With RefCell<T>, these invariants are enforced at runtime. \nBecause RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.\n\n### Interior Mutability: A Mutable Borrow to an Immutable Value\n```rust\nfn main() {\n    let x = 5;\n    let y = &mut x; // not allowed. cannot borrow `x` as mutable, as it is not declared as mutable\n}\n```\n\n### A Use Case for Interior Mutability: Mock Objects\n```rust\npub trait Messenger {\n    fn send(&self, msg: &str);\n}\n\npub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n\n```\na problematic usage\n```rust\npub trait Messenger {\n    fn send(&self, msg: &str);\n}\n\npub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n        sent_messages: Vec<String>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: vec![],\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.push(String::from(message)); // not allowed. cannot borrow `self.sent_messages` as mutable, as it is behind a `&` reference\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n\n```\nWe can’t modify the MockMessenger to keep track of the messages, because the send method takes an immutable reference to self. We also can’t take the suggestion from the error text to use &mut self instead, because then the signature of send wouldn’t match the signature in the Messenger trait definition\n\nThis is a situation in which interior mutability can help! \n```rust\npub trait Messenger {\n    fn send(&self, msg: &str);\n}\n\npub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &T, max: usize) -> LimitTracker<T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell<Vec<String>>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.borrow_mut().push(String::from(message)); // call borrow_mut on the RefCell<Vec<String>> in self.sent_messages to get a mutable reference to the value inside the RefCell<Vec<String>>\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1); //  call borrow on the RefCell<Vec<String>> to get an immutable reference to the vector.\n    }\n}\n```\n\n### Keeping Track of Borrows at Runtime with RefCell<T>\nWhen creating immutable and mutable references, we use the & and &mut syntax, respectively. With RefCell<T>, we use the borrow and borrow_mut methods, which are part of the safe API that belongs to RefCell<T>. **The borrow method returns the smart pointer type Ref<T>, and borrow_mut returns the smart pointer type RefMut<T>**.  Both types implement Deref, so we can treat them like regular references.\n\nThe RefCell<T> keeps track of how many Ref<T> and RefMut<T> smart pointers are currently active.RefCell<T> lets us have many immutable borrows or one mutable borrow at any point in time. If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of RefCell<T> will panic at runtime. \n```rust\nimpl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            let mut one_borrow = self.sent_messages.borrow_mut();\n            let mut two_borrow = self.sent_messages.borrow_mut();\n\n            one_borrow.push(String::from(message));\n            two_borrow.push(String::from(message));\n        }\n    }\n```\nWhen we run the tests for our library, the code in will compile without any errors, but the test will fail\nthread 'main' panicked at 'already borrowed\n\n### Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T>\nA common way to use RefCell<T> is in combination with Rc<T>.  If you have an Rc<T> that holds a RefCell<T>, you can get a value that can have multiple owners and that you can mutate!\n```rust\n#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5)); // We create a value that is an instance of Rc<RefCell<i32>> and store it in a variable named value so we can access it directly later.\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil))); //  Then we create a List in a with a Cons variant that holds value. We need to clone value so both a and value have ownership of the inner 5 value rather than transferring ownership from value to a or having a borrow from value. We wrap the list a in an Rc<T> so when we create lists b and c, they can both refer to a\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    *value.borrow_mut() += 10; // After we’ve created the lists in a, b, and c, we add 10 to the value in value. We do this by calling borrow_mut on value, which uses the automatic dereferencing feature to dereference the Rc<T> to the inner RefCell<T> value. The borrow_mut method returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}\n```\n\n**The standard library has other types that provide interior mutability, such as Cell<T>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the Cell<T>. There’s also Mutex<T>, which offers interior mutability that’s safe to use across threads;** \n\n## Reference Cycles Can Leak Memory\nRust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a memory leak).\n\n### Creating a Reference Cycle\n```rust\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>), // The second element in the Cons variant is now RefCell<Rc<List>>, meaning that we want to modify which List value a Cons variant is pointing to. \n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> { // We’re also adding a tail method to make it convenient for us to access the second item if we have a Cons variant.\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {\n    use crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a)))); // his code creates a list in a and a list in b that points to the list in a\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&b); // modifies the list in a to point to b, creating a reference cycle\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!(\"a next item = {:?}\", a.tail());\n} // At the end of main, Rust drops the variable b, which decreases the reference count of the Rc<List> instance from 2 to 1. The memory that Rc<List> has on the heap won’t be dropped at this point, because its reference count is 1, not 0. Then Rust drops a, which decreases the reference count of the a Rc<List> instance from 2 to 1 as well. This instance’s memory can’t be dropped either, because the other Rc<List> instance still refers to it. The memory allocated to the list will remain uncollected forever.\n```\n![cycle-ref](/images/rust/pointers/cycle.ref.png)\n\n### Preventing Reference Cycles: Turning an Rc<T> into a Weak<T>\nSo far, we’ve demonstrated that calling Rc::clone increases the strong_count of an Rc<T> instance, and an Rc<T> instance is only cleaned up if its strong_count is 0. You can also create a weak reference to the value within an Rc<T> instance by calling Rc::downgrade and passing a reference to the Rc<T>. When you call Rc::downgrade, you get a smart pointer of type Weak<T>. Instead of increasing the strong_count in the Rc<T> instance by 1, calling Rc::downgrade increases the weak_count by 1. The Rc<T> type uses weak_count to keep track of how many Weak<T> references exist, similar to strong_count. The difference is the weak_count doesn’t need to be 0 for the Rc<T> instance to be cleaned up.\n\nStrong references are how you can share ownership of an Rc<T> instance. Weak references don’t express an ownership relationship. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.\n\nBecause the value that Weak<T> references might have been dropped, to do anything with the value that a Weak<T> is pointing to, you must make sure the value still exists. Do this by calling the upgrade method on a Weak<T> instance, which will return an Option<Rc<T>>. You’ll get a result of Some if the Rc<T> value has not been dropped yet and a result of None if the Rc<T> value has been dropped. \n\n\n### Creating a Tree Data Structure: a Node with Child Nodes\n```rust\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>, // To make the child node aware of its parent, we need to add a parent field to our Node struct definition. The trouble is in deciding what the type of parent should be. We know it can’t contain an Rc<T>, because that would create a reference cycle with leaf.parent pointing to branch and branch.children pointing to leaf, which would cause their strong_count values to never be 0.\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade()); // try to get a reference to the parent of leaf by using the upgrade method, we get a None value. \n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]), // We clone the Rc<Node> in leaf and store that in branch, meaning the Node in leaf now has two owners: leaf and branch. \n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch); // use the Rc::downgrade function to create a Weak<Node> reference to branch from the Rc<Node> in branch.\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n   \n}\n```\n\n### Visualizing Changes to strong_count and weak_count\n```rust\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            \"branch strong = {}, weak = {}\",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            \"leaf strong = {}, weak = {}\",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n```","slug":"rust-06-smart-pointer","published":1,"updated":"2023-05-03T07:31:43.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tp000n6usj2gidb2ne","content":"<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>The most common kind of pointer in Rust is a reference (borrow but not own)<br>Smart pointers, on the other hand, are data structures that not only act like a pointer but also have additional metadata and capabilities.<br>references are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.</p>\n<h3 id=\"smart-pointers-example\"><a href=\"#smart-pointers-example\" class=\"headerlink\" title=\"smart pointers example\"></a>smart pointers example</h3><ul>\n<li>String</li>\n<li>Vec<T><br>Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with String ensuring its data will always be valid UTF-8).</li>\n</ul>\n<h3 id=\"Deref-amp-Drop\"><a href=\"#Deref-amp-Drop\" class=\"headerlink\" title=\"Deref &amp; Drop\"></a>Deref &amp; Drop</h3><p>Smart pointers are usually implemented using structs. The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.</p>\n<ul>\n<li>The Deref trait allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers. </li>\n<li>The Drop trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>\n</ul>\n<h3 id=\"the-most-common-smart-pointers-in-the-standard-library\"><a href=\"#the-most-common-smart-pointers-in-the-standard-library\" class=\"headerlink\" title=\"the most common smart pointers in the standard library:\"></a>the most common smart pointers in the standard library:</h3><ul>\n<li><code>Box&lt;T&gt;</code> for allocating values on the heap</li>\n<li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li>\n<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces the borrowing rules at runtime instead of compile time</li>\n</ul>\n<h2 id=\"Box\"><a href=\"#Box\" class=\"headerlink\" title=\"Box\"></a>Box<T></h2><h3 id=\"when-to-use\"><a href=\"#when-to-use\" class=\"headerlink\" title=\"when to use\"></a>when to use</h3><ul>\n<li>When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size. (such as cons)</li>\n<li>When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so</li>\n<li>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type</li>\n</ul>\n<h3 id=\"enabling-recursive-types-with-Box\"><a href=\"#enabling-recursive-types-with-Box\" class=\"headerlink\" title=\"enabling recursive types with Box\"></a>enabling recursive types with Box</h3><p>At compile time, Rust needs to know how much space a type takes up<br>One type whose size can’t be known at compile time is a recursive type (cons list), use Box, which only contains a memory address</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, List),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">list</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">1</span>, <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">2</span>, <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, Nil))); <span class=\"comment\">// not allowed, infinite size</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>use Box</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, <span class=\"type\">Box</span>&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">list</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">1</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">2</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(Nil))))));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait\"><a href=\"#Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait\" class=\"headerlink\" title=\"Treating Smart Pointers Like Regular References with the Deref Trait\"></a>Treating Smart Pointers Like Regular References with the Deref Trait</h2><p>Implementing the Deref trait allows you to customize the behavior of the dereference operator, <code>*</code><br>By implementing Deref in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>\n<h3 id=\"Defining-Our-Own-Smart-Pointer\"><a href=\"#Defining-Our-Own-Smart-Pointer\" class=\"headerlink\" title=\"Defining Our Own Smart Pointer\"></a>Defining Our Own Smart Pointer</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::ops::Deref;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyBox</span>&lt;T&gt;(T);  <span class=\"comment\">// The MyBox type is a tuple struct with one element of type T</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(x: T) <span class=\"punctuation\">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">MyBox</span>(x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; Deref <span class=\"keyword\">for</span> <span class=\"title class_\">MyBox</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> <span class=\"title class_\">Target</span> = T;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">deref</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"keyword\">Self</span>::Target &#123;</span><br><span class=\"line\">        &amp;<span class=\"keyword\">self</span>.<span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = MyBox::<span class=\"title function_ invoke__\">new</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(<span class=\"number\">5</span>, x);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(<span class=\"number\">5</span>, *y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>We fill in the body of the deref method with &amp;self.0 so deref returns a reference to the value we want to access with the * operator. </li>\n<li>behind the scenes Rust actually ran this code: <code>*(y.deref())</code>. Rust substitutes the * operator with a call to the deref method</li>\n<li>The reason the deref method returns a reference to a value, and that the plain dereference outside the parentheses in *(y.deref()) is still necessary, is the ownership system. If the deref method returned the value directly instead of a reference to the value, the value would be moved out of self. We don’t want to take ownership of the inner value inside MyBox<T> in this case or in most cases where we use the dereference operator.</li>\n</ul>\n<h3 id=\"Implicit-Deref-Coercions-with-Functions-and-Methods\"><a href=\"#Implicit-Deref-Coercions-with-Functions-and-Methods\" class=\"headerlink\" title=\"Implicit Deref Coercions with Functions and Methods\"></a>Implicit Deref Coercions with Functions and Methods</h3><p>Deref coercion is a convenience that Rust performs on arguments to functions and methods.<br>Deref coercion works only on types that implement the Deref trait. Deref coercion converts a reference to such a type into a reference to another type. For example, deref coercion can convert &amp;String to &amp;str because String implements the Deref trait such that it returns &amp;str<br>A sequence of calls to the deref method converts the type we provided into the type the parameter needs.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">hello</span>(name: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">m</span> = MyBox::<span class=\"title function_ invoke__\">new</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Rust&quot;</span>));</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">hello</span>(<span class=\"string\">&quot;rust&quot;</span>);  <span class=\"comment\">// ok</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">hello</span>(&amp;m);      <span class=\"comment\">// also ok</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">hello</span>(&amp;(*m)[..]); <span class=\"comment\">// without deref coercion. The (*m) dereferences the MyBox&lt;String&gt; into a String. Then the &amp; and [..] take a string slice of the String that is equal to the whole string to match the signature of hello</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Here we’re calling the hello function with the argument &amp;m, which is a reference to a MyBox<String> value. Because we implemented the Deref trait on MyBox<T>, Rust can turn &amp;MyBox<String> into &amp;String by calling deref. The standard library provides an implementation of Deref on String that returns a string slice. Rust calls deref again to turn the &amp;String into &amp;str, which matches the hello function’s definition.</p>\n<h3 id=\"How-Deref-Coercion-Interacts-with-Mutability\"><a href=\"#How-Deref-Coercion-Interacts-with-Mutability\" class=\"headerlink\" title=\"How Deref Coercion Interacts with Mutability\"></a>How Deref Coercion Interacts with Mutability</h3><p>Similar to how you use the Deref trait to override the * operator on immutable references, you can use the DerefMut trait to override the * operator on mutable references.</p>\n<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>\n<ul>\n<li>From &amp;T to &amp;U when T: Deref&lt;Target&#x3D;U&gt;</li>\n<li>From &amp;mut T to &amp;mut U when T: DerefMut&lt;Target&#x3D;U&gt;</li>\n<li>From &amp;mut T to &amp;U when T: Deref&lt;Target&#x3D;U&gt;</li>\n</ul>\n<h2 id=\"Running-Code-on-Cleanup-with-the-Drop-Trait\"><a href=\"#Running-Code-on-Cleanup-with-the-Drop-Trait\" class=\"headerlink\" title=\"Running Code on Cleanup with the Drop Trait\"></a>Running Code on Cleanup with the Drop Trait</h2><p>Drop, which lets you customize what happens when a value is about to go out of scope. </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    data: <span class=\"type\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Drop</span> <span class=\"keyword\">for</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">drop</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;</span>, <span class=\"keyword\">self</span>.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = CustomSmartPointer &#123;</span><br><span class=\"line\">        data: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;my stuff&quot;</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    c.<span class=\"title function_ invoke__\">drop</span>(); <span class=\"comment\">// not allowed</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">d</span> = CustomSmartPointer &#123;</span><br><span class=\"line\">        data: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;other stuff&quot;</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;CustomSmartPointers created.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dropping-a-Value-Early-with-std-mem-drop\"><a href=\"#Dropping-a-Value-Early-with-std-mem-drop\" class=\"headerlink\" title=\"Dropping a Value Early with std::mem::drop\"></a>Dropping a Value Early with std::mem::drop</h3><p>std::mem::drop is in prelude, can use directly</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    data: <span class=\"type\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Drop</span> <span class=\"keyword\">for</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">drop</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;</span>, <span class=\"keyword\">self</span>.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = CustomSmartPointer &#123;</span><br><span class=\"line\">        data: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;some data&quot;</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;CustomSmartPointer created.&quot;</span>);</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">drop</span>(c); <span class=\"comment\">// ok</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;CustomSmartPointer dropped before the end of main.&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"comment\">// c goes out of scope, will occur double drop</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Rc-the-Reference-Counted-Smart-Pointer\"><a href=\"#Rc-the-Reference-Counted-Smart-Pointer\" class=\"headerlink\" title=\"Rc: the Reference Counted Smart Pointer\"></a>Rc: the Reference Counted Smart Pointer</h2><p>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners.<br>type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>\n<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last.</p>\n<p>Rc<T> is only for use in single-threaded scenarios</p>\n<h3 id=\"using-Rc-to-share-data\"><a href=\"#using-Rc-to-share-data\" class=\"headerlink\" title=\"using Rc to share data\"></a>using Rc<T> to share data</h3><p><img src=\"/images/rust/pointers/rc.png\" alt=\"rc\"><br>implement use box will not work, as below</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, <span class=\"type\">Box</span>&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">5</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">10</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(Nil))));</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(a)); <span class=\"comment\">// value moved here</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">4</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(a)); <span class=\"comment\">// value used here after move</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>use Rc</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, Rc&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">5</span>, Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">10</span>, Rc::<span class=\"title function_ invoke__\">new</span>(Nil)))));</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a)); <span class=\"comment\">// shalow copy only reference, not data</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">4</span>, Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>We could have called a.clone() rather than Rc::clone(&amp;a), but Rust’s convention is to use Rc::clone in this case. The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do. The call to Rc::clone only increments the reference count, which doesn’t take much time.</p>\n<h3 id=\"Cloning-an-Rc-Increases-the-Reference-Count\"><a href=\"#Cloning-an-Rc-Increases-the-Reference-Count\" class=\"headerlink\" title=\"Cloning an Rc Increases the Reference Count\"></a>Cloning an Rc<T> Increases the Reference Count</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, Rc&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">5</span>, Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">10</span>, Rc::<span class=\"title function_ invoke__\">new</span>(Nil)))));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));  <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));  <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">4</span>, Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a)); <span class=\"comment\">// 3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));  <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>What we can’t see in this example is that when b and then a go out of scope at the end of main, the count is then 0, and the Rc<List> is cleaned up completely at that point.</p>\n<h2 id=\"RefCell-and-interior-mutability-pattern\"><a href=\"#RefCell-and-interior-mutability-pattern\" class=\"headerlink\" title=\"RefCell and interior mutability pattern\"></a>RefCell<T> and interior mutability pattern</h2><p>Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules.<br>To mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing.<br>We can use types that use the interior mutability pattern when we can ensure that the borrowing rules will be followed at <strong>runtime</strong>, even though the compiler can’t guarantee that.<br>The unsafe code involved is then wrapped in a safe API, and the outer type is still immutable.</p>\n<h3 id=\"Enforcing-Borrowing-Rules-at-Runtime-with-RefCell\"><a href=\"#Enforcing-Borrowing-Rules-at-Runtime-with-RefCell\" class=\"headerlink\" title=\"Enforcing Borrowing Rules at Runtime with RefCell\"></a>Enforcing Borrowing Rules at Runtime with RefCell<T></h3><p>Unlike Rc<T>, the RefCell<T> type represents single ownership over the data it holds.</p>\n<p>recall borrowing rules</p>\n<ul>\n<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>\n<li>References must always be valid.<br>With references and Box<T>, the borrowing rules’ invariants are enforced at compile time. With RefCell<T>, these invariants are enforced at runtime.<br>Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.</li>\n</ul>\n<h3 id=\"Interior-Mutability-A-Mutable-Borrow-to-an-Immutable-Value\"><a href=\"#Interior-Mutability-A-Mutable-Borrow-to-an-Immutable-Value\" class=\"headerlink\" title=\"Interior Mutability: A Mutable Borrow to an Immutable Value\"></a>Interior Mutability: A Mutable Borrow to an Immutable Value</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = &amp;<span class=\"keyword\">mut</span> x; <span class=\"comment\">// not allowed. cannot borrow `x` as mutable, as it is not declared as mutable</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"A-Use-Case-for-Interior-Mutability-Mock-Objects\"><a href=\"#A-Use-Case-for-Interior-Mutability-Mock-Objects\" class=\"headerlink\" title=\"A Use Case for Interior Mutability: Mock Objects\"></a>A Use Case for Interior Mutability: Mock Objects</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">Messenger</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, msg: &amp;<span class=\"type\">str</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LimitTracker</span>&lt;<span class=\"symbol\">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class=\"line\">    messenger: &amp;<span class=\"symbol\">&#x27;a</span> T,</span><br><span class=\"line\">    value: <span class=\"type\">usize</span>,</span><br><span class=\"line\">    max: <span class=\"type\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;<span class=\"symbol\">&#x27;a</span>, T&gt; LimitTracker&lt;<span class=\"symbol\">&#x27;a</span>, T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: Messenger,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(messenger: &amp;T, max: <span class=\"type\">usize</span>) <span class=\"punctuation\">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class=\"line\">        LimitTracker &#123;</span><br><span class=\"line\">            messenger,</span><br><span class=\"line\">            value: <span class=\"number\">0</span>,</span><br><span class=\"line\">            max,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">set_value</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, value: <span class=\"type\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">percentage_of_max</span> = <span class=\"keyword\">self</span>.value <span class=\"keyword\">as</span> <span class=\"type\">f64</span> / <span class=\"keyword\">self</span>.max <span class=\"keyword\">as</span> <span class=\"type\">f64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">1.0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger.<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.9</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.75</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>a problematic usage</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">Messenger</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, msg: &amp;<span class=\"type\">str</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LimitTracker</span>&lt;<span class=\"symbol\">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class=\"line\">    messenger: &amp;<span class=\"symbol\">&#x27;a</span> T,</span><br><span class=\"line\">    value: <span class=\"type\">usize</span>,</span><br><span class=\"line\">    max: <span class=\"type\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;<span class=\"symbol\">&#x27;a</span>, T&gt; LimitTracker&lt;<span class=\"symbol\">&#x27;a</span>, T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: Messenger,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(messenger: &amp;T, max: <span class=\"type\">usize</span>) <span class=\"punctuation\">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class=\"line\">        LimitTracker &#123;</span><br><span class=\"line\">            messenger,</span><br><span class=\"line\">            value: <span class=\"number\">0</span>,</span><br><span class=\"line\">            max,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">set_value</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, value: <span class=\"type\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">percentage_of_max</span> = <span class=\"keyword\">self</span>.value <span class=\"keyword\">as</span> <span class=\"type\">f64</span> / <span class=\"keyword\">self</span>.max <span class=\"keyword\">as</span> <span class=\"type\">f64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">1.0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger.<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.9</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.75</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[cfg(test)]</span></span><br><span class=\"line\"><span class=\"keyword\">mod</span> tests &#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> super::*;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        sent_messages: <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>() <span class=\"punctuation\">-&gt;</span> MockMessenger &#123;</span><br><span class=\"line\">            MockMessenger &#123;</span><br><span class=\"line\">                sent_messages: <span class=\"built_in\">vec!</span>[],</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">Messenger</span> <span class=\"keyword\">for</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, message: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.sent_messages.<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(message)); <span class=\"comment\">// not allowed. cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[test]</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">mock_messenger</span> = MockMessenger::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">limit_tracker</span> = LimitTracker::<span class=\"title function_ invoke__\">new</span>(&amp;mock_messenger, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        limit_tracker.<span class=\"title function_ invoke__\">set_value</span>(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">assert_eq!</span>(mock_messenger.sent_messages.<span class=\"title function_ invoke__\">len</span>(), <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>We can’t modify the MockMessenger to keep track of the messages, because the send method takes an immutable reference to self. We also can’t take the suggestion from the error text to use &amp;mut self instead, because then the signature of send wouldn’t match the signature in the Messenger trait definition</p>\n<p>This is a situation in which interior mutability can help! </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">Messenger</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, msg: &amp;<span class=\"type\">str</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LimitTracker</span>&lt;<span class=\"symbol\">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class=\"line\">    messenger: &amp;<span class=\"symbol\">&#x27;a</span> T,</span><br><span class=\"line\">    value: <span class=\"type\">usize</span>,</span><br><span class=\"line\">    max: <span class=\"type\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;<span class=\"symbol\">&#x27;a</span>, T&gt; LimitTracker&lt;<span class=\"symbol\">&#x27;a</span>, T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: Messenger,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(messenger: &amp;T, max: <span class=\"type\">usize</span>) <span class=\"punctuation\">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class=\"line\">        LimitTracker &#123;</span><br><span class=\"line\">            messenger,</span><br><span class=\"line\">            value: <span class=\"number\">0</span>,</span><br><span class=\"line\">            max,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">set_value</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, value: <span class=\"type\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">percentage_of_max</span> = <span class=\"keyword\">self</span>.value <span class=\"keyword\">as</span> <span class=\"type\">f64</span> / <span class=\"keyword\">self</span>.max <span class=\"keyword\">as</span> <span class=\"type\">f64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">1.0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger.<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.9</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.75</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[cfg(test)]</span></span><br><span class=\"line\"><span class=\"keyword\">mod</span> tests &#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> super::*;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        sent_messages: RefCell&lt;<span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>() <span class=\"punctuation\">-&gt;</span> MockMessenger &#123;</span><br><span class=\"line\">            MockMessenger &#123;</span><br><span class=\"line\">                sent_messages: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[]),</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">Messenger</span> <span class=\"keyword\">for</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, message: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.sent_messages.<span class=\"title function_ invoke__\">borrow_mut</span>().<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(message)); <span class=\"comment\">// call borrow_mut on the RefCell&lt;Vec&lt;String&gt;&gt; in self.sent_messages to get a mutable reference to the value inside the RefCell&lt;Vec&lt;String&gt;&gt;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[test]</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// --snip--</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">mock_messenger</span> = MockMessenger::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">limit_tracker</span> = LimitTracker::<span class=\"title function_ invoke__\">new</span>(&amp;mock_messenger, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        limit_tracker.<span class=\"title function_ invoke__\">set_value</span>(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">assert_eq!</span>(mock_messenger.sent_messages.<span class=\"title function_ invoke__\">borrow</span>().<span class=\"title function_ invoke__\">len</span>(), <span class=\"number\">1</span>); <span class=\"comment\">//  call borrow on the RefCell&lt;Vec&lt;String&gt;&gt; to get an immutable reference to the vector.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Keeping-Track-of-Borrows-at-Runtime-with-RefCell\"><a href=\"#Keeping-Track-of-Borrows-at-Runtime-with-RefCell\" class=\"headerlink\" title=\"Keeping Track of Borrows at Runtime with RefCell\"></a>Keeping Track of Borrows at Runtime with RefCell<T></h3><p>When creating immutable and mutable references, we use the &amp; and &amp;mut syntax, respectively. With RefCell<T>, we use the borrow and borrow_mut methods, which are part of the safe API that belongs to RefCell<T>. <strong>The borrow method returns the smart pointer type Ref<T>, and borrow_mut returns the smart pointer type RefMut<T></strong>.  Both types implement Deref, so we can treat them like regular references.</p>\n<p>The RefCell<T> keeps track of how many Ref<T> and RefMut<T> smart pointers are currently active.RefCell<T> lets us have many immutable borrows or one mutable borrow at any point in time. If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of RefCell<T> will panic at runtime. </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Messenger</span> <span class=\"keyword\">for</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, message: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">one_borrow</span> = <span class=\"keyword\">self</span>.sent_messages.<span class=\"title function_ invoke__\">borrow_mut</span>();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">two_borrow</span> = <span class=\"keyword\">self</span>.sent_messages.<span class=\"title function_ invoke__\">borrow_mut</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            one_borrow.<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(message));</span><br><span class=\"line\">            two_borrow.<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(message));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>When we run the tests for our library, the code in will compile without any errors, but the test will fail<br>thread ‘main’ panicked at ‘already borrowed</p>\n<h3 id=\"Having-Multiple-Owners-of-Mutable-Data-by-Combining-Rc-and-RefCell\"><a href=\"#Having-Multiple-Owners-of-Mutable-Data-by-Combining-Rc-and-RefCell\" class=\"headerlink\" title=\"Having Multiple Owners of Mutable Data by Combining Rc and RefCell\"></a>Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T></h3><p>A common way to use RefCell<T> is in combination with Rc<T>.  If you have an Rc<T> that holds a RefCell<T>, you can get a value that can have multiple owners and that you can mutate!</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(Rc&lt;RefCell&lt;<span class=\"type\">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">value</span> = Rc::<span class=\"title function_ invoke__\">new</span>(RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">5</span>)); <span class=\"comment\">// We create a value that is an instance of Rc&lt;RefCell&lt;i32&gt;&gt; and store it in a variable named value so we can access it directly later.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;value), Rc::<span class=\"title function_ invoke__\">new</span>(Nil))); <span class=\"comment\">//  Then we create a List in a with a Cons variant that holds value. We need to clone value so both a and value have ownership of the inner 5 value rather than transferring ownership from value to a or having a borrow from value. We wrap the list a in an Rc&lt;T&gt; so when we create lists b and c, they can both refer to a</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">Cons</span>(Rc::<span class=\"title function_ invoke__\">new</span>(RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">3</span>)), Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">Cons</span>(Rc::<span class=\"title function_ invoke__\">new</span>(RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">4</span>)), Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\"></span><br><span class=\"line\">    *value.<span class=\"title function_ invoke__\">borrow_mut</span>() += <span class=\"number\">10</span>; <span class=\"comment\">// After we’ve created the lists in a, b, and c, we add 10 to the value in value. We do this by calling borrow_mut on value, which uses the automatic dereferencing feature to dereference the Rc&lt;T&gt; to the inner RefCell&lt;T&gt; value. The borrow_mut method returns a RefMut&lt;T&gt; smart pointer, and we use the dereference operator on it and change the inner value.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a after = &#123;:?&#125;&quot;</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;b after = &#123;:?&#125;&quot;</span>, b);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;c after = &#123;:?&#125;&quot;</span>, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>The standard library has other types that provide interior mutability, such as Cell<T>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the Cell<T>. There’s also Mutex<T>, which offers interior mutability that’s safe to use across threads;</strong> </p>\n<h2 id=\"Reference-Cycles-Can-Leak-Memory\"><a href=\"#Reference-Cycles-Can-Leak-Memory\" class=\"headerlink\" title=\"Reference Cycles Can Leak Memory\"></a>Reference Cycles Can Leak Memory</h2><p>Rust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a memory leak).</p>\n<h3 id=\"Creating-a-Reference-Cycle\"><a href=\"#Creating-a-Reference-Cycle\" class=\"headerlink\" title=\"Creating a Reference Cycle\"></a>Creating a Reference Cycle</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;), <span class=\"comment\">// The second element in the Cons variant is now RefCell&lt;Rc&lt;List&gt;&gt;, meaning that we want to modify which List value a Cons variant is pointing to. </span></span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">tail</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123; <span class=\"comment\">// We’re also adding a tail method to make it convenient for us to access the second item if we have a Cons variant.</span></span><br><span class=\"line\">        <span class=\"keyword\">match</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_ invoke__\">Cons</span>(_, item) =&gt; <span class=\"title function_ invoke__\">Some</span>(item),</span><br><span class=\"line\">            Nil =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">tail</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_ invoke__\">Cons</span>(_, item) =&gt; <span class=\"title function_ invoke__\">Some</span>(item),</span><br><span class=\"line\">            Nil =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">5</span>, RefCell::<span class=\"title function_ invoke__\">new</span>(Rc::<span class=\"title function_ invoke__\">new</span>(Nil))));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a initial rc count = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a next item = &#123;:?&#125;&quot;</span>, a.<span class=\"title function_ invoke__\">tail</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">10</span>, RefCell::<span class=\"title function_ invoke__\">new</span>(Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a)))); <span class=\"comment\">// his code creates a list in a and a list in b that points to the list in a</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a rc count after b creation = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;b initial rc count = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;b));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;b next item = &#123;:?&#125;&quot;</span>, b.<span class=\"title function_ invoke__\">tail</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"variable\">Some</span>(link) = a.<span class=\"title function_ invoke__\">tail</span>() &#123;</span><br><span class=\"line\">        *link.<span class=\"title function_ invoke__\">borrow_mut</span>() = Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;b); <span class=\"comment\">// modifies the list in a to point to b, creating a reference cycle</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;b rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;b));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Uncomment the next line to see that we have a cycle;</span></span><br><span class=\"line\">    <span class=\"comment\">// it will overflow the stack</span></span><br><span class=\"line\">    <span class=\"comment\">// println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// At the end of main, Rust drops the variable b, which decreases the reference count of the Rc&lt;List&gt; instance from 2 to 1. The memory that Rc&lt;List&gt; has on the heap won’t be dropped at this point, because its reference count is 1, not 0. Then Rust drops a, which decreases the reference count of the a Rc&lt;List&gt; instance from 2 to 1 as well. This instance’s memory can’t be dropped either, because the other Rc&lt;List&gt; instance still refers to it. The memory allocated to the list will remain uncollected forever.</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/rust/pointers/cycle.ref.png\" alt=\"cycle-ref\"></p>\n<h3 id=\"Preventing-Reference-Cycles-Turning-an-Rc-into-a-Weak\"><a href=\"#Preventing-Reference-Cycles-Turning-an-Rc-into-a-Weak\" class=\"headerlink\" title=\"Preventing Reference Cycles: Turning an Rc into a Weak\"></a>Preventing Reference Cycles: Turning an Rc<T> into a Weak<T></h3><p>So far, we’ve demonstrated that calling Rc::clone increases the strong_count of an Rc<T> instance, and an Rc<T> instance is only cleaned up if its strong_count is 0. You can also create a weak reference to the value within an Rc<T> instance by calling Rc::downgrade and passing a reference to the Rc<T>. When you call Rc::downgrade, you get a smart pointer of type Weak<T>. Instead of increasing the strong_count in the Rc<T> instance by 1, calling Rc::downgrade increases the weak_count by 1. The Rc<T> type uses weak_count to keep track of how many Weak<T> references exist, similar to strong_count. The difference is the weak_count doesn’t need to be 0 for the Rc<T> instance to be cleaned up.</p>\n<p>Strong references are how you can share ownership of an Rc<T> instance. Weak references don’t express an ownership relationship. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>\n<p>Because the value that Weak<T> references might have been dropped, to do anything with the value that a Weak<T> is pointing to, you must make sure the value still exists. Do this by calling the upgrade method on a Weak<T> instance, which will return an Option&lt;Rc<T>&gt;. You’ll get a result of Some if the Rc<T> value has not been dropped yet and a result of None if the Rc<T> value has been dropped. </p>\n<h3 id=\"Creating-a-Tree-Data-Structure-a-Node-with-Child-Nodes\"><a href=\"#Creating-a-Tree-Data-Structure-a-Node-with-Child-Nodes\" class=\"headerlink\" title=\"Creating a Tree Data Structure: a Node with Child Nodes\"></a>Creating a Tree Data Structure: a Node with Child Nodes</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    value: <span class=\"type\">i32</span>,</span><br><span class=\"line\">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;, <span class=\"comment\">// To make the child node aware of its parent, we need to add a parent field to our Node struct definition. The trouble is in deciding what the type of parent should be. We know it can’t contain an Rc&lt;T&gt;, because that would create a reference cycle with leaf.parent pointing to branch and branch.children pointing to leaf, which would cause their strong_count values to never be 0.</span></span><br><span class=\"line\">    children: RefCell&lt;<span class=\"type\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">leaf</span> = Rc::<span class=\"title function_ invoke__\">new</span>(Node &#123;</span><br><span class=\"line\">        value: <span class=\"number\">3</span>,</span><br><span class=\"line\">        parent: RefCell::<span class=\"title function_ invoke__\">new</span>(Weak::<span class=\"title function_ invoke__\">new</span>()),</span><br><span class=\"line\">        children: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[]),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class=\"title function_ invoke__\">borrow</span>().<span class=\"title function_ invoke__\">upgrade</span>()); <span class=\"comment\">// try to get a reference to the parent of leaf by using the upgrade method, we get a None value. </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">branch</span> = Rc::<span class=\"title function_ invoke__\">new</span>(Node &#123;</span><br><span class=\"line\">        value: <span class=\"number\">5</span>,</span><br><span class=\"line\">        parent: RefCell::<span class=\"title function_ invoke__\">new</span>(Weak::<span class=\"title function_ invoke__\">new</span>()),</span><br><span class=\"line\">        children: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;leaf)]), <span class=\"comment\">// We clone the Rc&lt;Node&gt; in leaf and store that in branch, meaning the Node in leaf now has two owners: leaf and branch. </span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    *leaf.parent.<span class=\"title function_ invoke__\">borrow_mut</span>() = Rc::<span class=\"title function_ invoke__\">downgrade</span>(&amp;branch); <span class=\"comment\">// use the Rc::downgrade function to create a Weak&lt;Node&gt; reference to branch from the Rc&lt;Node&gt; in branch.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class=\"title function_ invoke__\">borrow</span>().<span class=\"title function_ invoke__\">upgrade</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Visualizing-Changes-to-strong-count-and-weak-count\"><a href=\"#Visualizing-Changes-to-strong-count-and-weak-count\" class=\"headerlink\" title=\"Visualizing Changes to strong_count and weak_count\"></a>Visualizing Changes to strong_count and weak_count</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    value: <span class=\"type\">i32</span>,</span><br><span class=\"line\">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class=\"line\">    children: RefCell&lt;<span class=\"type\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">leaf</span> = Rc::<span class=\"title function_ invoke__\">new</span>(Node &#123;</span><br><span class=\"line\">        value: <span class=\"number\">3</span>,</span><br><span class=\"line\">        parent: RefCell::<span class=\"title function_ invoke__\">new</span>(Weak::<span class=\"title function_ invoke__\">new</span>()),</span><br><span class=\"line\">        children: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[]),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class=\"line\">        Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;leaf),</span><br><span class=\"line\">        Rc::<span class=\"title function_ invoke__\">weak_count</span>(&amp;leaf),</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">branch</span> = Rc::<span class=\"title function_ invoke__\">new</span>(Node &#123;</span><br><span class=\"line\">            value: <span class=\"number\">5</span>,</span><br><span class=\"line\">            parent: RefCell::<span class=\"title function_ invoke__\">new</span>(Weak::<span class=\"title function_ invoke__\">new</span>()),</span><br><span class=\"line\">            children: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;leaf)]),</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        *leaf.parent.<span class=\"title function_ invoke__\">borrow_mut</span>() = Rc::<span class=\"title function_ invoke__\">downgrade</span>(&amp;branch);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;branch),</span><br><span class=\"line\">            Rc::<span class=\"title function_ invoke__\">weak_count</span>(&amp;branch),</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;leaf),</span><br><span class=\"line\">            Rc::<span class=\"title function_ invoke__\">weak_count</span>(&amp;leaf),</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class=\"title function_ invoke__\">borrow</span>().<span class=\"title function_ invoke__\">upgrade</span>());</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class=\"line\">        Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;leaf),</span><br><span class=\"line\">        Rc::<span class=\"title function_ invoke__\">weak_count</span>(&amp;leaf),</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>The most common kind of pointer in Rust is a reference (borrow but not own)<br>Smart pointers, on the other hand, are data structures that not only act like a pointer but also have additional metadata and capabilities.<br>references are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to.</p>\n<h3 id=\"smart-pointers-example\"><a href=\"#smart-pointers-example\" class=\"headerlink\" title=\"smart pointers example\"></a>smart pointers example</h3><ul>\n<li>String</li>\n<li>Vec<T><br>Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with String ensuring its data will always be valid UTF-8).</li>\n</ul>\n<h3 id=\"Deref-amp-Drop\"><a href=\"#Deref-amp-Drop\" class=\"headerlink\" title=\"Deref &amp; Drop\"></a>Deref &amp; Drop</h3><p>Smart pointers are usually implemented using structs. The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.</p>\n<ul>\n<li>The Deref trait allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers. </li>\n<li>The Drop trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>\n</ul>\n<h3 id=\"the-most-common-smart-pointers-in-the-standard-library\"><a href=\"#the-most-common-smart-pointers-in-the-standard-library\" class=\"headerlink\" title=\"the most common smart pointers in the standard library:\"></a>the most common smart pointers in the standard library:</h3><ul>\n<li><code>Box&lt;T&gt;</code> for allocating values on the heap</li>\n<li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li>\n<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces the borrowing rules at runtime instead of compile time</li>\n</ul>\n<h2 id=\"Box\"><a href=\"#Box\" class=\"headerlink\" title=\"Box\"></a>Box<T></h2><h3 id=\"when-to-use\"><a href=\"#when-to-use\" class=\"headerlink\" title=\"when to use\"></a>when to use</h3><ul>\n<li>When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size. (such as cons)</li>\n<li>When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so</li>\n<li>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type</li>\n</ul>\n<h3 id=\"enabling-recursive-types-with-Box\"><a href=\"#enabling-recursive-types-with-Box\" class=\"headerlink\" title=\"enabling recursive types with Box\"></a>enabling recursive types with Box</h3><p>At compile time, Rust needs to know how much space a type takes up<br>One type whose size can’t be known at compile time is a recursive type (cons list), use Box, which only contains a memory address</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, List),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">list</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">1</span>, <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">2</span>, <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, Nil))); <span class=\"comment\">// not allowed, infinite size</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>use Box</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, <span class=\"type\">Box</span>&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">list</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">1</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">2</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(Nil))))));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait\"><a href=\"#Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait\" class=\"headerlink\" title=\"Treating Smart Pointers Like Regular References with the Deref Trait\"></a>Treating Smart Pointers Like Regular References with the Deref Trait</h2><p>Implementing the Deref trait allows you to customize the behavior of the dereference operator, <code>*</code><br>By implementing Deref in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>\n<h3 id=\"Defining-Our-Own-Smart-Pointer\"><a href=\"#Defining-Our-Own-Smart-Pointer\" class=\"headerlink\" title=\"Defining Our Own Smart Pointer\"></a>Defining Our Own Smart Pointer</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::ops::Deref;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyBox</span>&lt;T&gt;(T);  <span class=\"comment\">// The MyBox type is a tuple struct with one element of type T</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(x: T) <span class=\"punctuation\">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">MyBox</span>(x)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; Deref <span class=\"keyword\">for</span> <span class=\"title class_\">MyBox</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">type</span> <span class=\"title class_\">Target</span> = T;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">deref</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> &amp;<span class=\"keyword\">Self</span>::Target &#123;</span><br><span class=\"line\">        &amp;<span class=\"keyword\">self</span>.<span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = MyBox::<span class=\"title function_ invoke__\">new</span>(x);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(<span class=\"number\">5</span>, x);</span><br><span class=\"line\">    <span class=\"built_in\">assert_eq!</span>(<span class=\"number\">5</span>, *y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>We fill in the body of the deref method with &amp;self.0 so deref returns a reference to the value we want to access with the * operator. </li>\n<li>behind the scenes Rust actually ran this code: <code>*(y.deref())</code>. Rust substitutes the * operator with a call to the deref method</li>\n<li>The reason the deref method returns a reference to a value, and that the plain dereference outside the parentheses in *(y.deref()) is still necessary, is the ownership system. If the deref method returned the value directly instead of a reference to the value, the value would be moved out of self. We don’t want to take ownership of the inner value inside MyBox<T> in this case or in most cases where we use the dereference operator.</li>\n</ul>\n<h3 id=\"Implicit-Deref-Coercions-with-Functions-and-Methods\"><a href=\"#Implicit-Deref-Coercions-with-Functions-and-Methods\" class=\"headerlink\" title=\"Implicit Deref Coercions with Functions and Methods\"></a>Implicit Deref Coercions with Functions and Methods</h3><p>Deref coercion is a convenience that Rust performs on arguments to functions and methods.<br>Deref coercion works only on types that implement the Deref trait. Deref coercion converts a reference to such a type into a reference to another type. For example, deref coercion can convert &amp;String to &amp;str because String implements the Deref trait such that it returns &amp;str<br>A sequence of calls to the deref method converts the type we provided into the type the parameter needs.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">hello</span>(name: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">m</span> = MyBox::<span class=\"title function_ invoke__\">new</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;Rust&quot;</span>));</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">hello</span>(<span class=\"string\">&quot;rust&quot;</span>);  <span class=\"comment\">// ok</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">hello</span>(&amp;m);      <span class=\"comment\">// also ok</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">hello</span>(&amp;(*m)[..]); <span class=\"comment\">// without deref coercion. The (*m) dereferences the MyBox&lt;String&gt; into a String. Then the &amp; and [..] take a string slice of the String that is equal to the whole string to match the signature of hello</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Here we’re calling the hello function with the argument &amp;m, which is a reference to a MyBox<String> value. Because we implemented the Deref trait on MyBox<T>, Rust can turn &amp;MyBox<String> into &amp;String by calling deref. The standard library provides an implementation of Deref on String that returns a string slice. Rust calls deref again to turn the &amp;String into &amp;str, which matches the hello function’s definition.</p>\n<h3 id=\"How-Deref-Coercion-Interacts-with-Mutability\"><a href=\"#How-Deref-Coercion-Interacts-with-Mutability\" class=\"headerlink\" title=\"How Deref Coercion Interacts with Mutability\"></a>How Deref Coercion Interacts with Mutability</h3><p>Similar to how you use the Deref trait to override the * operator on immutable references, you can use the DerefMut trait to override the * operator on mutable references.</p>\n<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>\n<ul>\n<li>From &amp;T to &amp;U when T: Deref&lt;Target&#x3D;U&gt;</li>\n<li>From &amp;mut T to &amp;mut U when T: DerefMut&lt;Target&#x3D;U&gt;</li>\n<li>From &amp;mut T to &amp;U when T: Deref&lt;Target&#x3D;U&gt;</li>\n</ul>\n<h2 id=\"Running-Code-on-Cleanup-with-the-Drop-Trait\"><a href=\"#Running-Code-on-Cleanup-with-the-Drop-Trait\" class=\"headerlink\" title=\"Running Code on Cleanup with the Drop Trait\"></a>Running Code on Cleanup with the Drop Trait</h2><p>Drop, which lets you customize what happens when a value is about to go out of scope. </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    data: <span class=\"type\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Drop</span> <span class=\"keyword\">for</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">drop</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;</span>, <span class=\"keyword\">self</span>.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = CustomSmartPointer &#123;</span><br><span class=\"line\">        data: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;my stuff&quot;</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    c.<span class=\"title function_ invoke__\">drop</span>(); <span class=\"comment\">// not allowed</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">d</span> = CustomSmartPointer &#123;</span><br><span class=\"line\">        data: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;other stuff&quot;</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;CustomSmartPointers created.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dropping-a-Value-Early-with-std-mem-drop\"><a href=\"#Dropping-a-Value-Early-with-std-mem-drop\" class=\"headerlink\" title=\"Dropping a Value Early with std::mem::drop\"></a>Dropping a Value Early with std::mem::drop</h3><p>std::mem::drop is in prelude, can use directly</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    data: <span class=\"type\">String</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Drop</span> <span class=\"keyword\">for</span> <span class=\"title class_\">CustomSmartPointer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">drop</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;</span>, <span class=\"keyword\">self</span>.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = CustomSmartPointer &#123;</span><br><span class=\"line\">        data: <span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(<span class=\"string\">&quot;some data&quot;</span>),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;CustomSmartPointer created.&quot;</span>);</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">drop</span>(c); <span class=\"comment\">// ok</span></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;CustomSmartPointer dropped before the end of main.&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"comment\">// c goes out of scope, will occur double drop</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"Rc-the-Reference-Counted-Smart-Pointer\"><a href=\"#Rc-the-Reference-Counted-Smart-Pointer\" class=\"headerlink\" title=\"Rc: the Reference Counted Smart Pointer\"></a>Rc: the Reference Counted Smart Pointer</h2><p>In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners.<br>type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>\n<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last.</p>\n<p>Rc<T> is only for use in single-threaded scenarios</p>\n<h3 id=\"using-Rc-to-share-data\"><a href=\"#using-Rc-to-share-data\" class=\"headerlink\" title=\"using Rc to share data\"></a>using Rc<T> to share data</h3><p><img src=\"/images/rust/pointers/rc.png\" alt=\"rc\"><br>implement use box will not work, as below</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, <span class=\"type\">Box</span>&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">5</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">10</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(Nil))));</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(a)); <span class=\"comment\">// value moved here</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">4</span>, <span class=\"type\">Box</span>::<span class=\"title function_ invoke__\">new</span>(a)); <span class=\"comment\">// value used here after move</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>use Rc</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, Rc&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">5</span>, Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">10</span>, Rc::<span class=\"title function_ invoke__\">new</span>(Nil)))));</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a)); <span class=\"comment\">// shalow copy only reference, not data</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">4</span>, Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>We could have called a.clone() rather than Rc::clone(&amp;a), but Rust’s convention is to use Rc::clone in this case. The implementation of Rc::clone doesn’t make a deep copy of all the data like most types’ implementations of clone do. The call to Rc::clone only increments the reference count, which doesn’t take much time.</p>\n<h3 id=\"Cloning-an-Rc-Increases-the-Reference-Count\"><a href=\"#Cloning-an-Rc-Increases-the-Reference-Count\" class=\"headerlink\" title=\"Cloning an Rc Increases the Reference Count\"></a>Cloning an Rc<T> Increases the Reference Count</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, Rc&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">5</span>, Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">10</span>, Rc::<span class=\"title function_ invoke__\">new</span>(Nil)))));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));  <span class=\"comment\">// 1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">3</span>, Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));  <span class=\"comment\">// 2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">4</span>, Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a)); <span class=\"comment\">// 3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));  <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>What we can’t see in this example is that when b and then a go out of scope at the end of main, the count is then 0, and the Rc<List> is cleaned up completely at that point.</p>\n<h2 id=\"RefCell-and-interior-mutability-pattern\"><a href=\"#RefCell-and-interior-mutability-pattern\" class=\"headerlink\" title=\"RefCell and interior mutability pattern\"></a>RefCell<T> and interior mutability pattern</h2><p>Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules.<br>To mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing.<br>We can use types that use the interior mutability pattern when we can ensure that the borrowing rules will be followed at <strong>runtime</strong>, even though the compiler can’t guarantee that.<br>The unsafe code involved is then wrapped in a safe API, and the outer type is still immutable.</p>\n<h3 id=\"Enforcing-Borrowing-Rules-at-Runtime-with-RefCell\"><a href=\"#Enforcing-Borrowing-Rules-at-Runtime-with-RefCell\" class=\"headerlink\" title=\"Enforcing Borrowing Rules at Runtime with RefCell\"></a>Enforcing Borrowing Rules at Runtime with RefCell<T></h3><p>Unlike Rc<T>, the RefCell<T> type represents single ownership over the data it holds.</p>\n<p>recall borrowing rules</p>\n<ul>\n<li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references.</li>\n<li>References must always be valid.<br>With references and Box<T>, the borrowing rules’ invariants are enforced at compile time. With RefCell<T>, these invariants are enforced at runtime.<br>Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.</li>\n</ul>\n<h3 id=\"Interior-Mutability-A-Mutable-Borrow-to-an-Immutable-Value\"><a href=\"#Interior-Mutability-A-Mutable-Borrow-to-an-Immutable-Value\" class=\"headerlink\" title=\"Interior Mutability: A Mutable Borrow to an Immutable Value\"></a>Interior Mutability: A Mutable Borrow to an Immutable Value</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">x</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">y</span> = &amp;<span class=\"keyword\">mut</span> x; <span class=\"comment\">// not allowed. cannot borrow `x` as mutable, as it is not declared as mutable</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"A-Use-Case-for-Interior-Mutability-Mock-Objects\"><a href=\"#A-Use-Case-for-Interior-Mutability-Mock-Objects\" class=\"headerlink\" title=\"A Use Case for Interior Mutability: Mock Objects\"></a>A Use Case for Interior Mutability: Mock Objects</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">Messenger</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, msg: &amp;<span class=\"type\">str</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LimitTracker</span>&lt;<span class=\"symbol\">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class=\"line\">    messenger: &amp;<span class=\"symbol\">&#x27;a</span> T,</span><br><span class=\"line\">    value: <span class=\"type\">usize</span>,</span><br><span class=\"line\">    max: <span class=\"type\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;<span class=\"symbol\">&#x27;a</span>, T&gt; LimitTracker&lt;<span class=\"symbol\">&#x27;a</span>, T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: Messenger,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(messenger: &amp;T, max: <span class=\"type\">usize</span>) <span class=\"punctuation\">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class=\"line\">        LimitTracker &#123;</span><br><span class=\"line\">            messenger,</span><br><span class=\"line\">            value: <span class=\"number\">0</span>,</span><br><span class=\"line\">            max,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">set_value</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, value: <span class=\"type\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">percentage_of_max</span> = <span class=\"keyword\">self</span>.value <span class=\"keyword\">as</span> <span class=\"type\">f64</span> / <span class=\"keyword\">self</span>.max <span class=\"keyword\">as</span> <span class=\"type\">f64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">1.0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger.<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.9</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.75</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>a problematic usage</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">Messenger</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, msg: &amp;<span class=\"type\">str</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LimitTracker</span>&lt;<span class=\"symbol\">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class=\"line\">    messenger: &amp;<span class=\"symbol\">&#x27;a</span> T,</span><br><span class=\"line\">    value: <span class=\"type\">usize</span>,</span><br><span class=\"line\">    max: <span class=\"type\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;<span class=\"symbol\">&#x27;a</span>, T&gt; LimitTracker&lt;<span class=\"symbol\">&#x27;a</span>, T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: Messenger,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(messenger: &amp;T, max: <span class=\"type\">usize</span>) <span class=\"punctuation\">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class=\"line\">        LimitTracker &#123;</span><br><span class=\"line\">            messenger,</span><br><span class=\"line\">            value: <span class=\"number\">0</span>,</span><br><span class=\"line\">            max,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">set_value</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, value: <span class=\"type\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">percentage_of_max</span> = <span class=\"keyword\">self</span>.value <span class=\"keyword\">as</span> <span class=\"type\">f64</span> / <span class=\"keyword\">self</span>.max <span class=\"keyword\">as</span> <span class=\"type\">f64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">1.0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger.<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.9</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.75</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[cfg(test)]</span></span><br><span class=\"line\"><span class=\"keyword\">mod</span> tests &#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> super::*;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        sent_messages: <span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>() <span class=\"punctuation\">-&gt;</span> MockMessenger &#123;</span><br><span class=\"line\">            MockMessenger &#123;</span><br><span class=\"line\">                sent_messages: <span class=\"built_in\">vec!</span>[],</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">Messenger</span> <span class=\"keyword\">for</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, message: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.sent_messages.<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(message)); <span class=\"comment\">// not allowed. cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[test]</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">mock_messenger</span> = MockMessenger::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">limit_tracker</span> = LimitTracker::<span class=\"title function_ invoke__\">new</span>(&amp;mock_messenger, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        limit_tracker.<span class=\"title function_ invoke__\">set_value</span>(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">assert_eq!</span>(mock_messenger.sent_messages.<span class=\"title function_ invoke__\">len</span>(), <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>We can’t modify the MockMessenger to keep track of the messages, because the send method takes an immutable reference to self. We also can’t take the suggestion from the error text to use &amp;mut self instead, because then the signature of send wouldn’t match the signature in the Messenger trait definition</p>\n<p>This is a situation in which interior mutability can help! </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"title class_\">Messenger</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, msg: &amp;<span class=\"type\">str</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">LimitTracker</span>&lt;<span class=\"symbol\">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class=\"line\">    messenger: &amp;<span class=\"symbol\">&#x27;a</span> T,</span><br><span class=\"line\">    value: <span class=\"type\">usize</span>,</span><br><span class=\"line\">    max: <span class=\"type\">usize</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span>&lt;<span class=\"symbol\">&#x27;a</span>, T&gt; LimitTracker&lt;<span class=\"symbol\">&#x27;a</span>, T&gt;</span><br><span class=\"line\"><span class=\"keyword\">where</span></span><br><span class=\"line\">    T: Messenger,</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>(messenger: &amp;T, max: <span class=\"type\">usize</span>) <span class=\"punctuation\">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class=\"line\">        LimitTracker &#123;</span><br><span class=\"line\">            messenger,</span><br><span class=\"line\">            value: <span class=\"number\">0</span>,</span><br><span class=\"line\">            max,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">set_value</span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, value: <span class=\"type\">usize</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value = value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">percentage_of_max</span> = <span class=\"keyword\">self</span>.value <span class=\"keyword\">as</span> <span class=\"type\">f64</span> / <span class=\"keyword\">self</span>.max <span class=\"keyword\">as</span> <span class=\"type\">f64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">1.0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger.<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.9</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> percentage_of_max &gt;= <span class=\"number\">0.75</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.messenger</span><br><span class=\"line\">                .<span class=\"title function_ invoke__\">send</span>(<span class=\"string\">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[cfg(test)]</span></span><br><span class=\"line\"><span class=\"keyword\">mod</span> tests &#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> super::*;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        sent_messages: RefCell&lt;<span class=\"type\">Vec</span>&lt;<span class=\"type\">String</span>&gt;&gt;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">new</span>() <span class=\"punctuation\">-&gt;</span> MockMessenger &#123;</span><br><span class=\"line\">            MockMessenger &#123;</span><br><span class=\"line\">                sent_messages: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[]),</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">impl</span> <span class=\"title class_\">Messenger</span> <span class=\"keyword\">for</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, message: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.sent_messages.<span class=\"title function_ invoke__\">borrow_mut</span>().<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(message)); <span class=\"comment\">// call borrow_mut on the RefCell&lt;Vec&lt;String&gt;&gt; in self.sent_messages to get a mutable reference to the value inside the RefCell&lt;Vec&lt;String&gt;&gt;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">#[test]</span></span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// --snip--</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">mock_messenger</span> = MockMessenger::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">limit_tracker</span> = LimitTracker::<span class=\"title function_ invoke__\">new</span>(&amp;mock_messenger, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        limit_tracker.<span class=\"title function_ invoke__\">set_value</span>(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">assert_eq!</span>(mock_messenger.sent_messages.<span class=\"title function_ invoke__\">borrow</span>().<span class=\"title function_ invoke__\">len</span>(), <span class=\"number\">1</span>); <span class=\"comment\">//  call borrow on the RefCell&lt;Vec&lt;String&gt;&gt; to get an immutable reference to the vector.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Keeping-Track-of-Borrows-at-Runtime-with-RefCell\"><a href=\"#Keeping-Track-of-Borrows-at-Runtime-with-RefCell\" class=\"headerlink\" title=\"Keeping Track of Borrows at Runtime with RefCell\"></a>Keeping Track of Borrows at Runtime with RefCell<T></h3><p>When creating immutable and mutable references, we use the &amp; and &amp;mut syntax, respectively. With RefCell<T>, we use the borrow and borrow_mut methods, which are part of the safe API that belongs to RefCell<T>. <strong>The borrow method returns the smart pointer type Ref<T>, and borrow_mut returns the smart pointer type RefMut<T></strong>.  Both types implement Deref, so we can treat them like regular references.</p>\n<p>The RefCell<T> keeps track of how many Ref<T> and RefMut<T> smart pointers are currently active.RefCell<T> lets us have many immutable borrows or one mutable borrow at any point in time. If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of RefCell<T> will panic at runtime. </p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">Messenger</span> <span class=\"keyword\">for</span> <span class=\"title class_\">MockMessenger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">fn</span> <span class=\"title function_\">send</span>(&amp;<span class=\"keyword\">self</span>, message: &amp;<span class=\"type\">str</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">one_borrow</span> = <span class=\"keyword\">self</span>.sent_messages.<span class=\"title function_ invoke__\">borrow_mut</span>();</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">two_borrow</span> = <span class=\"keyword\">self</span>.sent_messages.<span class=\"title function_ invoke__\">borrow_mut</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            one_borrow.<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(message));</span><br><span class=\"line\">            two_borrow.<span class=\"title function_ invoke__\">push</span>(<span class=\"type\">String</span>::<span class=\"title function_ invoke__\">from</span>(message));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>When we run the tests for our library, the code in will compile without any errors, but the test will fail<br>thread ‘main’ panicked at ‘already borrowed</p>\n<h3 id=\"Having-Multiple-Owners-of-Mutable-Data-by-Combining-Rc-and-RefCell\"><a href=\"#Having-Multiple-Owners-of-Mutable-Data-by-Combining-Rc-and-RefCell\" class=\"headerlink\" title=\"Having Multiple Owners of Mutable Data by Combining Rc and RefCell\"></a>Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T></h3><p>A common way to use RefCell<T> is in combination with Rc<T>.  If you have an Rc<T> that holds a RefCell<T>, you can get a value that can have multiple owners and that you can mutate!</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(Rc&lt;RefCell&lt;<span class=\"type\">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">value</span> = Rc::<span class=\"title function_ invoke__\">new</span>(RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">5</span>)); <span class=\"comment\">// We create a value that is an instance of Rc&lt;RefCell&lt;i32&gt;&gt; and store it in a variable named value so we can access it directly later.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;value), Rc::<span class=\"title function_ invoke__\">new</span>(Nil))); <span class=\"comment\">//  Then we create a List in a with a Cons variant that holds value. We need to clone value so both a and value have ownership of the inner 5 value rather than transferring ownership from value to a or having a borrow from value. We wrap the list a in an Rc&lt;T&gt; so when we create lists b and c, they can both refer to a</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = <span class=\"title function_ invoke__\">Cons</span>(Rc::<span class=\"title function_ invoke__\">new</span>(RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">3</span>)), Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">c</span> = <span class=\"title function_ invoke__\">Cons</span>(Rc::<span class=\"title function_ invoke__\">new</span>(RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"number\">4</span>)), Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a));</span><br><span class=\"line\"></span><br><span class=\"line\">    *value.<span class=\"title function_ invoke__\">borrow_mut</span>() += <span class=\"number\">10</span>; <span class=\"comment\">// After we’ve created the lists in a, b, and c, we add 10 to the value in value. We do this by calling borrow_mut on value, which uses the automatic dereferencing feature to dereference the Rc&lt;T&gt; to the inner RefCell&lt;T&gt; value. The borrow_mut method returns a RefMut&lt;T&gt; smart pointer, and we use the dereference operator on it and change the inner value.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a after = &#123;:?&#125;&quot;</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;b after = &#123;:?&#125;&quot;</span>, b);</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;c after = &#123;:?&#125;&quot;</span>, c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>The standard library has other types that provide interior mutability, such as Cell<T>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the Cell<T>. There’s also Mutex<T>, which offers interior mutability that’s safe to use across threads;</strong> </p>\n<h2 id=\"Reference-Cycles-Can-Leak-Memory\"><a href=\"#Reference-Cycles-Can-Leak-Memory\" class=\"headerlink\" title=\"Reference Cycles Can Leak Memory\"></a>Reference Cycles Can Leak Memory</h2><p>Rust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a memory leak).</p>\n<h3 id=\"Creating-a-Reference-Cycle\"><a href=\"#Creating-a-Reference-Cycle\" class=\"headerlink\" title=\"Creating a Reference Cycle\"></a>Creating a Reference Cycle</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;), <span class=\"comment\">// The second element in the Cons variant is now RefCell&lt;Rc&lt;List&gt;&gt;, meaning that we want to modify which List value a Cons variant is pointing to. </span></span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">tail</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123; <span class=\"comment\">// We’re also adding a tail method to make it convenient for us to access the second item if we have a Cons variant.</span></span><br><span class=\"line\">        <span class=\"keyword\">match</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_ invoke__\">Cons</span>(_, item) =&gt; <span class=\"title function_ invoke__\">Some</span>(item),</span><br><span class=\"line\">            Nil =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">Cons</span>(<span class=\"type\">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class=\"line\">    Nil,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">impl</span> <span class=\"title class_\">List</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">tail</span>(&amp;<span class=\"keyword\">self</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">match</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">            <span class=\"title function_ invoke__\">Cons</span>(_, item) =&gt; <span class=\"title function_ invoke__\">Some</span>(item),</span><br><span class=\"line\">            Nil =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">a</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">5</span>, RefCell::<span class=\"title function_ invoke__\">new</span>(Rc::<span class=\"title function_ invoke__\">new</span>(Nil))));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a initial rc count = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a next item = &#123;:?&#125;&quot;</span>, a.<span class=\"title function_ invoke__\">tail</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">b</span> = Rc::<span class=\"title function_ invoke__\">new</span>(<span class=\"title function_ invoke__\">Cons</span>(<span class=\"number\">10</span>, RefCell::<span class=\"title function_ invoke__\">new</span>(Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;a)))); <span class=\"comment\">// his code creates a list in a and a list in b that points to the list in a</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a rc count after b creation = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;b initial rc count = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;b));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;b next item = &#123;:?&#125;&quot;</span>, b.<span class=\"title function_ invoke__\">tail</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"variable\">Some</span>(link) = a.<span class=\"title function_ invoke__\">tail</span>() &#123;</span><br><span class=\"line\">        *link.<span class=\"title function_ invoke__\">borrow_mut</span>() = Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;b); <span class=\"comment\">// modifies the list in a to point to b, creating a reference cycle</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;b rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;b));</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;a rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;a));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Uncomment the next line to see that we have a cycle;</span></span><br><span class=\"line\">    <span class=\"comment\">// it will overflow the stack</span></span><br><span class=\"line\">    <span class=\"comment\">// println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// At the end of main, Rust drops the variable b, which decreases the reference count of the Rc&lt;List&gt; instance from 2 to 1. The memory that Rc&lt;List&gt; has on the heap won’t be dropped at this point, because its reference count is 1, not 0. Then Rust drops a, which decreases the reference count of the a Rc&lt;List&gt; instance from 2 to 1 as well. This instance’s memory can’t be dropped either, because the other Rc&lt;List&gt; instance still refers to it. The memory allocated to the list will remain uncollected forever.</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/rust/pointers/cycle.ref.png\" alt=\"cycle-ref\"></p>\n<h3 id=\"Preventing-Reference-Cycles-Turning-an-Rc-into-a-Weak\"><a href=\"#Preventing-Reference-Cycles-Turning-an-Rc-into-a-Weak\" class=\"headerlink\" title=\"Preventing Reference Cycles: Turning an Rc into a Weak\"></a>Preventing Reference Cycles: Turning an Rc<T> into a Weak<T></h3><p>So far, we’ve demonstrated that calling Rc::clone increases the strong_count of an Rc<T> instance, and an Rc<T> instance is only cleaned up if its strong_count is 0. You can also create a weak reference to the value within an Rc<T> instance by calling Rc::downgrade and passing a reference to the Rc<T>. When you call Rc::downgrade, you get a smart pointer of type Weak<T>. Instead of increasing the strong_count in the Rc<T> instance by 1, calling Rc::downgrade increases the weak_count by 1. The Rc<T> type uses weak_count to keep track of how many Weak<T> references exist, similar to strong_count. The difference is the weak_count doesn’t need to be 0 for the Rc<T> instance to be cleaned up.</p>\n<p>Strong references are how you can share ownership of an Rc<T> instance. Weak references don’t express an ownership relationship. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>\n<p>Because the value that Weak<T> references might have been dropped, to do anything with the value that a Weak<T> is pointing to, you must make sure the value still exists. Do this by calling the upgrade method on a Weak<T> instance, which will return an Option&lt;Rc<T>&gt;. You’ll get a result of Some if the Rc<T> value has not been dropped yet and a result of None if the Rc<T> value has been dropped. </p>\n<h3 id=\"Creating-a-Tree-Data-Structure-a-Node-with-Child-Nodes\"><a href=\"#Creating-a-Tree-Data-Structure-a-Node-with-Child-Nodes\" class=\"headerlink\" title=\"Creating a Tree Data Structure: a Node with Child Nodes\"></a>Creating a Tree Data Structure: a Node with Child Nodes</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::Rc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    value: <span class=\"type\">i32</span>,</span><br><span class=\"line\">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;, <span class=\"comment\">// To make the child node aware of its parent, we need to add a parent field to our Node struct definition. The trouble is in deciding what the type of parent should be. We know it can’t contain an Rc&lt;T&gt;, because that would create a reference cycle with leaf.parent pointing to branch and branch.children pointing to leaf, which would cause their strong_count values to never be 0.</span></span><br><span class=\"line\">    children: RefCell&lt;<span class=\"type\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">leaf</span> = Rc::<span class=\"title function_ invoke__\">new</span>(Node &#123;</span><br><span class=\"line\">        value: <span class=\"number\">3</span>,</span><br><span class=\"line\">        parent: RefCell::<span class=\"title function_ invoke__\">new</span>(Weak::<span class=\"title function_ invoke__\">new</span>()),</span><br><span class=\"line\">        children: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[]),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class=\"title function_ invoke__\">borrow</span>().<span class=\"title function_ invoke__\">upgrade</span>()); <span class=\"comment\">// try to get a reference to the parent of leaf by using the upgrade method, we get a None value. </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">branch</span> = Rc::<span class=\"title function_ invoke__\">new</span>(Node &#123;</span><br><span class=\"line\">        value: <span class=\"number\">5</span>,</span><br><span class=\"line\">        parent: RefCell::<span class=\"title function_ invoke__\">new</span>(Weak::<span class=\"title function_ invoke__\">new</span>()),</span><br><span class=\"line\">        children: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;leaf)]), <span class=\"comment\">// We clone the Rc&lt;Node&gt; in leaf and store that in branch, meaning the Node in leaf now has two owners: leaf and branch. </span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    *leaf.parent.<span class=\"title function_ invoke__\">borrow_mut</span>() = Rc::<span class=\"title function_ invoke__\">downgrade</span>(&amp;branch); <span class=\"comment\">// use the Rc::downgrade function to create a Weak&lt;Node&gt; reference to branch from the Rc&lt;Node&gt; in branch.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class=\"title function_ invoke__\">borrow</span>().<span class=\"title function_ invoke__\">upgrade</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Visualizing-Changes-to-strong-count-and-weak-count\"><a href=\"#Visualizing-Changes-to-strong-count-and-weak-count\" class=\"headerlink\" title=\"Visualizing Changes to strong_count and weak_count\"></a>Visualizing Changes to strong_count and weak_count</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::cell::RefCell;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#[derive(Debug)]</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    value: <span class=\"type\">i32</span>,</span><br><span class=\"line\">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class=\"line\">    children: RefCell&lt;<span class=\"type\">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">leaf</span> = Rc::<span class=\"title function_ invoke__\">new</span>(Node &#123;</span><br><span class=\"line\">        value: <span class=\"number\">3</span>,</span><br><span class=\"line\">        parent: RefCell::<span class=\"title function_ invoke__\">new</span>(Weak::<span class=\"title function_ invoke__\">new</span>()),</span><br><span class=\"line\">        children: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[]),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class=\"line\">        Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;leaf),</span><br><span class=\"line\">        Rc::<span class=\"title function_ invoke__\">weak_count</span>(&amp;leaf),</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"variable\">branch</span> = Rc::<span class=\"title function_ invoke__\">new</span>(Node &#123;</span><br><span class=\"line\">            value: <span class=\"number\">5</span>,</span><br><span class=\"line\">            parent: RefCell::<span class=\"title function_ invoke__\">new</span>(Weak::<span class=\"title function_ invoke__\">new</span>()),</span><br><span class=\"line\">            children: RefCell::<span class=\"title function_ invoke__\">new</span>(<span class=\"built_in\">vec!</span>[Rc::<span class=\"title function_ invoke__\">clone</span>(&amp;leaf)]),</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        *leaf.parent.<span class=\"title function_ invoke__\">borrow_mut</span>() = Rc::<span class=\"title function_ invoke__\">downgrade</span>(&amp;branch);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;branch),</span><br><span class=\"line\">            Rc::<span class=\"title function_ invoke__\">weak_count</span>(&amp;branch),</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">            <span class=\"string\">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class=\"line\">            Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;leaf),</span><br><span class=\"line\">            Rc::<span class=\"title function_ invoke__\">weak_count</span>(&amp;leaf),</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class=\"title function_ invoke__\">borrow</span>().<span class=\"title function_ invoke__\">upgrade</span>());</span><br><span class=\"line\">    <span class=\"built_in\">println!</span>(</span><br><span class=\"line\">        <span class=\"string\">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class=\"line\">        Rc::<span class=\"title function_ invoke__\">strong_count</span>(&amp;leaf),</span><br><span class=\"line\">        Rc::<span class=\"title function_ invoke__\">weak_count</span>(&amp;leaf),</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"rust reflect and macro","date":"2022-12-28T02:24:21.000Z","_content":"\n## reflect\n### trait object\nRust provides dynamic dispatch through a feature called `trait objects`. Trait objects, like &Foo or Box<Foo>, are normal values that store a value of any type that implements the given trait, where the precise type can only be known at **runtime**. more details can be found on [references 1]\n\n### any\nThis module (std::any) contains the `Any` trait, which enables dynamic typing of any <code>'static</code> type through runtime reflection. It also contains the `Provider` trait and accompanying API, which enable trait objects to provide data based on typed requests, an alternate form of runtime reflection.\nAny itself can be used to get a TypeId\n\n```rust\nuse std::fmt::Debug;\nuse std::any::Any;\n\nfn log<T: Any + Debug>(value: &Any) {\n    let value_any = value as &dyn Any;  // &dyn Any (a borrowed trait object), Note that &dyn Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.\n\n    match value_any.downcast_ref::<String>() {\n        Some(val_str) -> {\n            // do with string\n        },\n        None => {\n            // \n        }\n    }\n}\n```\n\n### porpular crates using Any\n- [oso](https://docs.osohq.com/)\nThe Oso Library is a batteries-included framework for building authorization in your application\n- [bevy](https://bevyengine.org/)\nA refreshingly simple data-driven game engine built in Rust\n\n## macro\n### rust compile process\n![rust compile process](/images/rust/macros/16.compile_process.png)\n\n### front end: rustc\n1. lexical analysis: Code Text -> TokenStream\n2. syntax analysis: TokenStream -> AST (abstract syntax tree)\n3. semantic analyzer: \n            AST -> HIR (High-Level Intermediate Representation) -> Type HIR (static type analysis, syntactic desugar, e.g `for` changed to `loop`) -> MIR: (Mid-Level Intermediate Representation, scope, reference & borrow check)\n\n### back end: LLVM\nLLVM IR -> machine code\n\n\n### macros in compiling\n- declarative macros: TokenStream - expand -> TokenStream\n- procedule macros: self defined AST with the help or third party crate such as syn, quote\n\n## declarative macro: macro_rules!\nDeclarative macros allow us to write match-like code. The match expression is a control structure that receives an expression and then matches the result of the expression with multiple patterns. Once a pattern is matched, the code associated with the pattern will be executed\n```rust\n#![allow(unused)]\nfn main() {\n    match target {\n        match_pattern_1 => expr_1,\n        match_pattern_2 => {\n            statement1;\n            statement2;\n            expr_2\n        },\n        _ => expr_3\n    }\n}\n```\n\n### example 1, simplified `vec!`\nbelow example use macro_rules to implement a simplified version of vec!\n```rust\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n\n#![allow(unused)]\nfn main() {\n    let v: Vec<u32> = vec![1, 2, 3];\n}\n```\n\n### example 2, unless\n```rust\nmacro_rules! unless {\n    ( ($arg:expr) => $branch:tt ) => ( if !$arg {$branch};);\n}\n\nfn cmp(a:i32, b:i32) {\n    unless!{\n        (a>b) => {println!(\"{} < {}\", a,b);}\n    }\n}\nfn main() {\n    cmp(1,2);  /// print \"1<2\" as the condition is true !(a>b)\n    cmp(3,2);  /// print nothing\n}\n```\n### example 3, HashMap\n```rust\nmacro_rules! hashmap {\n    // match for \"a\" => 1, \"b\" => 2,\n    ( $($key:expr => $value:expr,)* ) =>\n        { hashmap!($($key => $value),*) }; // recuisive\n    // match for \"a\" => 1, \"b\" => 2\n    ( $($key:expr => $value:expr),* ) => { \n        {\n            let mut _map = ::std::collections::HashMap::new();\n            $(\n                _map.insert($key, $value);\n            )*\n            _map\n        }\n       \n    };\n}\n\nmacro_rules! hashmap_equivalent {\n    ( $($key:expr => $value:expr),* $(,)*) => { \n        {\n            let mut _map = ::std::collections::HashMap::new();\n            $(\n                _map.insert($key, $value);\n            )*\n            _map\n        }\n       \n    };\n}\nfn main() {\n    let map = hashmap!{\n        \"a\" => 1,\n        \"b\" => 2,  // with or without ,\n    };\n    let map_2 = hashmap_equivalent!{\n        \"a\" => 1, \n        \"b\" => 2,  // with or without ,\n    };\n}\n```\n\n### metavariables\n- item: an Item\n- stmt: a Statement without the trailing semicolon (except for item statements that require semicolons)\n- expr: an Expression\n- ty: a Type\n- ident: an IDENTIFIER_OR_KEYWORD or RAW_IDENTIFIER\n- path: a TypePath style path\n- tt: a TokenTree (a single token or tokens in matching delimiters (), [], or {})\n- meta: an Attr, the contents of an attribute\n- lifetime: a LIFETIME_TOKEN\n- vis: a possibly empty Visibility qualifier\n- literal: matches LiteralExpression\ndetails to be found [here](https://doc.rust-lang.org/reference/macros-by-example.html)\n\n## procedures macro\n\n## references\n1. [rust trait object](https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/trait-objects.html)","source":"_posts/rust-07-macro.md","raw":"---\ntitle: rust reflect and macro\ndate: 2022-12-28 10:24:21\ntags: [rust]\n---\n\n## reflect\n### trait object\nRust provides dynamic dispatch through a feature called `trait objects`. Trait objects, like &Foo or Box<Foo>, are normal values that store a value of any type that implements the given trait, where the precise type can only be known at **runtime**. more details can be found on [references 1]\n\n### any\nThis module (std::any) contains the `Any` trait, which enables dynamic typing of any <code>'static</code> type through runtime reflection. It also contains the `Provider` trait and accompanying API, which enable trait objects to provide data based on typed requests, an alternate form of runtime reflection.\nAny itself can be used to get a TypeId\n\n```rust\nuse std::fmt::Debug;\nuse std::any::Any;\n\nfn log<T: Any + Debug>(value: &Any) {\n    let value_any = value as &dyn Any;  // &dyn Any (a borrowed trait object), Note that &dyn Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.\n\n    match value_any.downcast_ref::<String>() {\n        Some(val_str) -> {\n            // do with string\n        },\n        None => {\n            // \n        }\n    }\n}\n```\n\n### porpular crates using Any\n- [oso](https://docs.osohq.com/)\nThe Oso Library is a batteries-included framework for building authorization in your application\n- [bevy](https://bevyengine.org/)\nA refreshingly simple data-driven game engine built in Rust\n\n## macro\n### rust compile process\n![rust compile process](/images/rust/macros/16.compile_process.png)\n\n### front end: rustc\n1. lexical analysis: Code Text -> TokenStream\n2. syntax analysis: TokenStream -> AST (abstract syntax tree)\n3. semantic analyzer: \n            AST -> HIR (High-Level Intermediate Representation) -> Type HIR (static type analysis, syntactic desugar, e.g `for` changed to `loop`) -> MIR: (Mid-Level Intermediate Representation, scope, reference & borrow check)\n\n### back end: LLVM\nLLVM IR -> machine code\n\n\n### macros in compiling\n- declarative macros: TokenStream - expand -> TokenStream\n- procedule macros: self defined AST with the help or third party crate such as syn, quote\n\n## declarative macro: macro_rules!\nDeclarative macros allow us to write match-like code. The match expression is a control structure that receives an expression and then matches the result of the expression with multiple patterns. Once a pattern is matched, the code associated with the pattern will be executed\n```rust\n#![allow(unused)]\nfn main() {\n    match target {\n        match_pattern_1 => expr_1,\n        match_pattern_2 => {\n            statement1;\n            statement2;\n            expr_2\n        },\n        _ => expr_3\n    }\n}\n```\n\n### example 1, simplified `vec!`\nbelow example use macro_rules to implement a simplified version of vec!\n```rust\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n\n#![allow(unused)]\nfn main() {\n    let v: Vec<u32> = vec![1, 2, 3];\n}\n```\n\n### example 2, unless\n```rust\nmacro_rules! unless {\n    ( ($arg:expr) => $branch:tt ) => ( if !$arg {$branch};);\n}\n\nfn cmp(a:i32, b:i32) {\n    unless!{\n        (a>b) => {println!(\"{} < {}\", a,b);}\n    }\n}\nfn main() {\n    cmp(1,2);  /// print \"1<2\" as the condition is true !(a>b)\n    cmp(3,2);  /// print nothing\n}\n```\n### example 3, HashMap\n```rust\nmacro_rules! hashmap {\n    // match for \"a\" => 1, \"b\" => 2,\n    ( $($key:expr => $value:expr,)* ) =>\n        { hashmap!($($key => $value),*) }; // recuisive\n    // match for \"a\" => 1, \"b\" => 2\n    ( $($key:expr => $value:expr),* ) => { \n        {\n            let mut _map = ::std::collections::HashMap::new();\n            $(\n                _map.insert($key, $value);\n            )*\n            _map\n        }\n       \n    };\n}\n\nmacro_rules! hashmap_equivalent {\n    ( $($key:expr => $value:expr),* $(,)*) => { \n        {\n            let mut _map = ::std::collections::HashMap::new();\n            $(\n                _map.insert($key, $value);\n            )*\n            _map\n        }\n       \n    };\n}\nfn main() {\n    let map = hashmap!{\n        \"a\" => 1,\n        \"b\" => 2,  // with or without ,\n    };\n    let map_2 = hashmap_equivalent!{\n        \"a\" => 1, \n        \"b\" => 2,  // with or without ,\n    };\n}\n```\n\n### metavariables\n- item: an Item\n- stmt: a Statement without the trailing semicolon (except for item statements that require semicolons)\n- expr: an Expression\n- ty: a Type\n- ident: an IDENTIFIER_OR_KEYWORD or RAW_IDENTIFIER\n- path: a TypePath style path\n- tt: a TokenTree (a single token or tokens in matching delimiters (), [], or {})\n- meta: an Attr, the contents of an attribute\n- lifetime: a LIFETIME_TOKEN\n- vis: a possibly empty Visibility qualifier\n- literal: matches LiteralExpression\ndetails to be found [here](https://doc.rust-lang.org/reference/macros-by-example.html)\n\n## procedures macro\n\n## references\n1. [rust trait object](https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/trait-objects.html)","slug":"rust-07-macro","published":1,"updated":"2023-05-01T14:18:30.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tp000p6usj5aqdc9r8","content":"<h2 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h2><h3 id=\"trait-object\"><a href=\"#trait-object\" class=\"headerlink\" title=\"trait object\"></a>trait object</h3><p>Rust provides dynamic dispatch through a feature called <code>trait objects</code>. Trait objects, like &amp;Foo or Box<Foo>, are normal values that store a value of any type that implements the given trait, where the precise type can only be known at <strong>runtime</strong>. more details can be found on [references 1]</p>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><p>This module (std::any) contains the <code>Any</code> trait, which enables dynamic typing of any <code>'static</code> type through runtime reflection. It also contains the <code>Provider</code> trait and accompanying API, which enable trait objects to provide data based on typed requests, an alternate form of runtime reflection.<br>Any itself can be used to get a TypeId</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::fmt::<span class=\"built_in\">Debug</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::any::Any;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">log</span>&lt;T: Any + <span class=\"built_in\">Debug</span>&gt;(value: &amp;Any) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">value_any</span> = value <span class=\"keyword\">as</span> &amp;<span class=\"keyword\">dyn</span> Any;  <span class=\"comment\">// &amp;dyn Any (a borrowed trait object), Note that &amp;dyn Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">match</span> value_any.downcast_ref::&lt;<span class=\"type\">String</span>&gt;() &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Some</span>(val_str) <span class=\"punctuation\">-&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do with string</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"porpular-crates-using-Any\"><a href=\"#porpular-crates-using-Any\" class=\"headerlink\" title=\"porpular crates using Any\"></a>porpular crates using Any</h3><ul>\n<li><a href=\"https://docs.osohq.com/\">oso</a><br>The Oso Library is a batteries-included framework for building authorization in your application</li>\n<li><a href=\"https://bevyengine.org/\">bevy</a><br>A refreshingly simple data-driven game engine built in Rust</li>\n</ul>\n<h2 id=\"macro\"><a href=\"#macro\" class=\"headerlink\" title=\"macro\"></a>macro</h2><h3 id=\"rust-compile-process\"><a href=\"#rust-compile-process\" class=\"headerlink\" title=\"rust compile process\"></a>rust compile process</h3><p><img src=\"/images/rust/macros/16.compile_process.png\" alt=\"rust compile process\"></p>\n<h3 id=\"front-end-rustc\"><a href=\"#front-end-rustc\" class=\"headerlink\" title=\"front end: rustc\"></a>front end: rustc</h3><ol>\n<li>lexical analysis: Code Text -&gt; TokenStream</li>\n<li>syntax analysis: TokenStream -&gt; AST (abstract syntax tree)</li>\n<li>semantic analyzer:<br>     AST -&gt; HIR (High-Level Intermediate Representation) -&gt; Type HIR (static type analysis, syntactic desugar, e.g <code>for</code> changed to <code>loop</code>) -&gt; MIR: (Mid-Level Intermediate Representation, scope, reference &amp; borrow check)</li>\n</ol>\n<h3 id=\"back-end-LLVM\"><a href=\"#back-end-LLVM\" class=\"headerlink\" title=\"back end: LLVM\"></a>back end: LLVM</h3><p>LLVM IR -&gt; machine code</p>\n<h3 id=\"macros-in-compiling\"><a href=\"#macros-in-compiling\" class=\"headerlink\" title=\"macros in compiling\"></a>macros in compiling</h3><ul>\n<li>declarative macros: TokenStream - expand -&gt; TokenStream</li>\n<li>procedule macros: self defined AST with the help or third party crate such as syn, quote</li>\n</ul>\n<h2 id=\"declarative-macro-macro-rules\"><a href=\"#declarative-macro-macro-rules\" class=\"headerlink\" title=\"declarative macro: macro_rules!\"></a>declarative macro: macro_rules!</h2><p>Declarative macros allow us to write match-like code. The match expression is a control structure that receives an expression and then matches the result of the expression with multiple patterns. Once a pattern is matched, the code associated with the pattern will be executed</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#![allow(unused)]</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> target &#123;</span><br><span class=\"line\">        match_pattern_1 =&gt; expr_1,</span><br><span class=\"line\">        match_pattern_2 =&gt; &#123;</span><br><span class=\"line\">            statement1;</span><br><span class=\"line\">            statement2;</span><br><span class=\"line\">            expr_2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        _ =&gt; expr_3</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"example-1-simplified-vec\"><a href=\"#example-1-simplified-vec\" class=\"headerlink\" title=\"example 1, simplified vec!\"></a>example 1, simplified <code>vec!</code></h3><p>below example use macro_rules to implement a simplified version of vec!</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> vec &#123;</span><br><span class=\"line\">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">temp_vec</span> = <span class=\"type\">Vec</span>::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">            $(</span><br><span class=\"line\">                temp_vec.<span class=\"title function_ invoke__\">push</span>($x);</span><br><span class=\"line\">            )*</span><br><span class=\"line\">            temp_vec</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#![allow(unused)]</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">v</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">u32</span>&gt; = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"example-2-unless\"><a href=\"#example-2-unless\" class=\"headerlink\" title=\"example 2, unless\"></a>example 2, unless</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> unless &#123;</span><br><span class=\"line\">    ( ($arg:expr) =&gt; $branch:tt ) =&gt; ( <span class=\"keyword\">if</span> !$arg &#123;$branch&#125;;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">cmp</span>(a:<span class=\"type\">i32</span>, b:<span class=\"type\">i32</span>) &#123;</span><br><span class=\"line\">    unless!&#123;</span><br><span class=\"line\">        (a&gt;b) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; &lt; &#123;&#125;&quot;</span>, a,b);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">cmp</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);  <span class=\"comment\">/// print &quot;1&lt;2&quot; as the condition is true !(a&gt;b)</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">cmp</span>(<span class=\"number\">3</span>,<span class=\"number\">2</span>);  <span class=\"comment\">/// print nothing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"example-3-HashMap\"><a href=\"#example-3-HashMap\" class=\"headerlink\" title=\"example 3, HashMap\"></a>example 3, HashMap</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> hashmap &#123;</span><br><span class=\"line\">    <span class=\"comment\">// match for &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2,</span></span><br><span class=\"line\">    ( $($key:expr =&gt; $value:expr,)* ) =&gt;</span><br><span class=\"line\">        &#123; hashmap!($($key =&gt; $value),*) &#125;; <span class=\"comment\">// recuisive</span></span><br><span class=\"line\">    <span class=\"comment\">// match for &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2</span></span><br><span class=\"line\">    ( $($key:expr =&gt; $value:expr),* ) =&gt; &#123; </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">_map</span> = ::std::collections::HashMap::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">            $(</span><br><span class=\"line\">                _map.<span class=\"title function_ invoke__\">insert</span>($key, $value);</span><br><span class=\"line\">            )*</span><br><span class=\"line\">            _map</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> hashmap_equivalent &#123;</span><br><span class=\"line\">    ( $($key:expr =&gt; $value:expr),* $(,)*) =&gt; &#123; </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">_map</span> = ::std::collections::HashMap::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">            $(</span><br><span class=\"line\">                _map.<span class=\"title function_ invoke__\">insert</span>($key, $value);</span><br><span class=\"line\">            )*</span><br><span class=\"line\">            _map</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">map</span> = hashmap!&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;a&quot;</span> =&gt; <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;b&quot;</span> =&gt; <span class=\"number\">2</span>,  <span class=\"comment\">// with or without ,</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">map_2</span> = hashmap_equivalent!&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;a&quot;</span> =&gt; <span class=\"number\">1</span>, </span><br><span class=\"line\">        <span class=\"string\">&quot;b&quot;</span> =&gt; <span class=\"number\">2</span>,  <span class=\"comment\">// with or without ,</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"metavariables\"><a href=\"#metavariables\" class=\"headerlink\" title=\"metavariables\"></a>metavariables</h3><ul>\n<li>item: an Item</li>\n<li>stmt: a Statement without the trailing semicolon (except for item statements that require semicolons)</li>\n<li>expr: an Expression</li>\n<li>ty: a Type</li>\n<li>ident: an IDENTIFIER_OR_KEYWORD or RAW_IDENTIFIER</li>\n<li>path: a TypePath style path</li>\n<li>tt: a TokenTree (a single token or tokens in matching delimiters (), [], or {})</li>\n<li>meta: an Attr, the contents of an attribute</li>\n<li>lifetime: a LIFETIME_TOKEN</li>\n<li>vis: a possibly empty Visibility qualifier</li>\n<li>literal: matches LiteralExpression<br>details to be found <a href=\"https://doc.rust-lang.org/reference/macros-by-example.html\">here</a></li>\n</ul>\n<h2 id=\"procedures-macro\"><a href=\"#procedures-macro\" class=\"headerlink\" title=\"procedures macro\"></a>procedures macro</h2><h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ol>\n<li><a href=\"https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/trait-objects.html\">rust trait object</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h2><h3 id=\"trait-object\"><a href=\"#trait-object\" class=\"headerlink\" title=\"trait object\"></a>trait object</h3><p>Rust provides dynamic dispatch through a feature called <code>trait objects</code>. Trait objects, like &amp;Foo or Box<Foo>, are normal values that store a value of any type that implements the given trait, where the precise type can only be known at <strong>runtime</strong>. more details can be found on [references 1]</p>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><p>This module (std::any) contains the <code>Any</code> trait, which enables dynamic typing of any <code>'static</code> type through runtime reflection. It also contains the <code>Provider</code> trait and accompanying API, which enable trait objects to provide data based on typed requests, an alternate form of runtime reflection.<br>Any itself can be used to get a TypeId</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::fmt::<span class=\"built_in\">Debug</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::any::Any;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">log</span>&lt;T: Any + <span class=\"built_in\">Debug</span>&gt;(value: &amp;Any) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">value_any</span> = value <span class=\"keyword\">as</span> &amp;<span class=\"keyword\">dyn</span> Any;  <span class=\"comment\">// &amp;dyn Any (a borrowed trait object), Note that &amp;dyn Any is limited to testing whether a value is of a specified concrete type, and cannot be used to test whether a type implements a trait.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">match</span> value_any.downcast_ref::&lt;<span class=\"type\">String</span>&gt;() &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">Some</span>(val_str) <span class=\"punctuation\">-&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// do with string</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"literal\">None</span> =&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"porpular-crates-using-Any\"><a href=\"#porpular-crates-using-Any\" class=\"headerlink\" title=\"porpular crates using Any\"></a>porpular crates using Any</h3><ul>\n<li><a href=\"https://docs.osohq.com/\">oso</a><br>The Oso Library is a batteries-included framework for building authorization in your application</li>\n<li><a href=\"https://bevyengine.org/\">bevy</a><br>A refreshingly simple data-driven game engine built in Rust</li>\n</ul>\n<h2 id=\"macro\"><a href=\"#macro\" class=\"headerlink\" title=\"macro\"></a>macro</h2><h3 id=\"rust-compile-process\"><a href=\"#rust-compile-process\" class=\"headerlink\" title=\"rust compile process\"></a>rust compile process</h3><p><img src=\"/images/rust/macros/16.compile_process.png\" alt=\"rust compile process\"></p>\n<h3 id=\"front-end-rustc\"><a href=\"#front-end-rustc\" class=\"headerlink\" title=\"front end: rustc\"></a>front end: rustc</h3><ol>\n<li>lexical analysis: Code Text -&gt; TokenStream</li>\n<li>syntax analysis: TokenStream -&gt; AST (abstract syntax tree)</li>\n<li>semantic analyzer:<br>     AST -&gt; HIR (High-Level Intermediate Representation) -&gt; Type HIR (static type analysis, syntactic desugar, e.g <code>for</code> changed to <code>loop</code>) -&gt; MIR: (Mid-Level Intermediate Representation, scope, reference &amp; borrow check)</li>\n</ol>\n<h3 id=\"back-end-LLVM\"><a href=\"#back-end-LLVM\" class=\"headerlink\" title=\"back end: LLVM\"></a>back end: LLVM</h3><p>LLVM IR -&gt; machine code</p>\n<h3 id=\"macros-in-compiling\"><a href=\"#macros-in-compiling\" class=\"headerlink\" title=\"macros in compiling\"></a>macros in compiling</h3><ul>\n<li>declarative macros: TokenStream - expand -&gt; TokenStream</li>\n<li>procedule macros: self defined AST with the help or third party crate such as syn, quote</li>\n</ul>\n<h2 id=\"declarative-macro-macro-rules\"><a href=\"#declarative-macro-macro-rules\" class=\"headerlink\" title=\"declarative macro: macro_rules!\"></a>declarative macro: macro_rules!</h2><p>Declarative macros allow us to write match-like code. The match expression is a control structure that receives an expression and then matches the result of the expression with multiple patterns. Once a pattern is matched, the code associated with the pattern will be executed</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#![allow(unused)]</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">match</span> target &#123;</span><br><span class=\"line\">        match_pattern_1 =&gt; expr_1,</span><br><span class=\"line\">        match_pattern_2 =&gt; &#123;</span><br><span class=\"line\">            statement1;</span><br><span class=\"line\">            statement2;</span><br><span class=\"line\">            expr_2</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        _ =&gt; expr_3</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"example-1-simplified-vec\"><a href=\"#example-1-simplified-vec\" class=\"headerlink\" title=\"example 1, simplified vec!\"></a>example 1, simplified <code>vec!</code></h3><p>below example use macro_rules to implement a simplified version of vec!</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[macro_export]</span></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> vec &#123;</span><br><span class=\"line\">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">temp_vec</span> = <span class=\"type\">Vec</span>::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">            $(</span><br><span class=\"line\">                temp_vec.<span class=\"title function_ invoke__\">push</span>($x);</span><br><span class=\"line\">            )*</span><br><span class=\"line\">            temp_vec</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#![allow(unused)]</span></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">v</span>: <span class=\"type\">Vec</span>&lt;<span class=\"type\">u32</span>&gt; = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"example-2-unless\"><a href=\"#example-2-unless\" class=\"headerlink\" title=\"example 2, unless\"></a>example 2, unless</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> unless &#123;</span><br><span class=\"line\">    ( ($arg:expr) =&gt; $branch:tt ) =&gt; ( <span class=\"keyword\">if</span> !$arg &#123;$branch&#125;;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">cmp</span>(a:<span class=\"type\">i32</span>, b:<span class=\"type\">i32</span>) &#123;</span><br><span class=\"line\">    unless!&#123;</span><br><span class=\"line\">        (a&gt;b) =&gt; &#123;<span class=\"built_in\">println!</span>(<span class=\"string\">&quot;&#123;&#125; &lt; &#123;&#125;&quot;</span>, a,b);&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"title function_ invoke__\">cmp</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>);  <span class=\"comment\">/// print &quot;1&lt;2&quot; as the condition is true !(a&gt;b)</span></span><br><span class=\"line\">    <span class=\"title function_ invoke__\">cmp</span>(<span class=\"number\">3</span>,<span class=\"number\">2</span>);  <span class=\"comment\">/// print nothing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"example-3-HashMap\"><a href=\"#example-3-HashMap\" class=\"headerlink\" title=\"example 3, HashMap\"></a>example 3, HashMap</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">macro_rules!</span> hashmap &#123;</span><br><span class=\"line\">    <span class=\"comment\">// match for &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2,</span></span><br><span class=\"line\">    ( $($key:expr =&gt; $value:expr,)* ) =&gt;</span><br><span class=\"line\">        &#123; hashmap!($($key =&gt; $value),*) &#125;; <span class=\"comment\">// recuisive</span></span><br><span class=\"line\">    <span class=\"comment\">// match for &quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2</span></span><br><span class=\"line\">    ( $($key:expr =&gt; $value:expr),* ) =&gt; &#123; </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">_map</span> = ::std::collections::HashMap::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">            $(</span><br><span class=\"line\">                _map.<span class=\"title function_ invoke__\">insert</span>($key, $value);</span><br><span class=\"line\">            )*</span><br><span class=\"line\">            _map</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">macro_rules!</span> hashmap_equivalent &#123;</span><br><span class=\"line\">    ( $($key:expr =&gt; $value:expr),* $(,)*) =&gt; &#123; </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> <span class=\"keyword\">mut </span><span class=\"variable\">_map</span> = ::std::collections::HashMap::<span class=\"title function_ invoke__\">new</span>();</span><br><span class=\"line\">            $(</span><br><span class=\"line\">                _map.<span class=\"title function_ invoke__\">insert</span>($key, $value);</span><br><span class=\"line\">            )*</span><br><span class=\"line\">            _map</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">main</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">map</span> = hashmap!&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;a&quot;</span> =&gt; <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;b&quot;</span> =&gt; <span class=\"number\">2</span>,  <span class=\"comment\">// with or without ,</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"variable\">map_2</span> = hashmap_equivalent!&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;a&quot;</span> =&gt; <span class=\"number\">1</span>, </span><br><span class=\"line\">        <span class=\"string\">&quot;b&quot;</span> =&gt; <span class=\"number\">2</span>,  <span class=\"comment\">// with or without ,</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"metavariables\"><a href=\"#metavariables\" class=\"headerlink\" title=\"metavariables\"></a>metavariables</h3><ul>\n<li>item: an Item</li>\n<li>stmt: a Statement without the trailing semicolon (except for item statements that require semicolons)</li>\n<li>expr: an Expression</li>\n<li>ty: a Type</li>\n<li>ident: an IDENTIFIER_OR_KEYWORD or RAW_IDENTIFIER</li>\n<li>path: a TypePath style path</li>\n<li>tt: a TokenTree (a single token or tokens in matching delimiters (), [], or {})</li>\n<li>meta: an Attr, the contents of an attribute</li>\n<li>lifetime: a LIFETIME_TOKEN</li>\n<li>vis: a possibly empty Visibility qualifier</li>\n<li>literal: matches LiteralExpression<br>details to be found <a href=\"https://doc.rust-lang.org/reference/macros-by-example.html\">here</a></li>\n</ul>\n<h2 id=\"procedures-macro\"><a href=\"#procedures-macro\" class=\"headerlink\" title=\"procedures macro\"></a>procedures macro</h2><h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ol>\n<li><a href=\"https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/trait-objects.html\">rust trait object</a></li>\n</ol>\n"},{"title":"cargo_doc","date":"2022-11-13T07:41:59.000Z","_content":"\n## 文档注释\n### 用于生成文档\n  - 使用 ///\n  - 支持 Markdown\n  - 放置在被说没条目之前\n### 例子\n```rust\n/// adds one to the number given\n/// \n/// # Examples\n/// ```\n/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n/// \n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -> i32 {\n    x + 1;\n}\n```\n### 命令\n```\ncargo doc  ## 生成的html放在 target/doc 目录下\ncargo doc --open ## 构建当前crate的文档 (也包含crate依赖项的文档)\n```\n### 常用章节\n- `# Examples`\n- `Panics`: 可能panic的场景\n- `Errors`: 如果fn返回Result, 描述可能的错误种类, 以及导致错误的条件\n- `Safety`: 如果fn出入unsafe调用, 解释unsafe的原因, 以及调用者确保的使用前提\n\n### 文档注释作为测试\n- 运行cargo test, doc中用# Example标记的实例代码会用来测试运行\n\n### 为包含注释的项添加文档注释\n- 符号: //!\n- 这类注释通常用描述crate和模块:\n  - crate root (按惯例 src/lib.rs)\n  - 一个模块内，将crate火模块作为一个整体进行记录","source":"_posts/rust-cargo-doc.md","raw":"---\ntitle: cargo_doc\ndate: 2022-11-13 15:41:59\ntags: [rust,cargo]\n---\n\n## 文档注释\n### 用于生成文档\n  - 使用 ///\n  - 支持 Markdown\n  - 放置在被说没条目之前\n### 例子\n```rust\n/// adds one to the number given\n/// \n/// # Examples\n/// ```\n/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n/// \n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -> i32 {\n    x + 1;\n}\n```\n### 命令\n```\ncargo doc  ## 生成的html放在 target/doc 目录下\ncargo doc --open ## 构建当前crate的文档 (也包含crate依赖项的文档)\n```\n### 常用章节\n- `# Examples`\n- `Panics`: 可能panic的场景\n- `Errors`: 如果fn返回Result, 描述可能的错误种类, 以及导致错误的条件\n- `Safety`: 如果fn出入unsafe调用, 解释unsafe的原因, 以及调用者确保的使用前提\n\n### 文档注释作为测试\n- 运行cargo test, doc中用# Example标记的实例代码会用来测试运行\n\n### 为包含注释的项添加文档注释\n- 符号: //!\n- 这类注释通常用描述crate和模块:\n  - crate root (按惯例 src/lib.rs)\n  - 一个模块内，将crate火模块作为一个整体进行记录","slug":"rust-cargo-doc","published":1,"updated":"2023-05-03T07:45:46.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tp000s6usj4jqheaep","content":"<h2 id=\"文档注释\"><a href=\"#文档注释\" class=\"headerlink\" title=\"文档注释\"></a>文档注释</h2><h3 id=\"用于生成文档\"><a href=\"#用于生成文档\" class=\"headerlink\" title=\"用于生成文档\"></a>用于生成文档</h3><ul>\n<li>使用 &#x2F;&#x2F;&#x2F;</li>\n<li>支持 Markdown</li>\n<li>放置在被说没条目之前</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// adds one to the number given</span></span><br><span class=\"line\"><span class=\"comment\">/// </span></span><br><span class=\"line\"><span class=\"comment\">/// # Examples</span></span><br><span class=\"line\"><span class=\"comment\">/// ```</span></span><br><span class=\"line\"><span class=\"comment\">/// let arg = 5;</span></span><br><span class=\"line\"><span class=\"comment\">/// let answer = my_crate::add_one(arg);</span></span><br><span class=\"line\"><span class=\"comment\">/// </span></span><br><span class=\"line\"><span class=\"comment\">/// assert_eq!(6, answer);</span></span><br><span class=\"line\"><span class=\"comment\">/// ```</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">add_one</span>(x: <span class=\"type\">i32</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">i32</span> &#123;</span><br><span class=\"line\">    x + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo doc  ## 生成的html放在 target/doc 目录下</span><br><span class=\"line\">cargo doc --open ## 构建当前crate的文档 (也包含crate依赖项的文档)</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用章节\"><a href=\"#常用章节\" class=\"headerlink\" title=\"常用章节\"></a>常用章节</h3><ul>\n<li><code># Examples</code></li>\n<li><code>Panics</code>: 可能panic的场景</li>\n<li><code>Errors</code>: 如果fn返回Result, 描述可能的错误种类, 以及导致错误的条件</li>\n<li><code>Safety</code>: 如果fn出入unsafe调用, 解释unsafe的原因, 以及调用者确保的使用前提</li>\n</ul>\n<h3 id=\"文档注释作为测试\"><a href=\"#文档注释作为测试\" class=\"headerlink\" title=\"文档注释作为测试\"></a>文档注释作为测试</h3><ul>\n<li>运行cargo test, doc中用# Example标记的实例代码会用来测试运行</li>\n</ul>\n<h3 id=\"为包含注释的项添加文档注释\"><a href=\"#为包含注释的项添加文档注释\" class=\"headerlink\" title=\"为包含注释的项添加文档注释\"></a>为包含注释的项添加文档注释</h3><ul>\n<li>符号: &#x2F;&#x2F;!</li>\n<li>这类注释通常用描述crate和模块:<ul>\n<li>crate root (按惯例 src&#x2F;lib.rs)</li>\n<li>一个模块内，将crate火模块作为一个整体进行记录</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文档注释\"><a href=\"#文档注释\" class=\"headerlink\" title=\"文档注释\"></a>文档注释</h2><h3 id=\"用于生成文档\"><a href=\"#用于生成文档\" class=\"headerlink\" title=\"用于生成文档\"></a>用于生成文档</h3><ul>\n<li>使用 &#x2F;&#x2F;&#x2F;</li>\n<li>支持 Markdown</li>\n<li>放置在被说没条目之前</li>\n</ul>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// adds one to the number given</span></span><br><span class=\"line\"><span class=\"comment\">/// </span></span><br><span class=\"line\"><span class=\"comment\">/// # Examples</span></span><br><span class=\"line\"><span class=\"comment\">/// ```</span></span><br><span class=\"line\"><span class=\"comment\">/// let arg = 5;</span></span><br><span class=\"line\"><span class=\"comment\">/// let answer = my_crate::add_one(arg);</span></span><br><span class=\"line\"><span class=\"comment\">/// </span></span><br><span class=\"line\"><span class=\"comment\">/// assert_eq!(6, answer);</span></span><br><span class=\"line\"><span class=\"comment\">/// ```</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">add_one</span>(x: <span class=\"type\">i32</span>) <span class=\"punctuation\">-&gt;</span> <span class=\"type\">i32</span> &#123;</span><br><span class=\"line\">    x + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo doc  ## 生成的html放在 target/doc 目录下</span><br><span class=\"line\">cargo doc --open ## 构建当前crate的文档 (也包含crate依赖项的文档)</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用章节\"><a href=\"#常用章节\" class=\"headerlink\" title=\"常用章节\"></a>常用章节</h3><ul>\n<li><code># Examples</code></li>\n<li><code>Panics</code>: 可能panic的场景</li>\n<li><code>Errors</code>: 如果fn返回Result, 描述可能的错误种类, 以及导致错误的条件</li>\n<li><code>Safety</code>: 如果fn出入unsafe调用, 解释unsafe的原因, 以及调用者确保的使用前提</li>\n</ul>\n<h3 id=\"文档注释作为测试\"><a href=\"#文档注释作为测试\" class=\"headerlink\" title=\"文档注释作为测试\"></a>文档注释作为测试</h3><ul>\n<li>运行cargo test, doc中用# Example标记的实例代码会用来测试运行</li>\n</ul>\n<h3 id=\"为包含注释的项添加文档注释\"><a href=\"#为包含注释的项添加文档注释\" class=\"headerlink\" title=\"为包含注释的项添加文档注释\"></a>为包含注释的项添加文档注释</h3><ul>\n<li>符号: &#x2F;&#x2F;!</li>\n<li>这类注释通常用描述crate和模块:<ul>\n<li>crate root (按惯例 src&#x2F;lib.rs)</li>\n<li>一个模块内，将crate火模块作为一个整体进行记录</li>\n</ul>\n</li>\n</ul>\n"},{"title":"rust project management","date":"2022-11-06T07:33:55.000Z","_content":"\n## basic concepts\n- **Packages**: A Cargo feature that lets you build, test, and share crates\n- **Crates**: A tree of modules that produces a library or executable\n- **Modules and use**: Let you control the organization, scope, and privacy of paths\n- **Paths**: A way of naming an item, such as a struct, function, or module\n\n### package\n1. one package can only has one library Crate. default is src/lib.rs\n2. one package can have multiple binary Crates (under src/bin). default src/main.rs\n3. one package has at least one crate，no matter lib or bin。\n4. one package could simultaneously have src/main.rs and src/lib.rs (crate name same to package name)\n```\ncargo new my-project --lib  ## create a library project\n```\n### crate\n- binary or library\n- The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate\n\n### module\n- keyword `mod` \n- module could be nested。\n- module includes(struct、enum、const、trait、func, etc)\n\n### path\n- absolute path: use crate name or `crate`\n- relative path:，use self, super etc\n```rust\nfn serve_order() {}\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::serve_order();\n    }\n    fn cook_order() {}\n}\n```\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n### Bringing Paths into Scope with the use Keyword\n```rust\nuse std::io;\nuse std::io::Write;\nuse std::io:: { self, Write} ;\nuse std::{cmp::Ordering, io};\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\nuse std::collections::*;\n\npub use crate::front_of_house::hosting; // re-exporting names with pub use\n```\n### Separating Modules into Different Files\nFilename: src/lib.rs\n```rust\nmod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n```\nFilename: src/front_of_house.rs\n```rust\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n```\n\n## profile\n```\ncargo build ## dev: [unoptimized + debuginfo]\ncargo build --release ## [optimized]\n```\n- config\n```\n[profile.dev]\nopt-level = 0\n\n[profile.release]\nopt-level = 3\n\n# profile for the wasm example (from project ethers-rs)\n[profile.release.package.ethers-wasm]\nopt-level = \"s\"  # Tell `rustc` to optimize for small code size.\n```\n","source":"_posts/rust-08-project-management.md","raw":"---\ntitle: rust project management\ndate: 2022-11-06 15:33:55\ntags: [rust]\n---\n\n## basic concepts\n- **Packages**: A Cargo feature that lets you build, test, and share crates\n- **Crates**: A tree of modules that produces a library or executable\n- **Modules and use**: Let you control the organization, scope, and privacy of paths\n- **Paths**: A way of naming an item, such as a struct, function, or module\n\n### package\n1. one package can only has one library Crate. default is src/lib.rs\n2. one package can have multiple binary Crates (under src/bin). default src/main.rs\n3. one package has at least one crate，no matter lib or bin。\n4. one package could simultaneously have src/main.rs and src/lib.rs (crate name same to package name)\n```\ncargo new my-project --lib  ## create a library project\n```\n### crate\n- binary or library\n- The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate\n\n### module\n- keyword `mod` \n- module could be nested。\n- module includes(struct、enum、const、trait、func, etc)\n\n### path\n- absolute path: use crate name or `crate`\n- relative path:，use self, super etc\n```rust\nfn serve_order() {}\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::serve_order();\n    }\n    fn cook_order() {}\n}\n```\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\n### Bringing Paths into Scope with the use Keyword\n```rust\nuse std::io;\nuse std::io::Write;\nuse std::io:: { self, Write} ;\nuse std::{cmp::Ordering, io};\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\nuse std::collections::*;\n\npub use crate::front_of_house::hosting; // re-exporting names with pub use\n```\n### Separating Modules into Different Files\nFilename: src/lib.rs\n```rust\nmod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n    hosting::add_to_waitlist();\n}\n```\nFilename: src/front_of_house.rs\n```rust\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n```\n\n## profile\n```\ncargo build ## dev: [unoptimized + debuginfo]\ncargo build --release ## [optimized]\n```\n- config\n```\n[profile.dev]\nopt-level = 0\n\n[profile.release]\nopt-level = 3\n\n# profile for the wasm example (from project ethers-rs)\n[profile.release.package.ethers-wasm]\nopt-level = \"s\"  # Tell `rustc` to optimize for small code size.\n```\n","slug":"rust-08-project-management","published":1,"updated":"2023-05-03T07:41:48.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tt001h6usj465z51mz","content":"<h2 id=\"basic-concepts\"><a href=\"#basic-concepts\" class=\"headerlink\" title=\"basic concepts\"></a>basic concepts</h2><ul>\n<li><strong>Packages</strong>: A Cargo feature that lets you build, test, and share crates</li>\n<li><strong>Crates</strong>: A tree of modules that produces a library or executable</li>\n<li><strong>Modules and use</strong>: Let you control the organization, scope, and privacy of paths</li>\n<li><strong>Paths</strong>: A way of naming an item, such as a struct, function, or module</li>\n</ul>\n<h3 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h3><ol>\n<li>one package can only has one library Crate. default is src&#x2F;lib.rs</li>\n<li>one package can have multiple binary Crates (under src&#x2F;bin). default src&#x2F;main.rs</li>\n<li>one package has at least one crate，no matter lib or bin。</li>\n<li>one package could simultaneously have src&#x2F;main.rs and src&#x2F;lib.rs (crate name same to package name)<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo new my-project --lib  ## create a library project</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"crate\"><a href=\"#crate\" class=\"headerlink\" title=\"crate\"></a>crate</h3><ul>\n<li>binary or library</li>\n<li>The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate</li>\n</ul>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><ul>\n<li>keyword <code>mod</code> </li>\n<li>module could be nested。</li>\n<li>module includes(struct、enum、const、trait、func, etc)</li>\n</ul>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><ul>\n<li>absolute path: use crate name or <code>crate</code></li>\n<li>relative path:，use self, super etc<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">serve_order</span>() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">mod</span> back_of_house &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">fix_incorrect_order</span>() &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">cook_order</span>();</span><br><span class=\"line\">        super::<span class=\"title function_ invoke__\">serve_order</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">cook_order</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> front_of_house &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> hosting &#123;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">add_to_waitlist</span>() &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">eat_at_restaurant</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Absolute path</span></span><br><span class=\"line\">    crate::front_of_house::hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">    <span class=\"comment\">// Relative path</span></span><br><span class=\"line\">    front_of_house::hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Bringing-Paths-into-Scope-with-the-use-Keyword\"><a href=\"#Bringing-Paths-into-Scope-with-the-use-Keyword\" class=\"headerlink\" title=\"Bringing Paths into Scope with the use Keyword\"></a>Bringing Paths into Scope with the use Keyword</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::io;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io::Write;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io:: &#123; <span class=\"keyword\">self</span>, Write&#125; ;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::fmt::<span class=\"type\">Result</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io::<span class=\"type\">Result</span> <span class=\"keyword\">as</span> IoResult;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">use</span> crate::front_of_house::hosting; <span class=\"comment\">// re-exporting names with pub use</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Separating-Modules-into-Different-Files\"><a href=\"#Separating-Modules-into-Different-Files\" class=\"headerlink\" title=\"Separating Modules into Different Files\"></a>Separating Modules into Different Files</h3><p>Filename: src&#x2F;lib.rs</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> front_of_house;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">use</span> crate::front_of_house::hosting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">eat_at_restaurant</span>() &#123;</span><br><span class=\"line\">    hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">    hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">    hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Filename: src&#x2F;front_of_house.rs</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> hosting &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">add_to_waitlist</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo build ## dev: [unoptimized + debuginfo]</span><br><span class=\"line\">cargo build --release ## [optimized]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>config<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[profile.dev]</span><br><span class=\"line\">opt-level = 0</span><br><span class=\"line\"></span><br><span class=\"line\">[profile.release]</span><br><span class=\"line\">opt-level = 3</span><br><span class=\"line\"></span><br><span class=\"line\"># profile for the wasm example (from project ethers-rs)</span><br><span class=\"line\">[profile.release.package.ethers-wasm]</span><br><span class=\"line\">opt-level = &quot;s&quot;  # Tell `rustc` to optimize for small code size.</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"basic-concepts\"><a href=\"#basic-concepts\" class=\"headerlink\" title=\"basic concepts\"></a>basic concepts</h2><ul>\n<li><strong>Packages</strong>: A Cargo feature that lets you build, test, and share crates</li>\n<li><strong>Crates</strong>: A tree of modules that produces a library or executable</li>\n<li><strong>Modules and use</strong>: Let you control the organization, scope, and privacy of paths</li>\n<li><strong>Paths</strong>: A way of naming an item, such as a struct, function, or module</li>\n</ul>\n<h3 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h3><ol>\n<li>one package can only has one library Crate. default is src&#x2F;lib.rs</li>\n<li>one package can have multiple binary Crates (under src&#x2F;bin). default src&#x2F;main.rs</li>\n<li>one package has at least one crate，no matter lib or bin。</li>\n<li>one package could simultaneously have src&#x2F;main.rs and src&#x2F;lib.rs (crate name same to package name)<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo new my-project --lib  ## create a library project</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"crate\"><a href=\"#crate\" class=\"headerlink\" title=\"crate\"></a>crate</h3><ul>\n<li>binary or library</li>\n<li>The crate root is a source file that the Rust compiler starts from and makes up the root module of your crate</li>\n</ul>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><ul>\n<li>keyword <code>mod</code> </li>\n<li>module could be nested。</li>\n<li>module includes(struct、enum、const、trait、func, etc)</li>\n</ul>\n<h3 id=\"path\"><a href=\"#path\" class=\"headerlink\" title=\"path\"></a>path</h3><ul>\n<li>absolute path: use crate name or <code>crate</code></li>\n<li>relative path:，use self, super etc<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fn</span> <span class=\"title function_\">serve_order</span>() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">mod</span> back_of_house &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">fix_incorrect_order</span>() &#123;</span><br><span class=\"line\">        <span class=\"title function_ invoke__\">cook_order</span>();</span><br><span class=\"line\">        super::<span class=\"title function_ invoke__\">serve_order</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">fn</span> <span class=\"title function_\">cook_order</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> front_of_house &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> hosting &#123;</span><br><span class=\"line\">        <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">add_to_waitlist</span>() &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">eat_at_restaurant</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Absolute path</span></span><br><span class=\"line\">    crate::front_of_house::hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">    <span class=\"comment\">// Relative path</span></span><br><span class=\"line\">    front_of_house::hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"Bringing-Paths-into-Scope-with-the-use-Keyword\"><a href=\"#Bringing-Paths-into-Scope-with-the-use-Keyword\" class=\"headerlink\" title=\"Bringing Paths into Scope with the use Keyword\"></a>Bringing Paths into Scope with the use Keyword</h3><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> std::io;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io::Write;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io:: &#123; <span class=\"keyword\">self</span>, Write&#125; ;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::&#123;cmp::Ordering, io&#125;;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::fmt::<span class=\"type\">Result</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::io::<span class=\"type\">Result</span> <span class=\"keyword\">as</span> IoResult;</span><br><span class=\"line\"><span class=\"keyword\">use</span> std::collections::*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">use</span> crate::front_of_house::hosting; <span class=\"comment\">// re-exporting names with pub use</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Separating-Modules-into-Different-Files\"><a href=\"#Separating-Modules-into-Different-Files\" class=\"headerlink\" title=\"Separating Modules into Different Files\"></a>Separating Modules into Different Files</h3><p>Filename: src&#x2F;lib.rs</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mod</span> front_of_house;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">use</span> crate::front_of_house::hosting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">eat_at_restaurant</span>() &#123;</span><br><span class=\"line\">    hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">    hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">    hosting::<span class=\"title function_ invoke__\">add_to_waitlist</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Filename: src&#x2F;front_of_house.rs</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> hosting &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"title function_\">add_to_waitlist</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cargo build ## dev: [unoptimized + debuginfo]</span><br><span class=\"line\">cargo build --release ## [optimized]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>config<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[profile.dev]</span><br><span class=\"line\">opt-level = 0</span><br><span class=\"line\"></span><br><span class=\"line\">[profile.release]</span><br><span class=\"line\">opt-level = 3</span><br><span class=\"line\"></span><br><span class=\"line\"># profile for the wasm example (from project ethers-rs)</span><br><span class=\"line\">[profile.release.package.ethers-wasm]</span><br><span class=\"line\">opt-level = &quot;s&quot;  # Tell `rustc` to optimize for small code size.</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"two party ecdsa","date":"2023-02-07T06:29:26.000Z","_content":"<script\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n  type=\"text/javascript\">\n</script>\n\n## overview\nthis post is my reading summary of paper Yehuda Lindell 2017: Fast secure two-party ecdsa signing. the implementation could be found in tss-lib (golang), zengo's library (rust).\n\nUnlike other schemes like RSA, Schnorr signatures and more, it is particularly hard to construct efficient threshold signature protocols for ECDSA as there is an inverse computaion of \\\\( k \\\\).\n\nIn this paper, we consider the specific case of two parties (and thus no honest majority) and con-struct a protocol that is approximately two orders of magnitude faster than the previous best.\n\n## Comparing ECDSA signing to EC-Schnorr signing\nIn both cases, the public verification key is an elliptic curve point \\\\( Q \\\\) and the private signing key is \\\\( x \\\\) such that \\\\( Q = x \\cdot G \\\\), where \\\\( G \\\\) is the generator point of an EC group of order \\\\( q \\\\).\n![schnorr ecdsa comparison](/images/two_party_ecdsa/schnorr_ecdsa_comparison.png)\n\nObserve that Schnorr signing can be easily distributed since the private key \\\\( x \\\\) and the value k are both used in a linear equation.  In contrast, in ECDSA signing, the equation for computing \\\\( s \\\\) includes \\\\( k^{-1} \\\\). Now, given shares \\\\(k_1\\\\), \\\\(k_2\\\\) such that \\\\(k_1 + k_2 = k \\bmod q\\\\) .It is very difficult to compute \\\\(k_1^{\\prime}\\\\), \\\\(k_2^{\\prime}\\\\) such  that \\\\(k_1^{\\prime} + k_2^{\\prime} = k^{-1} \\bmod q\\\\)\n\n\ntwo-party protocols for ECDSA signing use multiplicative sharing of \\\\( x \\\\) and of \\\\( k \\\\). That is, the parties hold \\\\(x_1\\\\), \\\\(x_2\\\\)  such that \\\\(x_1 \\cdot x_2 = x \\bmod q\\\\), and in each signing operation they generate \\\\(k_1\\\\), \\\\(k_2\\\\) such that \\\\(k_1 \\cdot k_2 = k \\bmod q\\\\). This enables them to easily compute \\\\(k^{-1}\\\\) since each party can locally compute  \\\\(k_i^{\\prime} = k_i^{-1} \\bmod q\\\\), and then \\\\(k_1^{\\prime}\\\\), \\\\(k_2^{\\prime}\\\\) are multiplicative shares of \\\\(k^{-1}\\\\). The parties can then use additively homomorphic encryption – specifically Paillier encryption  – in order to combine their equations. For example, \\\\(P_1\\\\) can compute \\\\(c_1 = Enc_{pk}(k_1^{-1} \\cdot H(m))\\\\) and \\\\(c_2 = Enc_{pk}(k_1^{-1} \\cdot x_1 \\cdot r)\\\\) . Then, using scar multiplication (denoted ⊙) and homomorphic addition (denoted ⊕), \\\\( P_2 \\\\) can compute \\\\( (k_2^{-1} ⊙ c_1 ) ⊕ [( k_2^{-1} \\cdot x_2)  ⊙ c_2 ]\\\\), which will be an encryption of \n\n![paillier encryption](/images/two_party_ecdsa/paillier_enc.png)\n\nHowever, proving that each party worked correctly is extremely difficult. For example, the first party must prove that the Paillier encryption includes \\\\(k_1^{-1}\\\\) when the second party only has \\\\(R_1 = k_1 \\cdot G\\\\). it must prove that the Paillier encryptions are to values in the expected range, and more. This can be done, but it results in a protocol that is very expensive.\n\n## their results\n[WIP]\n\n## references\n- [original papger](https://eprint.iacr.org/2017/552.pdf)","source":"_posts/two-party-ecdsa.md","raw":"---\ntitle: two party ecdsa\ndate: 2023-02-07 14:29:26\ntags: [cryptography,mpc,ecdsa]\n---\n<script\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n  type=\"text/javascript\">\n</script>\n\n## overview\nthis post is my reading summary of paper Yehuda Lindell 2017: Fast secure two-party ecdsa signing. the implementation could be found in tss-lib (golang), zengo's library (rust).\n\nUnlike other schemes like RSA, Schnorr signatures and more, it is particularly hard to construct efficient threshold signature protocols for ECDSA as there is an inverse computaion of \\\\( k \\\\).\n\nIn this paper, we consider the specific case of two parties (and thus no honest majority) and con-struct a protocol that is approximately two orders of magnitude faster than the previous best.\n\n## Comparing ECDSA signing to EC-Schnorr signing\nIn both cases, the public verification key is an elliptic curve point \\\\( Q \\\\) and the private signing key is \\\\( x \\\\) such that \\\\( Q = x \\cdot G \\\\), where \\\\( G \\\\) is the generator point of an EC group of order \\\\( q \\\\).\n![schnorr ecdsa comparison](/images/two_party_ecdsa/schnorr_ecdsa_comparison.png)\n\nObserve that Schnorr signing can be easily distributed since the private key \\\\( x \\\\) and the value k are both used in a linear equation.  In contrast, in ECDSA signing, the equation for computing \\\\( s \\\\) includes \\\\( k^{-1} \\\\). Now, given shares \\\\(k_1\\\\), \\\\(k_2\\\\) such that \\\\(k_1 + k_2 = k \\bmod q\\\\) .It is very difficult to compute \\\\(k_1^{\\prime}\\\\), \\\\(k_2^{\\prime}\\\\) such  that \\\\(k_1^{\\prime} + k_2^{\\prime} = k^{-1} \\bmod q\\\\)\n\n\ntwo-party protocols for ECDSA signing use multiplicative sharing of \\\\( x \\\\) and of \\\\( k \\\\). That is, the parties hold \\\\(x_1\\\\), \\\\(x_2\\\\)  such that \\\\(x_1 \\cdot x_2 = x \\bmod q\\\\), and in each signing operation they generate \\\\(k_1\\\\), \\\\(k_2\\\\) such that \\\\(k_1 \\cdot k_2 = k \\bmod q\\\\). This enables them to easily compute \\\\(k^{-1}\\\\) since each party can locally compute  \\\\(k_i^{\\prime} = k_i^{-1} \\bmod q\\\\), and then \\\\(k_1^{\\prime}\\\\), \\\\(k_2^{\\prime}\\\\) are multiplicative shares of \\\\(k^{-1}\\\\). The parties can then use additively homomorphic encryption – specifically Paillier encryption  – in order to combine their equations. For example, \\\\(P_1\\\\) can compute \\\\(c_1 = Enc_{pk}(k_1^{-1} \\cdot H(m))\\\\) and \\\\(c_2 = Enc_{pk}(k_1^{-1} \\cdot x_1 \\cdot r)\\\\) . Then, using scar multiplication (denoted ⊙) and homomorphic addition (denoted ⊕), \\\\( P_2 \\\\) can compute \\\\( (k_2^{-1} ⊙ c_1 ) ⊕ [( k_2^{-1} \\cdot x_2)  ⊙ c_2 ]\\\\), which will be an encryption of \n\n![paillier encryption](/images/two_party_ecdsa/paillier_enc.png)\n\nHowever, proving that each party worked correctly is extremely difficult. For example, the first party must prove that the Paillier encryption includes \\\\(k_1^{-1}\\\\) when the second party only has \\\\(R_1 = k_1 \\cdot G\\\\). it must prove that the Paillier encryptions are to values in the expected range, and more. This can be done, but it results in a protocol that is very expensive.\n\n## their results\n[WIP]\n\n## references\n- [original papger](https://eprint.iacr.org/2017/552.pdf)","slug":"two-party-ecdsa","published":1,"updated":"2023-04-24T06:31:53.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7ea2tt001i6usj2hz07ice","content":"<script\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n  type=\"text/javascript\">\n</script>\n\n<h2 id=\"overview\"><a href=\"#overview\" class=\"headerlink\" title=\"overview\"></a>overview</h2><p>this post is my reading summary of paper Yehuda Lindell 2017: Fast secure two-party ecdsa signing. the implementation could be found in tss-lib (golang), zengo’s library (rust).</p>\n<p>Unlike other schemes like RSA, Schnorr signatures and more, it is particularly hard to construct efficient threshold signature protocols for ECDSA as there is an inverse computaion of \\( k \\).</p>\n<p>In this paper, we consider the specific case of two parties (and thus no honest majority) and con-struct a protocol that is approximately two orders of magnitude faster than the previous best.</p>\n<h2 id=\"Comparing-ECDSA-signing-to-EC-Schnorr-signing\"><a href=\"#Comparing-ECDSA-signing-to-EC-Schnorr-signing\" class=\"headerlink\" title=\"Comparing ECDSA signing to EC-Schnorr signing\"></a>Comparing ECDSA signing to EC-Schnorr signing</h2><p>In both cases, the public verification key is an elliptic curve point \\( Q \\) and the private signing key is \\( x \\) such that \\( Q &#x3D; x \\cdot G \\), where \\( G \\) is the generator point of an EC group of order \\( q \\).<br><img src=\"/images/two_party_ecdsa/schnorr_ecdsa_comparison.png\" alt=\"schnorr ecdsa comparison\"></p>\n<p>Observe that Schnorr signing can be easily distributed since the private key \\( x \\) and the value k are both used in a linear equation.  In contrast, in ECDSA signing, the equation for computing \\( s \\) includes \\( k^{-1} \\). Now, given shares \\(k_1\\), \\(k_2\\) such that \\(k_1 + k_2 &#x3D; k \\bmod q\\) .It is very difficult to compute \\(k_1^{\\prime}\\), \\(k_2^{\\prime}\\) such  that \\(k_1^{\\prime} + k_2^{\\prime} &#x3D; k^{-1} \\bmod q\\)</p>\n<p>two-party protocols for ECDSA signing use multiplicative sharing of \\( x \\) and of \\( k \\). That is, the parties hold \\(x_1\\), \\(x_2\\)  such that \\(x_1 \\cdot x_2 &#x3D; x \\bmod q\\), and in each signing operation they generate \\(k_1\\), \\(k_2\\) such that \\(k_1 \\cdot k_2 &#x3D; k \\bmod q\\). This enables them to easily compute \\(k^{-1}\\) since each party can locally compute  \\(k_i^{\\prime} &#x3D; k_i^{-1} \\bmod q\\), and then \\(k_1^{\\prime}\\), \\(k_2^{\\prime}\\) are multiplicative shares of \\(k^{-1}\\). The parties can then use additively homomorphic encryption – specifically Paillier encryption  – in order to combine their equations. For example, \\(P_1\\) can compute \\(c_1 &#x3D; Enc_{pk}(k_1^{-1} \\cdot H(m))\\) and \\(c_2 &#x3D; Enc_{pk}(k_1^{-1} \\cdot x_1 \\cdot r)\\) . Then, using scar multiplication (denoted ⊙) and homomorphic addition (denoted ⊕), \\( P_2 \\) can compute \\( (k_2^{-1} ⊙ c_1 ) ⊕ [( k_2^{-1} \\cdot x_2)  ⊙ c_2 ]\\), which will be an encryption of </p>\n<p><img src=\"/images/two_party_ecdsa/paillier_enc.png\" alt=\"paillier encryption\"></p>\n<p>However, proving that each party worked correctly is extremely difficult. For example, the first party must prove that the Paillier encryption includes \\(k_1^{-1}\\) when the second party only has \\(R_1 &#x3D; k_1 \\cdot G\\). it must prove that the Paillier encryptions are to values in the expected range, and more. This can be done, but it results in a protocol that is very expensive.</p>\n<h2 id=\"their-results\"><a href=\"#their-results\" class=\"headerlink\" title=\"their results\"></a>their results</h2><p>[WIP]</p>\n<h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ul>\n<li><a href=\"https://eprint.iacr.org/2017/552.pdf\">original papger</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<script\n  src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"\n  type=\"text/javascript\">\n</script>\n\n<h2 id=\"overview\"><a href=\"#overview\" class=\"headerlink\" title=\"overview\"></a>overview</h2><p>this post is my reading summary of paper Yehuda Lindell 2017: Fast secure two-party ecdsa signing. the implementation could be found in tss-lib (golang), zengo’s library (rust).</p>\n<p>Unlike other schemes like RSA, Schnorr signatures and more, it is particularly hard to construct efficient threshold signature protocols for ECDSA as there is an inverse computaion of \\( k \\).</p>\n<p>In this paper, we consider the specific case of two parties (and thus no honest majority) and con-struct a protocol that is approximately two orders of magnitude faster than the previous best.</p>\n<h2 id=\"Comparing-ECDSA-signing-to-EC-Schnorr-signing\"><a href=\"#Comparing-ECDSA-signing-to-EC-Schnorr-signing\" class=\"headerlink\" title=\"Comparing ECDSA signing to EC-Schnorr signing\"></a>Comparing ECDSA signing to EC-Schnorr signing</h2><p>In both cases, the public verification key is an elliptic curve point \\( Q \\) and the private signing key is \\( x \\) such that \\( Q &#x3D; x \\cdot G \\), where \\( G \\) is the generator point of an EC group of order \\( q \\).<br><img src=\"/images/two_party_ecdsa/schnorr_ecdsa_comparison.png\" alt=\"schnorr ecdsa comparison\"></p>\n<p>Observe that Schnorr signing can be easily distributed since the private key \\( x \\) and the value k are both used in a linear equation.  In contrast, in ECDSA signing, the equation for computing \\( s \\) includes \\( k^{-1} \\). Now, given shares \\(k_1\\), \\(k_2\\) such that \\(k_1 + k_2 &#x3D; k \\bmod q\\) .It is very difficult to compute \\(k_1^{\\prime}\\), \\(k_2^{\\prime}\\) such  that \\(k_1^{\\prime} + k_2^{\\prime} &#x3D; k^{-1} \\bmod q\\)</p>\n<p>two-party protocols for ECDSA signing use multiplicative sharing of \\( x \\) and of \\( k \\). That is, the parties hold \\(x_1\\), \\(x_2\\)  such that \\(x_1 \\cdot x_2 &#x3D; x \\bmod q\\), and in each signing operation they generate \\(k_1\\), \\(k_2\\) such that \\(k_1 \\cdot k_2 &#x3D; k \\bmod q\\). This enables them to easily compute \\(k^{-1}\\) since each party can locally compute  \\(k_i^{\\prime} &#x3D; k_i^{-1} \\bmod q\\), and then \\(k_1^{\\prime}\\), \\(k_2^{\\prime}\\) are multiplicative shares of \\(k^{-1}\\). The parties can then use additively homomorphic encryption – specifically Paillier encryption  – in order to combine their equations. For example, \\(P_1\\) can compute \\(c_1 &#x3D; Enc_{pk}(k_1^{-1} \\cdot H(m))\\) and \\(c_2 &#x3D; Enc_{pk}(k_1^{-1} \\cdot x_1 \\cdot r)\\) . Then, using scar multiplication (denoted ⊙) and homomorphic addition (denoted ⊕), \\( P_2 \\) can compute \\( (k_2^{-1} ⊙ c_1 ) ⊕ [( k_2^{-1} \\cdot x_2)  ⊙ c_2 ]\\), which will be an encryption of </p>\n<p><img src=\"/images/two_party_ecdsa/paillier_enc.png\" alt=\"paillier encryption\"></p>\n<p>However, proving that each party worked correctly is extremely difficult. For example, the first party must prove that the Paillier encryption includes \\(k_1^{-1}\\) when the second party only has \\(R_1 &#x3D; k_1 \\cdot G\\). it must prove that the Paillier encryptions are to values in the expected range, and more. This can be done, but it results in a protocol that is very expensive.</p>\n<h2 id=\"their-results\"><a href=\"#their-results\" class=\"headerlink\" title=\"their results\"></a>their results</h2><p>[WIP]</p>\n<h2 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references\"></a>references</h2><ul>\n<li><a href=\"https://eprint.iacr.org/2017/552.pdf\">original papger</a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clh7ea2ti00016usj67y74gw9","tag_id":"clh7ea2tj00036usj4ise7hgw","_id":"clh7ea2tl00086usjbzujh4lv"},{"post_id":"clh7ea2ti00026usjc8dm063h","tag_id":"clh7ea2tj00036usj4ise7hgw","_id":"clh7ea2to000g6usj7lmsbohp"},{"post_id":"clh7ea2ti00026usjc8dm063h","tag_id":"clh7ea2tm000b6usjbzvkhceo","_id":"clh7ea2to000i6usjdby602xj"},{"post_id":"clh7ea2tj00046usj9cm2fgsm","tag_id":"clh7ea2tj00036usj4ise7hgw","_id":"clh7ea2tp000o6usj3a69d5k5"},{"post_id":"clh7ea2tj00046usj9cm2fgsm","tag_id":"clh7ea2tm000b6usjbzvkhceo","_id":"clh7ea2tp000q6usjfz5g62kn"},{"post_id":"clh7ea2tk00066usjhifj5ge1","tag_id":"clh7ea2tj00036usj4ise7hgw","_id":"clh7ea2tq000t6usj395r69dy"},{"post_id":"clh7ea2tk00066usjhifj5ge1","tag_id":"clh7ea2tm000b6usjbzvkhceo","_id":"clh7ea2tq000u6usjcqire091"},{"post_id":"clh7ea2tl00096usj8zec85nf","tag_id":"clh7ea2tj00036usj4ise7hgw","_id":"clh7ea2tq000w6usjhfdqc1md"},{"post_id":"clh7ea2tl00096usj8zec85nf","tag_id":"clh7ea2tm000b6usjbzvkhceo","_id":"clh7ea2tq000x6usjd5l4cgku"},{"post_id":"clh7ea2tm000a6usjg8vd43xw","tag_id":"clh7ea2tq000v6usjbj2ueid7","_id":"clh7ea2tr000z6usjbng5crf4"},{"post_id":"clh7ea2tn000d6usjb24y5x0k","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2tr00116usjhes92arq"},{"post_id":"clh7ea2tn000f6usj3zg9fmwl","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2tr00136usj63jfeom5"},{"post_id":"clh7ea2to000h6usjhx9odovw","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2ts00156usjc7w468kd"},{"post_id":"clh7ea2to000k6usj7ksx9owl","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2ts00176usj8zs6gwaf"},{"post_id":"clh7ea2tp000l6usjfku62qis","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2ts00196usj2xgrh33x"},{"post_id":"clh7ea2tp000n6usj2gidb2ne","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2ts001b6usj5vw0ec5f"},{"post_id":"clh7ea2tp000p6usj5aqdc9r8","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2ts001d6usj0ykq3b9z"},{"post_id":"clh7ea2tp000s6usj4jqheaep","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2ts001f6usj4qxl2hlg"},{"post_id":"clh7ea2tp000s6usj4jqheaep","tag_id":"clh7ea2ts001e6usjdmz6cuan","_id":"clh7ea2tt001g6usj19ea5nxg"},{"post_id":"clh7ea2tt001h6usj465z51mz","tag_id":"clh7ea2tq000y6usjego287o5","_id":"clh7ea2tu001j6usj3mhn9a3q"},{"post_id":"clh7ea2tt001i6usj2hz07ice","tag_id":"clh7ea2tq000v6usjbj2ueid7","_id":"clh7ea2tu001m6usj6g0d8y93"},{"post_id":"clh7ea2tt001i6usj2hz07ice","tag_id":"clh7ea2tu001k6usjfpnj0xfl","_id":"clh7ea2tu001n6usjfcnof23o"},{"post_id":"clh7ea2tt001i6usj2hz07ice","tag_id":"clh7ea2tu001l6usj7a3r8x2l","_id":"clh7ea2tu001o6usjfntz0j0o"}],"Tag":[{"name":"blockchain","_id":"clh7ea2tj00036usj4ise7hgw"},{"name":"geth","_id":"clh7ea2tm000b6usjbzvkhceo"},{"name":"cryptography","_id":"clh7ea2tq000v6usjbj2ueid7"},{"name":"rust","_id":"clh7ea2tq000y6usjego287o5"},{"name":"cargo","_id":"clh7ea2ts001e6usjdmz6cuan"},{"name":"mpc","_id":"clh7ea2tu001k6usjfpnj0xfl"},{"name":"ecdsa","_id":"clh7ea2tu001l6usj7a3r8x2l"}]}}