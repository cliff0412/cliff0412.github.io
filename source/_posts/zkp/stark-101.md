---
title: stark_101
date: 2023-11-03 17:07:33
tags: [cryptography,zkp]
---
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>

# startk 101

## trace and low degree extension
the objective is to develop a STARK prover for the FibonacciSq sequence over a finite field. The FibonacciSq sequence is defined by the recurrence relation
\\[ a_{n+2} = a_{n+1} ^2 + a_n ^2 \\]

the statement is: **I know a FieldElement \\(X\in \mathbb{F}\\) such that the 1023rd element of the FibonacciSq sequence starting with \\(1, X\\) is \\(2338775057\\)**

The underlying field of this class is \\(\mathbb{F}_{3221225473}\\) (\\(3221225473 = 3 \cdot 2^{30} + 1\\)), so all operations are done modulo 3221225473.


### FibonacciSq Trace
 let's construct a list `a` of length 1023, whose first two elements will be FieldElement objects representing 1 and 3141592, respectively. The next 1021 elements will be the FibonacciSq sequence induced by these two elements. `a` is called the **trace** of FibonacciSq, or, when the context is clear, the trace.

### Thinking of Polynomials
We now want to think of the sequence as the evaluation of some polynomial \\(f\\) of degree 1022.
We will choose the domain to be some subgroup \\(G \subseteq \mathbb{F}^\times\\) of size 1024, for reasons that will become clear later.

(Recall that \\(\mathbb{F}^\times\\) denotes the multiplicative group of \\(\mathbb{F}\\), which we get from \\(\mathbb{F}\\) by omitting the zero element with the induced multiplication from the field. A subgroup of size 1024 exists because \\(\mathbb{F}^\times\\) is a cyclic group of size \\(3\cdot 2^{30}\\), so it contains a subgroup of size \\(2^i\\) for any \\(0 \leq i \leq 30\\)).
#### Find a Group of Size 1024
If we find an element \\(g \in \mathbb{F}\\) whose (multiplicative) order is 1024, then \\(g\\) will generate such a group. Create a list called `G` with all the elements of \\(G\\), such that \\(G[i] := g^i\\).


### Evaluating on a Larger Domain
then, interpolating `G` over `a` we get a polynomial `f`. The trace, viewed as evaluations of a polynomial \\(f\\) on \\(G\\), can now be extended by evaluating \\(f\\) over a larger domain, thereby creating a Reed-Solomon error correction code.

#### Cosets
To that end, we must decide on a larger domain on which \\(f\\) will be evaluated. We will work with a domain that is 8 times larger than \\(G\\). <br>A natural choice for such a domain is to take some group \\(H\\) of size 8192 (which exists because 8192 divides \\(|\mathbb{F}^\times|\\)), and shift it by the generator of \\(\mathbb{F}^\times\\), thereby obtaining a [coset](https://en.wikipedia.org/wiki/Coset) of \\(H\\).

Create a list called `H` of the elements of \\(H\\), and multiply each of them by the generator of \\(\mathbb{F}^\times\\) to obtain a list called `eval_domain`. In other words, `eval_domain` = \\(\\{w\cdot h^i | 0 \leq i <8192  \\}\\) for \\(h\\) the generator of \\(H\\) and \\(w\\) the generator of \\(\mathbb{F}^\times\\).


#### Evaluate on a Coset
```python
f = interpolate_poly(G[:-1], a)
f_eval = [f(d) for d in eval_domain]
```

### Commitments
We will use [Sha256](https://en.wikipedia.org/wiki/SHA-2)-based [Merkle Trees](https://en.wikipedia.org/wiki/Merkle_tree) as our commitment scheme.
```python
from merkle import MerkleTree
f_merkle = MerkleTree(f_eval)
```

### Channel
Theoretically, a STARK proof system is a protocol for interaction between two parties - a prover and a verifier. In practice, we convert this interactive protocol into a non-interactive proof using the [Fiat-Shamir Heuristic](https://en.wikipedia.org/wiki/Fiat%E2%80%93Shamir_heuristic). In this tutorial you will use the `Channel` class, which implements this transformation. This channel replaces the verifier in the sense that the prover (which you are writing) will send data, and receive random numbers or random `FieldElement` instances.




## constraints
In this part, we are going to create a set of constraints over the trace `a`. 
### Step 1 - FibonacciSq Constraints
For `a` to be a correct trace of a FibonacciSq sequence that proves our claim:
1. The first element has to be 1, namely \\(a[0] = 1\\).
2. The last element has to be 2338775057, namely \\(a[1022] = 2338775057\\).
3. The FibonacciSq rule must apply, that is - for every \\(i<1021\\), \\(a[i+2]=a[i+1]^2+a[i]^2\\).


### Step 2 - Polynomial Constraints
Recall that `f` is a polynomial over the trace domain, that evaluates exactly to `a` over \\(G \setminus \{g^{1023}\}\\) where \\(G=\{g^i : 0\leq i\leq 1023\}\\) is the "small" group generated by \\(g\\).<br>

We now rewrite the above three constraints in a form of polynomial constraints over `f`:
1. \\(a[0] = 1\\) is translated to the polynomial \\(f(x) - 1\\), which evalutes to 0 for \\(x = g^0\\) (note that \\(g^0\\) is \\(1\\)). <br>
2. \\(a[1022] = 2338775057\\) is translated to the polynomial \\(f(x) - 2338775057\\), which evalutes to 0 for \\(x = g^{1022}\\). <br>
3. \\(a[i+2]=a[i+1]^2+a[i]^2\\) for every \\(i<1021\\) is translated to the polynomial \\(f(g^2 \cdot x) - (f(g \cdot x))^2 - (f(x))^2\\), which evaluates to 0 for \\(x \in G \backslash \{g^{1021}, g^{1022}, g^{1023}\}\\). <br><br>

### Step 3 - Rational Functions (That are in Fact Polynomials)

Each of the constraints above is represented by a polynomial \\(u(x)\\) that supposedly evaluates to \\(0\\) on certain elements of the group \\(G\\). That is, for some \\(x_0, \ldots, x_k \in G\\), we claim that

\\[u(x_0) = \ldots = u(x_k) = 0\\]

(note that for the first two constaints, \\(k=0\\) because they only refer to one point and for the third \\(k=1021\\)).

This is equivalent to saying that \\(u(x)\\) is divisible, as a polynomial, by all of \\(\{(x-x_i)\}_{i=0}^k\\), or, equivalently, by

\\[\prod_{i=0}^k (x-x_i)\\]

Therefore, each of the three constraints above can be written as a rational function of the form:

\\[\frac{u(x)}{\prod_{i=0}^k (x-x_i)}\\]

for the corresponding \\(u(x)) and \\(\{x_i\}_{i=0}^k). In this step we will construct these three rational functions and show that they are indeed polynomials.

# references
- https://github.com/starkware-industries/stark101
- [startk_math](https://medium.com/starkware/tagged/stark-math)
- [starkEx deep dive](https://medium.com/starkware/starkdex-deep-dive-introduction-7b4ef0dedba8)
- [coset] https://en.wikipedia.org/wiki/Coset